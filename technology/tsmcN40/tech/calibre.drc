//****************************************************************************************************
//* CALIBRE DRC COMMAND FILE - CN45_6M_4X1Z.27a  08/31/2020
//* FOR TSMC N45LP/LPG,N40LP/LPG/LP+,N40G(N45GS) LOGIC/MS_RF 1P6M PROCESS WITH 4X1Z METAL OPTION
//* DRC COMMAND FILE DOCUMENT: T-N45-CL-DR-001-C1 VER 2.7a
//* DESIGN RULE DOCUMENT: T-N45-CL-DR-001 VER 2.7
//*                       T-N40-CM-DR-004 VER 1.1
//****************************************************************************************************
//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************

/* SWITCH DEFINITION START */
//

//  OPTION SETUP
//================
//#DEFINE SANITY_CHECKER_FOR_PDE_AND_CO_PLACEMENT  //Turn on to check DOD.R.4R/CO.S.7R/OD.DN.4-9R/PO.DN.4-9R for layout effect
#DEFINE GUIDELINE_ESD        // Turn on to check ESD protection guidelines
#DEFINE DATATYPE_WARNING     // Turn on to flag NW/OD/PO warning datatype
#DEFINE NW_SUGGESTED       // Turn on to use conservative way to check NW.S.3/NW.S.4

#DEFINE FRONT_END            // Turn on to check Front-End rules
#DEFINE BACK_END             // Turn on to check Back-End rules
//#DEFINE FULL_CHIP            // Turn on for chip level design
//#DEFINE WITH_SEALRING        // Turn on if sealring is assembled in chip
 //#DEFINE P3_SEALRING       // Turn on if using old sealring (Phase 3)
 //#DEFINE P3R_SEALRING      // Turn on if using old sealring (Phase 3R)
 //#DEFINE P4_SEALRING       // Turn on if using old sealring (Phase 4)
//#DEFINE WIRE_BOND            // Turn off if using flip-chip package (FBEOL option2/4); Turn on if using wire-bond package (FBEOL option1/3)

#DEFINE WITH_APRDL           // Turn on if with AlCu RDL (FBEOL option3/4); Turn off if without AlCu RDL (FBEOL option1/2)
//#DEFINE WLCSP              // Turn on for WLCSP package
#DEFINE WITH_POLYIMIDE       // Turn off when process without Polyimide or Polyimide is derived from logic operation
//#DEFINE SINGLE_PASSIVATION // Turn on for single passivation process

//#DEFINE COMPATIBLE_MODE    // Turn on if you want to run your product for both N45LP and N40LP process

//#DEFINE N45_LP                // Turn on if CLN45LP process is used
#DEFINE N40_LP              // Turn on if CLN40LP process is used
//#DEFINE N45_LPG             // Turn on if CLN45LPG process is used
//#DEFINE N40_LPG             // Turn on if CLN40LPG process is used
//#DEFINE N40_G               // Turn on if N40G process is used


#DEFINE eDRAM                // Turn on if using eDRAM process
//#DEFINE AP_20K_THICKNESS   //Turn on for 20K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE AP_28K_THICKNESS   //Turn on for 28K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE AP_36K_THICKNESS   //Turn on for 36K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE MIXED_SCHEME       // Turn on to allow datatype 0 for M(y,z,r,u)/VIA(y,z,r,u) and datatype 1 for DM(y,z,r,u)
//#DEFINE MOM_18V            // Turn on if max voltage applied on MOM is 0.9V, 1.1V, 1.2V, or 1.8V
//#DEFINE MOM_25V            // Turn on if max voltage applied on MOM is 2.5V
#DEFINE MOM_33V              // Turn on if max voltage applied on MOM is 3.3V, or 5.0V

#DEFINE HVMOS_25           // Turn on if 5V HVMOS which is fabricated with 2.5V IO Gox. (N45LP/N40LP only)
//#DEFINE HVMOS_18           // Turn on if 5V HVMOS which is fabricated with 1.8V IO Gox. (N40LP only)

#DEFINE CHECK_LOW_DENSITY    // Turn on to check OD/PO/Metal local low density.
//#DEFINE CHECK_PRBOUNDARY_DENSITY  // Turn to check Mx.DN.6R/Mx.DN.7R by PrBoundary

//#DEFINE SKIP_POS2_BOUNDARY // Turn on to skip PO/OD boundary in PO.S.2 check in cell level.
//#DEFINE Mx_S_8_IO_NET      // Turn on to check all I/O metal net in Mx.S.8
//#DEFINE IND_INTER_MET_VIA  // Turn on to allow inter metal/via in inductor
#DEFINE DVIAxR3_For_NonFlipChip  // DVIAx.R.3 is must for Flip-Chip PAD application and also strongly recommended for Non Flip-Chip PAD
			     	 // Turn off can skip DVIAx.R.3 check for Non Flip-Chip PAD application without UBM
#DEFINE VERTICAL_TCD_PATTERN // Turn on if gate direction in dummy TCDs is vertical. Turn off for horizontal.
//#DEFINE CYBER_SHUTTLE      // Turn on to check DTCD.R.5 for cyber shuttle.
//#DEFINE ICOVL              // Turn on to check ICOVL (In Chip Overlay) Rules
//#DEFINE TSMC_ROTATE        // Turn on if you know your tapeout will be rotated in TSMC
//#DEFINE DISCONNECT_ALL_RESISTOR  // Turn on to disconnect all resistors between pad and device for Latch-Up rule check.
//#DEFINE CONNECT_ALL_RESISTOR     // Turn on to connect all resistors between pad and device for Latch-Up rule check.

//#DEFINE DEFINE_PAD_BY_TEXT // Turn on to recognize IO PAD by following text

VARIABLE PAD_TEXT  "?"       // pin name of PAD
VARIABLE VDD_TEXT  "VDD?"    // pin name of VDD
VARIABLE VSS_TEXT  "VSS?"    // pin name of VSS
//#DEFINE CHECK_FLOATING_GATE_BY_TEXT // Turn on to waive PO.R.8 false error in cell or chip with empty IP by following text
//#DEFINE CHECK_FLOATING_GATE_BY_PRIMARY_TEXT   // Turn on to waive PO.R.8 false error in cell by following primary text
VARIABLE IP_PIN_TEXT  "?"    // pin name of IP

//#DEFINE ChipWindowUsed  // Turn on to specify chip boundary directly by following variables
VARIABLE xLB   0.0        // x-coordinate of left-bottom corner for user defined chip window
VARIABLE yLB   0.0        // y-coordinate of left-bottom corner for user defined chip window
VARIABLE xRT   1000.0     // x-coordinate of right-top corner for user defined chip window
VARIABLE yRT   1000.0     // y-coordinate of right-top corner for user defined chip window

//  OPTION SETUP OF DFM RULES
//===============================
//#DEFINE DFM               // Turn on to check DFM rules
//#DEFINE DFM_ONLY          // Turn on to check DFM rules only
 #DEFINE Required           // Turn on to check Action-Required rules
 #DEFINE Recommended        // Turn on to check Recommendations
    #DEFINE First_priority  // Turn on to check First priority recommendations
    #DEFINE Parametric      // Turn on to check SPICE related recommendations for better simulation accuracy
    #DEFINE Systematic      // Turn on to check Systematic related recommendations
    #DEFINE Defect          // Turn on to check Defect related recommendations
 #DEFINE Analog             // Turn on to check Analog Recommendations(must select by layer RRuleAnalog or cell CellsForRRuleAnalog)
 #DEFINE Guideline          // Turn on to check Guidelines

VARIABLE CellsForRRuleRequired "*"         // include cell in Action-Required rules check
VARIABLE CellsForRRuleRecommended "*"      // include cell in Recommendations check
VARIABLE CellsForRRuleAnalog " "           // include cell in Analog rules check (default is empty)
VARIABLE CellsForRRuleGuideline "*"        // include cell in Guidleline check
VARIABLE ExclCellsForRRuleRequired " "     // exclude cell from Action-Required rules check
VARIABLE ExclCellsForRRuleRecommended " "  // exclude cell from Recommendations check
VARIABLE ExclCellsForRRuleAnalog " "       // exclude cell from Analog rules check
VARIABLE ExclCellsForRRuleGuideline " "    // exclude cell from Guideline check

// Action-required rules
//===================================
  #DEFINE _POEX2_
  #DEFINE _POS5_
  #DEFINE _POS6_
// Recommendations
//===============================
  #DEFINE _ODW1_        // SPICE related
  #DEFINE _ODS1_        // Defect related
  #DEFINE _ODDN4_       // SPICE related
  #DEFINE _ODDN5_       // SPICE related
  #DEFINE _ODDN6_       // SPICE related
  #DEFINE _ODDN7_       // SPICE related
  #DEFINE _ODDN8_       // SPICE related
  #DEFINE _ODDN9_       // SPICE related
  #DEFINE _SRDODS3_     // Systematic Others
  #DEFINE _SRDODDN1_    // 1st priority related
  #DEFINE _DNWEN1_      // Systematic related
  #DEFINE _NWRODS3_     // SPICE related
  #DEFINE _NWRSTIEN2_   // SPICE related
  #DEFINE _POS1_        // Defect related
  #DEFINE _POS2_        // Systematic and SPICE related (for LP only)
  #DEFINE _POS4_1_      // SPICE related
  #DEFINE _POS17_       // Systematic and SPICE related
  #DEFINE _POS18_       // SPICE related (for GS only)
  #DEFINE _POEX1_       // Systematic and SPICE related
  #DEFINE _PODN4_       // SPICE related
  #DEFINE _PODN5_       // SPICE related
  #DEFINE _PODN6_       // SPICE related
  #DEFINE _PODN7_       // SPICE related
  #DEFINE _PODN8_       // SPICE related
  #DEFINE _PODN9_       // SPICE related
  #DEFINE _SRDPOS1_     // Systematic SPICE
  #DEFINE _SRDPOL1_     // Systematic Litho,OPC
  #DEFINE _SRDPOL3_     // Systematic Litho, OPC
  #DEFINE _SRDPODN1_    // 1st priority related
  #DEFINE _ESDIMPEN1_   // Systematic related
  #DEFINE _COS3_        // Systematic and Defect related
  #DEFINE _COEN1_       // Systematic and SPICE related
  #DEFINE _COEN11_      // Systematic and SPICE related
  #DEFINE _COEN3_       // Systematic and SPICE related
  #DEFINE _COS7_        // SPICE related
  #DEFINE _M1S1_        // Defect related
  #DEFINE _M1A1_        // Systematic and Defect related
  #DEFINE _M1EN1_M1EN2_ // 1st priority, Systematic, and SPICE related
  #DEFINE _M1EN5_       // Defect related
  #DEFINE _M1DN6_     // Systematic related
  #DEFINE _VIA1EN1_VIA1EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M2S1_               // Defect related
  #DEFINE _M2A1_               // Systematic and Defect related
  #DEFINE _M2EN1_M2EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M2DN6_              // Systematic related

  #DEFINE _VIA2EN1_VIA2EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M3S1_               // Defect related
  #DEFINE _M3A1_               // Systematic and Defect related
  #DEFINE _M3EN1_M3EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M3DN6_              // Systematic related
  #DEFINE _MxDN7_M1_M2_M3_    // Systematic related

  #DEFINE _VIA3EN1_VIA3EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M4S1_               // Defect related
  #DEFINE _M4A1_               // Systematic and Defect related
  #DEFINE _M4EN1_M4EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M4DN6_              // Systematic related
  #DEFINE _MxDN7_M2_M3_M4_    // Systematic related

  #DEFINE _VIA4EN1_VIA4EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M5S1_               // Defect related
  #DEFINE _M5A1_               // Systematic and Defect related
  #DEFINE _M5EN1_M5EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M5DN6_              // Systematic related
  #DEFINE _MxDN7_M3_M4_M5_    // Systematic related

  #DEFINE _MxDN8_              // 1st priority related
  #DEFINE _M6W3_               // Systematic related
  #DEFINE _ROMR3_              // 1st priority related
  #DEFINE _DTCDDN1_
  #DEFINE _MOMDN1_M1_
  #DEFINE _MOMDN1_M2_
  #DEFINE _MOMDN1_M3_
  #DEFINE _MOMDN1_M4_
  #DEFINE _MOMDN1_M5_
  #DEFINE _INDDN8_
  #DEFINE _INDDN9_

// Analog Recommendations
//==========================
  #DEFINE _POS14m_
  #DEFINE _POEN1m_
  #DEFINE _POEN2m_
  #DEFINE _POEN3m_
  #DEFINE _POS5m_
  #DEFINE _POS6m_
  #DEFINE _POS61m_
  #DEFINE _POEX1m_
  #DEFINE _BJTR2_
  #DEFINE _BJTR7_
  #DEFINE _ANR17_
  #DEFINE _ANR20_
// Guidelines
//==========================
  #DEFINE _NWR1_
  #DEFINE _DNWR6_
  #DEFINE _NWRODR3_NWRSTIR3_
  #DEFINE _NWRODR8_NWRSTIR4_
  #DEFINE _RESR15_
  #DEFINE _RESR16_
  #DEFINE _RESR17_
  #DEFINE _RESR18_
  #DEFINE _RESR19_
  #DEFINE _RESR20_
  #DEFINE _COS6_
  #DEFINE _COR5_




// ENVIRONMENT SETUP
//---------------------

PRECISION    1000
RESOLUTION      5    // For 0.005um layout grid  

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep"  // HIER
DRC KEEP EMPTY NO
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
FLAG NONSIMPLE PATH YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO
LAYOUT PROCESS BOX RECORD YES
//
/* SWITCH DEFINITION END */


//OPTION DEPENDENCE
//=========================


#IFDEF N40_LP
#DEFINE HALF_NODE
#ENDIF


#IFDEF N45_LPG
#DEFINE LPG
#ENDIF

#IFDEF N40_LPG
#DEFINE HALF_NODE
#DEFINE LPG
#ENDIF

#IFDEF N40_G  
#DEFINE HALF_NODE
#DEFINE GS
#ENDIF


#IFDEF FULL_CHIP
#DEFINE CHECK_LOW_DENSITY
#ENDIF


#IFDEF HALF_NODE
#IFNDEF GS
#DEFINE WIDE_ADJUST
#ENDIF
#ENDIF

#IFDEF P3_SEALRING
#DEFINE OLD_SEALRING
#ENDIF
#IFDEF P3R_SEALRING
#DEFINE OLD_SEALRING
#ENDIF

#IFDEF DFM_ONLY
#DEFINE DFM
#ENDIF



//RULES VALUE VARIABLES
//=======================
VARIABLE METAL_LOW_DEN_WINDOW_SIZE 125
VARIABLE METAL_LOW_DEN_WINDOW_STEP 62.5
VARIABLE METAL_HIGH_DEN_WINDOW_SIZE 125
VARIABLE METAL_HIGH_DEN_WINDOW_STEP 62.5



VARIABLE  GRID      0.005
VARIABLE  BIG_AREA  4000000

VARIABLE  DNW_W_1   3.0
VARIABLE  DNW_S_1   3.5
VARIABLE  DNW_S_2   2.5
VARIABLE  DNW_S_3   1.65
VARIABLE  DNW_S_4   0.8
VARIABLE  DNW_S_5   1.0

VARIABLE  DNW_EN_3  0.48
VARIABLE  DNW_O_1   0.4
VARIABLE  OD_W_1    0.06
VARIABLE  OD_W_2    0.12
VARIABLE  OD_W_2_1  10.0 // user value
#IFDEF GS
VARIABLE  OD_W_2_2  1.50 // user value
#ENDIF
VARIABLE  OD_W_3    0.32 // user value
VARIABLE  OD_W_4    0.17
VARIABLE  OD_S_1    0.08
VARIABLE  OD_S_2    0.15
VARIABLE  OD_S_3    0.10
VARIABLE  OD_S_3_L  0.14
VARIABLE  OD_S_3_W  0.12
VARIABLE  OD_S_3_1    0.11
VARIABLE  OD_S_3_1_L  0.14
VARIABLE  OD_S_3_1_W  0.12

VARIABLE  OD_S_4    0.17
VARIABLE  OD_S_5    0.15
VARIABLE  OD_A_1    0.035
VARIABLE  OD_A_1_W  0.06
VARIABLE  OD_A_1_L  0.26
VARIABLE  OD_A_2    0.055
VARIABLE  OD_A_2_L  0.21
VARIABLE  OD_A_3    0.04
VARIABLE  OD_A_4    0.077
VARIABLE  OD_A_4_L  0.21
#IFDEF GS
VARIABLE  OD_A_5    300 // user value
VARIABLE  OD_A_5_S1 0.22
VARIABLE  OD_A_5_S2 0.08
#ENDIF
#IFNDEF WIDE_ADJUST
VARIABLE  OD_L_1    0.4
VARIABLE  OD_L_2    60
#ELSE
VARIABLE  OD_L_1    0.44
VARIABLE  OD_L_2    66
#ENDIF
VARIABLE  OD_L_1_W  0.12
VARIABLE  OD_L_2_W  0.12
VARIABLE  OD_DN_1    0.25
VARIABLE  OD_DN_1_1  0.75
VARIABLE  OD_DN_2    0.2
VARIABLE  OD_DN_2_W  150
VARIABLE  OD_DN_2_S  75
VARIABLE  OD_DN_2_E  37.5
VARIABLE  OD_DN_2_1 0.8
VARIABLE  OD_DN_2_1_W 150
VARIABLE  OD_DN_2_1_S 75
VARIABLE  OD_DN_2_1_E 37.5
VARIABLE  OD_DN_2_2 0.9
VARIABLE  OD_DN_2_2_W 150
VARIABLE  OD_DN_2_2_S 75
VARIABLE  OD_DN_2_2_E 37.5
VARIABLE  OD_DN_3 0.2
VARIABLE  OD_DN_3_W 150
VARIABLE  OD_DN_3_S 75
VARIABLE  OD_DN_3_E 37.5
VARIABLE  OD_DN_3_1 0.8
VARIABLE  OD_DN_3_1_W 150
VARIABLE  OD_DN_3_1_S 75
VARIABLE  OD_DN_3_1_E 37.5
VARIABLE  OD_DN_3_2 0.9
VARIABLE  OD_DN_3_2_W 150
VARIABLE  OD_DN_3_2_S 75
VARIABLE  OD_DN_3_2_E 37.5
VARIABLE  ODRZ_X    0.11
VARIABLE  ODRZ_Y    0.08
VARIABLE  ODRZ_S    0.16

VARIABLE  SRDOD_W_1     0.1
VARIABLE  SRDOD_W_2	0.5
VARIABLE  SRDOD_S_1     0.12
VARIABLE  SRDOD_S_1_1   0.12
VARIABLE  SRDOD_S_2     0.05
VARIABLE  SRDOD_S_3     0.03
VARIABLE  SRDOD_S_4     0.17
VARIABLE  SRDOD_S_5     0.15
VARIABLE  SRDOD_S_6R    0.35
VARIABLE  SRDOD_S_7     0.08
VARIABLE  SRDOD_S_8     0.60
VARIABLE  SRDOD_S_9     0.00
VARIABLE  SRDOD_S_10    1.20
VARIABLE  SRDOD_S_11    0.14
VARIABLE  SRDOD_EN_1    0.08
VARIABLE  SRDOD_EN_2    0.60
VARIABLE  SRDOD_A_1     0.05
VARIABLE  SRDOD_A_1_W   0.06
VARIABLE  SRDOD_A_1_L   0.26
VARIABLE  SRDOD_A_3     0.04
VARIABLE  SRDOD_A_4     0.077
VARIABLE  SRDOD_A_4_L   0.21
VARIABLE  SRDOD_L_1	0.5
VARIABLE  SRDOD_L_2	10

VARIABLE  NW_W_1    0.34
VARIABLE  NW_S_1    0.34
VARIABLE  NW_S_2    0.80
VARIABLE  NW_S_3    1.0
VARIABLE  NW_S_4    1.0
VARIABLE  NW_S_5    0.08
VARIABLE  NW_S_6    0.08
VARIABLE  NW_S_6_1  0.16
VARIABLE  NW_S_7    0.22
VARIABLE  NW_EN_1   0.08
VARIABLE  NW_EN_2   0.08
VARIABLE  NW_EN_2_1 0.16
VARIABLE  NW_EN_3   0.22
VARIABLE  NW_A_1    0.64
VARIABLE  NW_A_2    0.64
VARIABLE  NWROD_W_1   1.8
VARIABLE  NWROD_S_1   1.0
VARIABLE  NWROD_S_2   0.3
VARIABLE  NWROD_EN_1  1.0
VARIABLE  NWROD_EN_2  0.3
VARIABLE  NWROD_O_1   0.4
VARIABLE  NWRSTI_W_1  1.8
VARIABLE  NWRSTI_S_1  1.0
VARIABLE  NWRSTI_EN_1 0.4
VARIABLE  NWRSTI_EN_2 0.3
VARIABLE  NWRSTI_EN_3 0.3
VARIABLE  NWRSTI_EX_1 0.3
VARIABLE  NWROD_R_1_L_M	20
VARIABLE  NWROD_R_1_W_M	1.8
VARIABLE  NWROD_R_1_S_M	5
VARIABLE  NWRSTI_R_1_L_M 20
VARIABLE  NWRSTI_R_1_W_M 1.8
VARIABLE  NWRSTI_R_1_S_M 5

VARIABLE  NTN_W_1    0.34
VARIABLE  NTN_W_2    0.30
VARIABLE  NTN_W_2_1  0.20
VARIABLE  NTN_W_3    1.20


VARIABLE  NTN_W_4    0.8
VARIABLE  NTN_W_5    0.5
VARIABLE  NTN_S_1    0.34
VARIABLE  NTN_S_2    0.38
VARIABLE  NTN_S_3    1.0
VARIABLE  NTN_EN_1   0.26
VARIABLE  NTN_EX_1   0.35
VARIABLE  NTN_A_1    0.64
VARIABLE  NTN_A_2    0.64

VARIABLE  OD2_W_1     0.34
VARIABLE  OD2_W_2     0.34
VARIABLE  OD2_W_3     0.34
VARIABLE  OD2_S_1     0.34
VARIABLE  OD2_S_2     0.20
VARIABLE  OD2_S_3     0.25
VARIABLE  OD2_S_4     0.34
VARIABLE  OD2_S_5     0.34
VARIABLE  OD2_S_6     0.34
VARIABLE  OD2_S_7     0.34
VARIABLE  OD2_S_8     0.34
VARIABLE  OD2_EN_1    0.25
VARIABLE  OD2_EX_1    0.34
VARIABLE  OD2_EX_2    0.34
VARIABLE  OD2_EX_3    0.20
VARIABLE  OD2_O_1     0.34

VARIABLE  DCO_W_1     0.34
VARIABLE  DCO_W_2     0.34
VARIABLE  DCO_S_1     0.34
VARIABLE  DCO_S_2     0.05
VARIABLE  DCO_S_3     0.16
VARIABLE  DCO_S_4     0.09
VARIABLE  DCO_S_5     0.34
VARIABLE  DCO_S_6     0.34
VARIABLE  DCO_S_8     0.34
VARIABLE  DCO_S_9     0.34
VARIABLE  DCO_S_10    0.34
VARIABLE  DCO_EN_1    0.16
VARIABLE  DCO_EN_2    0.09
VARIABLE  DCO_EX_1    0.34
VARIABLE  DCO_EX_2    0.34
VARIABLE  DCO_EX_3    0.05
VARIABLE  DCO_A_1     0.7
VARIABLE  DCO_A_2     0.7
VARIABLE  DCO_O_1     0.34
VARIABLE  DCO_LPP_R_5     0.14
VARIABLE  DCO_LPP_R_5_2     0.19
VARIABLE  DCO_LPP_S_2     0.04
VARIABLE  DCO_LPP_A_1     0.7
VARIABLE  DCO_LPP_A_1_1   0.5292
VARIABLE  DCO_LPP_A_2     0.7
VARIABLE  DCO_LPP_A_2_1   0.5292
VARIABLE  DCO_LPP_EX_3    0.04

VARIABLE  DCO_LPP_W_1     0.34 //user value
VARIABLE  DCO_LPP_S_1     0.34
VARIABLE  DCO_LPP_S_3     0.16
VARIABLE  DCO_LPP_S_4     0.09
VARIABLE  DCO_LPP_S_6     0.34
VARIABLE  DCO_LPP_EN_1    0.16
VARIABLE  DCO_LPP_EN_2    0.09
VARIABLE  OD12_W_1     0.34
VARIABLE  OD12_W_3     0.07
VARIABLE  OD12_S_1     0.34
VARIABLE  OD12_S_2     0.05
VARIABLE  OD12_S_3     0.16
VARIABLE  OD12_S_4     0.09
VARIABLE  OD12_S_6     0.18
VARIABLE  OD12_EN_1    0.16
VARIABLE  OD12_EN_2    0.09
VARIABLE  OD12_EX_3    0.05
VARIABLE  OD12_A_1     0.64
VARIABLE  OD12_A_2     0.64
VARIABLE  OD12_R_4     0.14
#IFDEF COMPATIBLE_MODE
VARIABLE  OD25_33_W_1 0.55
VARIABLE  OD25_33_W_2 0.44
#ELSE
#IFDEF HALF_NODE
VARIABLE  OD25_33_W_1 0.55
VARIABLE  OD25_33_W_2 0.44
#ELSE
VARIABLE  OD25_33_W_1 0.50
VARIABLE  OD25_33_W_2 0.40
#ENDIF
#ENDIF
#IFDEF GS
VARIABLE  OD25_18_W_1GS 0.27
#ENDIF
VARIABLE  OD25_18_W_1 0.25

VARIABLE  OD25_33_W_3 1.2
VARIABLE  OD25_18_W_2 1.2

#IFDEF GS
VARIABLE  OD18_15_W_1 0.105
#ELSE
VARIABLE  OD18_15_W_1 0.125
#ENDIF
VARIABLE  PO_W_1        0.04
VARIABLE  PO_W_2        0.27
VARIABLE  PO_W_3        0.42
VARIABLE  PO_W_4        0.15

#IFDEF GS
VARIABLE  PO_W_6A       0.04
VARIABLE  PO_W_6B       0.045
VARIABLE  PO_W_6C       0.05
VARIABLE  PO_W_6D       0.06
VARIABLE  PO_W_6E       0.07
VARIABLE  PO_W_6F       0.08
VARIABLE  PO_W_6G       10
#ENDIF
VARIABLE  PO_W_7        0.17
#IFNDEF GS
VARIABLE  PO_W_8        10
#ENDIF
VARIABLE  PO_S_1        0.10
#IFDEF GS
VARIABLE  PO_S_2_W      0.08
VARIABLE  PO_S_2A      0.14 // user value
VARIABLE  PO_S_2B      0.16
VARIABLE  PO_S_2C      0.20
VARIABLE  PO_S_2_1      0.14
VARIABLE  PO_S_2_1_W    0.08
VARIABLE  PO_S_2_1_1    0.32 // user value
VARIABLE  PO_S_2_1_1_W  0.08 // user value
#ELSE
VARIABLE  PO_S_2_W      0.06
#IFDEF COMPATIBLE_MODE
VARIABLE  PO_S_2A     0.13 // user value
#ELSE
#IFDEF HALF_NODE
VARIABLE  PO_S_2A     0.13 // user value
#ELSE
VARIABLE  PO_S_2A     0.12 // user value
#ENDIF
#ENDIF
VARIABLE  PO_S_2B     0.22
VARIABLE  PO_S_2C     0.32
VARIABLE  PO_S_2_1      0.14
VARIABLE  PO_S_2_1_W    0.06
#ENDIF
VARIABLE  PO_S_3        0.22
VARIABLE  PO_S_4        0.03
VARIABLE  PO_S_4_1      0.11
VARIABLE  PO_S_4_1_A    0.0121
VARIABLE  PO_S_6        0.04
VARIABLE  PO_S_6_L      0.06
VARIABLE  PO_S_6_1      0.05
VARIABLE  PO_S_6_1_L1   0.06
VARIABLE  PO_S_6_1_L2   0.1
VARIABLE  PO_S_7        0.16
VARIABLE  PO_S_7_L      0.14
VARIABLE  PO_S_7_W      0.12
VARIABLE  PO_S_9        0.18
VARIABLE  PO_S_10       0.11
VARIABLE  PO_S_10_Q     0.07
VARIABLE  PO_S_10_E     0.035
VARIABLE  PO_S_10_L	0.04
VARIABLE  PO_S_15       1.0
VARIABLE  PO_S_15_W1     0.08
VARIABLE  PO_S_15_A     630
VARIABLE  PO_S_15_D     0.7   // density
VARIABLE  PO_S_15_W2     30    // window size
VARIABLE  PO_S_15_S     15    // window step
VARIABLE  PO_S_16       0.17
VARIABLE  PO_EX_1       0.09
VARIABLE  PO_EX_2       0.09
VARIABLE  PO_EX_3       0.11
VARIABLE  PO_EX_3_S     0.10
VARIABLE  PO_EX_3_J     0.02
#IFNDEF WIDE_ADJUST
VARIABLE  PO_L_1        18.0
#ELSE
VARIABLE  PO_L_1        19.8
#ENDIF
VARIABLE  PO_L_1_W      0.08
VARIABLE  PO_L_2        0.26
VARIABLE  PO_A_1        0.022
VARIABLE  PO_A_1_L      0.3
VARIABLE  PO_A_2        0.055
VARIABLE  PO_A_2_L      0.21
VARIABLE  PO_A_3        0.04
VARIABLE  PO_A_4        0.077
VARIABLE  PO_A_4_L      0.21
VARIABLE  PO_DN_1  	0.14
VARIABLE  PO_DN_1_1     0.40
VARIABLE  PO_DN_2       0.001
VARIABLE  PO_DN_2_W     20
VARIABLE  PO_DN_2_S     10
VARIABLE  PO_DN_2_E     5
VARIABLE  PO_DN_3       0.14
VARIABLE  PO_R_6_S      0.43
VARIABLE  PO_R_6_W1      0.10
VARIABLE  PO_R_6_W2      0.25
VARIABLE  PO_R_6_L      0.065

VARIABLE  SRDPO_W_1     0.04
VARIABLE  SRDPO_W_2     0.10
VARIABLE  SRDPO_W_6     0.17
VARIABLE  SRDPO_S_1     0.10
VARIABLE  SRDPO_S_2     0.14
VARIABLE  SRDPO_S_3     0.22
VARIABLE  SRDPO_S_4     0.03
VARIABLE  SRDPO_S_9     0.18
VARIABLE  SRDPO_S_16    0.17
VARIABLE  SRDPO_S_17    0.05
VARIABLE  SRDPO_S_18    0.38
VARIABLE  SRDPO_S_19    0.04
VARIABLE  SRDPO_S_20    0.08
VARIABLE  SRDPO_EN_1    0.01
VARIABLE  SRDPO_EN_2    0.02
VARIABLE  SRDPO_EX_1    0.09
VARIABLE  SRDPO_EX_2    0.03
VARIABLE  SRDPO_L_2     0.26
VARIABLE  SRDPO_A_1     0.022
VARIABLE  SRDPO_A_1_L   0.3
VARIABLE  SRDPO_A_2     0.055
VARIABLE  SRDPO_A_2_L   0.21
VARIABLE  SRDPO_A_3     0.04
VARIABLE  SRDPO_A_4     0.077
VARIABLE  SRDPO_A_4_L   0.21

VARIABLE  VTHN_W_1   0.18
VARIABLE  VTHN_S_1   0.18
VARIABLE  VTHN_S_2   0.08
VARIABLE  VTHN_S_2_1 0.14
VARIABLE  VTHN_S_3   0.18
VARIABLE  VTHN_EN_1  0.14
VARIABLE  VTHN_EN_2  0.08
VARIABLE  VTHN_A_1   0.19
VARIABLE  VTHN_A_2   0.19
VARIABLE  VTHN_R_3   0.14
VARIABLE  VTHN_L_1   0.50
VARIABLE  VTHP_W_1   0.18
VARIABLE  VTHP_S_1   0.18
VARIABLE  VTHP_S_2   0.08
VARIABLE  VTHP_S_2_1 0.14
VARIABLE  VTHP_S_3   0.18
VARIABLE  VTHP_EN_1  0.14
VARIABLE  VTHP_EN_2  0.08
VARIABLE  VTHP_A_1   0.19
VARIABLE  VTHP_A_2   0.19
VARIABLE  VTHP_R_3   0.14
VARIABLE  VTHP_L_1   0.50
VARIABLE  VTLN_W_1   0.18
VARIABLE  VTLN_S_1   0.18
VARIABLE  VTLN_S_2   0.08
VARIABLE  VTLN_S_2_1 0.14
VARIABLE  VTLN_S_3   0.18
VARIABLE  VTLN_EN_1  0.14
VARIABLE  VTLN_EN_2  0.08
VARIABLE  VTLN_A_1   0.19
VARIABLE  VTLN_A_2   0.19
VARIABLE  VTLN_R_3   0.14
VARIABLE  VTLN_L_1   0.50
VARIABLE  VTLP_W_1   0.18
VARIABLE  VTLP_S_1   0.18
VARIABLE  VTLP_S_2   0.08
VARIABLE  VTLP_S_2_1 0.14
VARIABLE  VTLP_S_3   0.18
VARIABLE  VTLP_EN_1  0.14
VARIABLE  VTLP_EN_2  0.08
VARIABLE  VTLP_A_1   0.19
VARIABLE  VTLP_A_2   0.19
VARIABLE  VTLP_R_3   0.14
VARIABLE  VTLP_L_1   0.50


VARIABLE  ULVT_N_W_1   0.18 // user value
VARIABLE  ULVT_N_S_1   0.18
VARIABLE  ULVT_N_S_2   0.08
VARIABLE  ULVT_N_S_2_1 0.14
VARIABLE  ULVT_N_S_3   0.18
VARIABLE  ULVT_N_EN_1  0.14
VARIABLE  ULVT_N_EN_2  0.08
VARIABLE  ULVT_N_A_1   0.19
VARIABLE  ULVT_N_A_2   0.19
VARIABLE  ULVT_N_R_3   0.14
VARIABLE  ULVT_N_L_1   0.50

VARIABLE  ULVT_P_W_1   0.18 // user value
VARIABLE  ULVT_P_S_1   0.18
VARIABLE  ULVT_P_S_2   0.08
VARIABLE  ULVT_P_S_2_1 0.14
VARIABLE  ULVT_P_S_3   0.18
VARIABLE  ULVT_P_EN_1  0.14
VARIABLE  ULVT_P_EN_2  0.08
VARIABLE  ULVT_P_A_1   0.19
VARIABLE  ULVT_P_A_2   0.19
VARIABLE  ULVT_P_R_3   0.14
VARIABLE  ULVT_P_L_1   0.50
VARIABLE VTLN18_W_1    0.2 // user value
VARIABLE VTLN18_W_1_1  1.2 // user value
VARIABLE VTLN18_W_1_2  0.11 // user value
VARIABLE VTLN18_W_2    0.54 // user value
VARIABLE VTLN18_W_3    1 // user value
VARIABLE VTLN18_S_1    0.22 // user value
VARIABLE VTLN18_S_2    0.22 // user value
VARIABLE VTLN18_S_3    0.08 // user value
VARIABLE VTLN18_S_4    0.03
VARIABLE VTLN18_EN_1   0.1 // user value
VARIABLE VTLN18_EN_2   0.52 // user value
VARIABLE VTLN18_EN_3   0.19 // user value
VARIABLE VTLN18_EN_4   0
VARIABLE VTLN18_EX_1   0.09

VARIABLE  PP_W_1   0.18
VARIABLE  PP_S_1   0.18
VARIABLE  PP_S_2   0.08
VARIABLE  PP_S_4   0.02
VARIABLE  PP_S_5   0.23
VARIABLE  PP_S_6   0.23
VARIABLE  PP_S_6_J 0.13
VARIABLE  PP_S_7   0.14
VARIABLE  PP_EN_1  0.11
VARIABLE  PP_EX_1  0.08
VARIABLE  PP_EX_2  0.02
VARIABLE  PP_EX_3  0.14
VARIABLE  PP_EX_4  0.23
VARIABLE  PP_O_1   0.10
VARIABLE  PP_A_1   0.11
VARIABLE  PP_A_2   0.11
VARIABLE  PP_A_3   0.021
VARIABLE  PP_R_1   0.08
VARIABLE  PP_L_1   0.50

VARIABLE  NP_W_1   0.18
VARIABLE  NP_S_1   0.18
VARIABLE  NP_S_2   0.08
VARIABLE  NP_S_4   0.02
VARIABLE  NP_S_5   0.23
VARIABLE  NP_S_6   0.23
VARIABLE  NP_S_6_J 0.13
VARIABLE  NP_S_7   0.14
VARIABLE  NP_EN_1  0.11
VARIABLE  NP_EX_1  0.08
VARIABLE  NP_EX_2  0.02
VARIABLE  NP_EX_3  0.14
VARIABLE  NP_EX_4  0.23
VARIABLE  NP_O_1   0.10
VARIABLE  NP_A_1   0.11
VARIABLE  NP_A_2   0.11
VARIABLE  NP_A_3   0.021
VARIABLE  NP_R_1   0.08
VARIABLE  NP_L_1   0.50

VARIABLE  LDN_EX_1  0.18
VARIABLE  LDP_EX_1  0.18
VARIABLE  LDP_EX_2  0.18
VARIABLE  LDN_O_1   0.18
VARIABLE  LDP_O_2   0.18
VARIABLE  VT_S_1    0.18
VARIABLE  VT_EX_2   0.18

VARIABLE  ESDIMP_W_1  0.5
VARIABLE  ESDIMP_S_1  0.5
VARIABLE  ESDIMP_EN_1 0.4
VARIABLE  ESDIMP_A_1  1.0
VARIABLE  ESDIMP_A_2  1.0

VARIABLE  RPO_W_1    0.4
VARIABLE  RPO_S_1    0.4
VARIABLE  RPO_S_2    0.22
VARIABLE  RPO_S_3    0.22
VARIABLE  RPO_S_4    0.38
VARIABLE  RPO_S_5    0.30
VARIABLE  RPO_EX_1   0.22
VARIABLE  RPO_EX_1_1   0.30
VARIABLE  RPO_EX_1_1_W 10.0
VARIABLE  RPO_EX_1_2   0.30
VARIABLE  RPO_EX_1_2_W 0.43
VARIABLE  RPO_EX_2   0.22
VARIABLE  RPO_A_1    1.00
VARIABLE  RPO_A_2    1.00

VARIABLE  RES_W_1    0.4
VARIABLE  RES_L_1    0.4
VARIABLE  RES_R_1    1.0
VARIABLE  RES_S_1    0.16
VARIABLE  RES_S_2    0.08
VARIABLE  RES_EN_1   0.19


VARIABLE  VAR_W_1    0.20 // user value
VARIABLE  VAR_W_3    0.40
VARIABLE  VAR_W_4    0.32
VARIABLE  VAR_W_5    0.35 // user value
VARIABLE  VAR_S_1    0.13
VARIABLE  VAR_EN_1   0.16
VARIABLE  VAR_R_4    0.16
VARIABLE  VAR_R_5_X  0.19
VARIABLE  VAR_R_5_Y  0.13
VARIABLE  VAR_R_5_1_X  0.19
VARIABLE  VAR_R_5_1_Y  0.13
VARIABLE  VAR_A_1      25


VARIABLE  HVD_N25_W_1     0.47
#IFDEF HALF_NODE
VARIABLE  HVD_N25_W_2     1.115
#ELSE
VARIABLE  HVD_N25_W_2     1.0
#ENDIF
VARIABLE  HVD_N25_S_1     0.47
VARIABLE  HVD_N25_S_2     1.37
VARIABLE  HVD_N25_S_3     1.6
VARIABLE  HVD_N25_S_4     0.3
VARIABLE  HVD_N25_S_5     0.6
VARIABLE  HVD_N25_S_6     3.0
VARIABLE  HVD_N25_S_7     0.52
VARIABLE  HVD_N25_S_8     1.26
VARIABLE  HVD_N25_S_9     0.22
VARIABLE  HVD_N25_S_10    2.0
#IFDEF HALF_NODE
VARIABLE  HVD_N25_S_11    0.6
#ELSE
VARIABLE  HVD_N25_S_11    0.54
#ENDIF
VARIABLE  HVD_N25_S_12    0.6
VARIABLE  HVD_N25_S_13    0.16
VARIABLE  HVD_N25_EN_1    2.0
VARIABLE  HVD_N25_EX_1    0.24
#IFDEF HALF_NODE
VARIABLE  HVD_N25_O_1     0.33
VARIABLE  HVD_N25_L_1     0.88
#ELSE
VARIABLE  HVD_N25_O_1     0.3
VARIABLE  HVD_N25_L_1     0.8
#ENDIF
VARIABLE  HVD_N25_A_1     0.64
VARIABLE  HVD_N25_A_2     0.64

VARIABLE  HVD_P25_W_1     0.47
#IFDEF HALF_NODE
VARIABLE  HVD_P25_W_2     1.115
#ELSE
VARIABLE  HVD_P25_W_2     1.0
#ENDIF
VARIABLE  HVD_P25_S_1     0.47
VARIABLE  HVD_P25_S_2     1.2
VARIABLE  HVD_P25_S_4     0.24
VARIABLE  HVD_P25_S_5     0.48
VARIABLE  HVD_P25_S_6     2.0
VARIABLE  HVD_P25_S_7     0.52
VARIABLE  HVD_P25_S_8     0.05
VARIABLE  HVD_P25_S_9     1.26
VARIABLE  HVD_P25_S_10    0.22
#IFDEF HALF_NODE
VARIABLE  HVD_P25_S_11    0.6
#ELSE
VARIABLE  HVD_P25_S_11    0.54
#ENDIF
VARIABLE  HVD_P25_S_12    0.6
VARIABLE  HVD_P25_S_13    0.16
VARIABLE  HVD_P25_EX_1    0.24
VARIABLE  HVD_P25_EN_1    0.6
VARIABLE  HVD_P25_EN_2    0.6
VARIABLE  HVD_P25_EN_3    2.0
VARIABLE  HVD_P25_EN_4    2.0
#IFDEF HALF_NODE
VARIABLE  HVD_P25_O_1     0.28
VARIABLE  HVD_P25_L_1     0.66
#ELSE
VARIABLE  HVD_P25_O_1     0.25
VARIABLE  HVD_P25_L_1     0.6
#ENDIF
VARIABLE  HVD_P25_A_1     0.64
VARIABLE  HVD_P25_A_2     0.64

VARIABLE  HVD_N18_W_1     0.47
VARIABLE  HVD_N18_W_2     0.67
VARIABLE  HVD_N18_S_1     0.47
VARIABLE  HVD_N18_S_2     1.37
VARIABLE  HVD_N18_S_3     1.6
VARIABLE  HVD_N18_S_4     0.3
VARIABLE  HVD_N18_S_5     0.6
VARIABLE  HVD_N18_S_6     3.0
VARIABLE  HVD_N18_S_7     0.52
VARIABLE  HVD_N18_S_8     1.26
VARIABLE  HVD_N18_S_9     0.22
VARIABLE  HVD_N18_S_10    2.0
VARIABLE  HVD_N18_S_11    0.6
VARIABLE  HVD_N18_S_12    0.6
VARIABLE  HVD_N18_EN_1    2.0
VARIABLE  HVD_N18_EX_1    0.24
VARIABLE  HVD_N18_O_1     0.33
VARIABLE  HVD_N18_L_1     0.88
VARIABLE  HVD_N18_A_1     0.64
VARIABLE  HVD_N18_A_2     0.64

VARIABLE  HVD_P18_W_1     0.47
VARIABLE  HVD_P18_W_2     0.67
VARIABLE  HVD_P18_S_1     0.47
VARIABLE  HVD_P18_S_2     1.2
VARIABLE  HVD_P18_S_4     0.24
VARIABLE  HVD_P18_S_5     0.48
VARIABLE  HVD_P18_S_6     2.0
VARIABLE  HVD_P18_S_7     0.52
VARIABLE  HVD_P18_S_8     0.05
VARIABLE  HVD_P18_S_9     1.82
VARIABLE  HVD_P18_S_10    0.22
VARIABLE  HVD_P18_S_11    0.88
VARIABLE  HVD_P18_S_12    0.6
VARIABLE  HVD_P18_EX_1    0.24
VARIABLE  HVD_P18_EN_1    0.6
VARIABLE  HVD_P18_EN_2    0.6
VARIABLE  HVD_P18_EN_3    2.0
VARIABLE  HVD_P18_EN_4    2.0
VARIABLE  HVD_P18_O_1     0.28
VARIABLE  HVD_P18_L_1     0.66
VARIABLE  HVD_P18_A_1     0.64
VARIABLE  HVD_P18_A_2     0.64
VARIABLE  HVD_GR_R_5      30
VARIABLE  DEHVD_N_L_1     0.54
VARIABLE  DEHVD_N_W_1     0.47
VARIABLE  DEHVD_N_W_2     1.0
VARIABLE  DEHVD_N_W_3     0.12
VARIABLE  DEHVD_N_S_1     0.47
VARIABLE  DEHVD_N_S_2     1.37
VARIABLE  DEHVD_N_S_3     1.6
VARIABLE  DEHVD_N_S_4     0.3
VARIABLE  DEHVD_N_S_5     0.6
VARIABLE  DEHVD_N_S_6     3.0
VARIABLE  DEHVD_N_S_7     0.12
VARIABLE  DEHVD_N_S_8     0.4
VARIABLE  DEHVD_N_S_9     0.6 // user value
VARIABLE  DEHVD_N_S_10    0.44
VARIABLE  DEHVD_N_S_12    1.26
VARIABLE  DEHVD_N_S_13    0.22
VARIABLE  DEHVD_N_S_14    0.6
VARIABLE  DEHVD_N_S_15    2.0
VARIABLE  DEHVD_N_EN_1    2.0
VARIABLE  DEHVD_N_EX_1    0.24
VARIABLE  DEHVD_N_EX_2    0.525
VARIABLE  DEHVD_N_EX_3    0.4
VARIABLE  DEHVD_N_O_1     0.05
VARIABLE  DEHVD_N_A_1     0.64
VARIABLE  DEHVD_N_A_2     0.64

VARIABLE  DEHVD_GR_R_7    2.0
VARIABLE  DEHVD_GR_R_8    4.0
VARIABLE  DEHVD_GR_R_10   2.0
VARIABLE  DEHVD_GR_R_11   2.0


VARIABLE  CO_W_1     0.06
VARIABLE  CO_S_1     0.08
VARIABLE  CO_S_2     0.10
VARIABLE  CO_S_2_D   0.11
VARIABLE  CO_S_2_1   0.11
VARIABLE  CO_S_3     0.04
VARIABLE  CO_S_3_S   0.035
VARIABLE  CO_S_4     0.05
VARIABLE  CO_S_5     0.08
#IFDEF HALF_NODE
VARIABLE  CO_S_5_1   0.6 // user value
#ELSE
VARIABLE  CO_S_5_1   0.54 // user value
#ENDIF

VARIABLE  CO_S_6     0.04
VARIABLE  CO_EN_1    0.01
VARIABLE  CO_EN_1_1  0.03
VARIABLE  CO_EN_1_2  0.02
VARIABLE  CO_EN_1_3  0.02
VARIABLE  CO_EN_2    0.01
VARIABLE  CO_EN_3    0.02
VARIABLE  CO_EN_5A    0.005
VARIABLE  CO_EN_5B  0.015
VARIABLE  CO_EN_6    0.03

VARIABLE  M1_W_1     0.07
VARIABLE  M1_W_2     0.17
VARIABLE  M1_S_1     0.07
#IFNDEF WIDE_ADJUST
VARIABLE  M1_W_3     4.50
VARIABLE  M1_S_2     0.08
VARIABLE  M1_S_2_W   0.17
VARIABLE  M1_S_2_L   0.27
VARIABLE  M1_S_2_1   0.12
VARIABLE  M1_S_2_1_W 0.24
VARIABLE  M1_S_2_1_L 0.27
VARIABLE  M1_S_2_2   0.14
VARIABLE  M1_S_2_2_W 0.31
VARIABLE  M1_S_2_2_L 0.40
VARIABLE  M1_S_2_3   0.21
VARIABLE  M1_S_2_3_W 0.62
VARIABLE  M1_S_2_3_L 0.62
VARIABLE  M1_S_3     0.50
VARIABLE  M1_S_3_W   1.50
VARIABLE  M1_S_3_L   1.50
#ELSE
VARIABLE  M1_W_3     4.95
VARIABLE  M1_S_2     0.08
VARIABLE  M1_S_2_W   0.19
VARIABLE  M1_S_2_L   0.30
VARIABLE  M1_S_2_1   0.12
VARIABLE  M1_S_2_1_W 0.265
VARIABLE  M1_S_2_1_L 0.30
VARIABLE  M1_S_2_2   0.14
VARIABLE  M1_S_2_2_W 0.345
VARIABLE  M1_S_2_2_L 0.44
VARIABLE  M1_S_2_3   0.21
VARIABLE  M1_S_2_3_W 0.685
VARIABLE  M1_S_2_3_L 0.685
VARIABLE  M1_S_2_4   0.075
VARIABLE  M1_S_2_4_W 0.17
VARIABLE  M1_S_2_4_L 0.30
VARIABLE  M1_S_2_5   0.085
VARIABLE  M1_S_2_5_W 0.24
VARIABLE  M1_S_2_5_L 0.30
VARIABLE  M1_S_2_6   0.13
VARIABLE  M1_S_2_6_W 0.31
VARIABLE  M1_S_2_6_L 0.44
VARIABLE  M1_S_2_7   0.15
VARIABLE  M1_S_2_7_W 0.62
VARIABLE  M1_S_2_7_L 0.685
VARIABLE  M1_S_3     0.50
VARIABLE  M1_S_3_W   1.65
VARIABLE  M1_S_3_L   1.65
#ENDIF
VARIABLE  M1_S_5     0.08
VARIABLE  M1_S_5_W   0.09
VARIABLE  M1_S_5_Q   0.07
VARIABLE  M1_S_5_T   0.025
VARIABLE  M1_S_6     0.17
VARIABLE  M1_S_8     0.1
VARIABLE  M1_S_8_1   0.08
VARIABLE  M1_S_1_1   0.09
VARIABLE  M1_S_8_2   0.18
VARIABLE  M1_S_9     0.15
VARIABLE  M1_S_9_A   0.06
VARIABLE  M1_S_9_B   0.12
VARIABLE  M1_S_9_C   0.13
VARIABLE  M1_S_9_D   0.01
VARIABLE  M1_EN_1    0
VARIABLE  M1_EN_2    0.03
VARIABLE  M1_EN_3    0.02
VARIABLE  M1_EN_3_1  0.005
VARIABLE  M1_EN_3_2  0.025
VARIABLE  M1_EN_4    0.03
VARIABLE  M1_EN_4_W  0.7
VARIABLE  M1_EN_5    0.015
VARIABLE  M1_EN_5_W  0.11
VARIABLE  M1_EN_5_L  0.27
VARIABLE  M1_EN_5_S  0.08

VARIABLE  M1_A_1     0.0215
VARIABLE  M1_A_2     0.055
VARIABLE  M1_A_2_W   0.07
VARIABLE  M1_A_2_L1   0.17
VARIABLE  M1_A_2_L2   0.17
VARIABLE  M1_A_3     0.2
VARIABLE  M1_DN_1    0.1
VARIABLE  M1_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE
VARIABLE  M1_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M1_DN_1_E  M1_DN_1_W/4
VARIABLE  M1_DN_1_1  0.85
VARIABLE  M1_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE
VARIABLE  M1_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M1_DN_1_1_E  M1_DN_1_1_W/4
VARIABLE  M1_DN_4_W  200
VARIABLE  M1_DN_4    0.5
VARIABLE  M1_DN_6_W_A 80
VARIABLE  M1_DN_6_S_A 40
VARIABLE  M1_DN_6_E_A 40
VARIABLE  M1_DN_6     0.01
VARIABLE  M1_DN_6_W_BC 10
VARIABLE  M1_DN_6_S_BC 5
VARIABLE  M1_DN_6_E_BC 5
VARIABLE  M1_DN_6_A_B 6400
VARIABLE  M1_DN_6_A_C 18000
VARIABLE  M1_DN_6_U   30
VARIABLE  M1_DN_6_W_A_R 40
VARIABLE  M1_DN_6_S_A_R 40
VARIABLE  M1_DN_6_E_A_R 20 // user value
VARIABLE  M1_DN_6_R     0.01
VARIABLE  M1_DN_6_W_BC_R 10
VARIABLE  M1_DN_6_S_BC_R 5
VARIABLE  M1_DN_6_E_BC_R 5 // user value
VARIABLE  M1_DN_6_A_B_R 1600 // user value
VARIABLE  M1_DN_6_A_C_R 4500 // user value
VARIABLE  M1_DN_6_U_R   30
VARIABLE  M1_DN_6_CS_A_R	40 
VARIABLE  M1_DN_6_CS_B_R	10 
VARIABLE  M1_DN_6_CS_C_R	10 


VARIABLE  VIA1_W_1     0.07 
VARIABLE  VIA1_S_1     0.07 
VARIABLE  VIA1_S_1_1   0.2
VARIABLE  VIA1_S_2     0.09 
VARIABLE  VIA1_S_2_D   0.098 
VARIABLE  VIA1_S_3     0.095  
VARIABLE  VIA1_S_3_1   0.11 
VARIABLE  VIA1_EN_1    0
VARIABLE  VIA1_EN_2    0.03 
VARIABLE  VIA1_EN_3_1    0.015
VARIABLE  VIA1_EN_3_1_W  0.11
VARIABLE  VIA1_EN_3_1_L  0.27
VARIABLE  VIA1_EN_3_1_S  0.08
VARIABLE  VIA1_EN_4    0.01
VARIABLE  VIA1_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA1_R_2_S1  0.14 
VARIABLE  VIA1_R_2_S2  0.63 
VARIABLE  VIA1_R_2_W   0.21 
VARIABLE  VIA1_R_3_S1  0.14 
VARIABLE  VIA1_R_3_S2  0.83 
VARIABLE  VIA1_R_3_W   0.55 
VARIABLE  VIA1_R_4_W   0.21
VARIABLE  VIA1_R_4_D   1.14
VARIABLE  VIA1_R_5_W   1.4
VARIABLE  VIA1_R_5_D   2.8
VARIABLE  VIA1_R_6_W   2.1
VARIABLE  VIA1_R_6_L   7.0
VARIABLE  VIA1_R_6_D   7.1
VARIABLE  VIA1_R_11_L1 5.0
VARIABLE  VIA1_R_11_A  5.0
VARIABLE  VIA1_R_11_L2  1.0
VARIABLE  VIA1_R_11_W  0.21
#ELSE
VARIABLE  VIA1_R_2_S1  0.16
VARIABLE  VIA1_R_2_S2  0.70
VARIABLE  VIA1_R_2_W   0.235
VARIABLE  VIA1_R_3_S1  0.16
VARIABLE  VIA1_R_3_S2  0.92
VARIABLE  VIA1_R_3_W   0.605
VARIABLE  VIA1_R_4_W   0.235
VARIABLE  VIA1_R_4_D   1.14
VARIABLE  VIA1_R_5_W   1.54
VARIABLE  VIA1_R_5_D   2.80
VARIABLE  VIA1_R_6_W   2.31
VARIABLE  VIA1_R_6_L   7.70
VARIABLE  VIA1_R_6_D   7.10
VARIABLE  VIA1_R_11_L2  1.00
VARIABLE  VIA1_R_11_W  0.235
VARIABLE  VIA1_R_11_A  5.00
VARIABLE  VIA1_R_11_L1 5.00
#ENDIF

VARIABLE  M2_W_1      0.07 
VARIABLE  M2_W_2      0.17
VARIABLE  M2_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M2_W_3      4.50
VARIABLE  M2_S_2      0.10 
VARIABLE  M2_S_2_W    0.17 
VARIABLE  M2_S_2_L    0.27
VARIABLE  M2_S_2_1    0.12 
VARIABLE  M2_S_2_1_W  0.24 
VARIABLE  M2_S_2_1_L  0.27
VARIABLE  M2_S_2_2    0.15 
VARIABLE  M2_S_2_2_W  0.31 
VARIABLE  M2_S_2_2_L  0.40
VARIABLE  M2_S_2_3    0.21 
VARIABLE  M2_S_2_3_W  0.62 
VARIABLE  M2_S_2_3_L  0.62
VARIABLE  M2_S_3      0.50 
VARIABLE  M2_S_3_W    1.50 
VARIABLE  M2_S_3_L    1.50 
#ELSE
VARIABLE  M2_W_3      4.95 
VARIABLE  M2_S_2      0.10
VARIABLE  M2_S_2_W    0.19
VARIABLE  M2_S_2_L    0.30
VARIABLE  M2_S_2_1    0.12
VARIABLE  M2_S_2_1_W  0.265
VARIABLE  M2_S_2_1_L  0.30
VARIABLE  M2_S_2_2    0.15
VARIABLE  M2_S_2_2_W  0.345
VARIABLE  M2_S_2_2_L  0.44
VARIABLE  M2_S_2_3    0.21
VARIABLE  M2_S_2_3_W  0.685
VARIABLE  M2_S_2_3_L  0.685
VARIABLE  M2_S_2_4    0.075
VARIABLE  M2_S_2_4_W  0.17
VARIABLE  M2_S_2_4_L  0.30
VARIABLE  M2_S_2_5    0.11
VARIABLE  M2_S_2_5_W  0.24
VARIABLE  M2_S_2_5_L  0.30
VARIABLE  M2_S_2_6    0.13
VARIABLE  M2_S_2_6_W  0.31
VARIABLE  M2_S_2_6_L  0.44
VARIABLE  M2_S_2_7    0.165
VARIABLE  M2_S_2_7_W  0.62
VARIABLE  M2_S_2_7_L  0.685
VARIABLE  M2_S_3      0.50
VARIABLE  M2_S_3_W    1.65
VARIABLE  M2_S_3_L    1.65
#ENDIF
VARIABLE  M2_S_5      0.10 
VARIABLE  M2_S_5_W    0.10 
VARIABLE  M2_S_5_T    0.035 
VARIABLE  M2_S_5_L    0.07	
VARIABLE  M2_S_5_1    0.12
//VARIABLE  M2_S_5_1_L  0.07
VARIABLE  M2_S_5_1_W  0.10 
VARIABLE  M2_S_5_1_T  0.035
VARIABLE  M2_S_5_1_E  0.05 
VARIABLE  M2_S_5_1_E2 0.035
VARIABLE  M2_S_5_1_E3 0.040
VARIABLE  M2_S_5_1_E4 0.045
VARIABLE  M2_S_5_1_S2 0.115
VARIABLE  M2_S_5_1_S3 0.110
VARIABLE  M2_S_5_1_S4 0.105
VARIABLE  M2_S_6      0.17
VARIABLE  M2_S_8      0.1 
VARIABLE  M2_S_8_1    0.08
VARIABLE  M2_S_1_1    0.09

VARIABLE  M2_S_8_2    0.18
VARIABLE  M2_S_9      0.15
VARIABLE  M2_S_9_A   0.06
VARIABLE  M2_S_9_B   0.12
VARIABLE  M2_S_9_C   0.13
VARIABLE  M2_S_9_D   0.01
VARIABLE  M2_EN_1     0
VARIABLE  M2_EN_2     0.03 
VARIABLE  M2_EN_3     0.01
VARIABLE  M2_EN_3_1   0.02 
VARIABLE  M2_A_1      0.027 
VARIABLE  M2_A_2      0.06 
VARIABLE  M2_A_2_W    0.07 
VARIABLE  M2_A_2_L1    0.17
VARIABLE  M2_A_2_L2    0.17
VARIABLE  M2_A_3      0.20 
VARIABLE  M2_DN_1    0.1 
VARIABLE  M2_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M2_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M2_DN_1_E  M2_DN_1_W/4
VARIABLE  M2_DN_1_1  0.85
VARIABLE  M2_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M2_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M2_DN_1_1_E  M2_DN_1_1_W/4
VARIABLE  M2_DN_4     0.5
VARIABLE  M2_DN_4_W   200 
VARIABLE  M2_DN_6_W_A 80  
VARIABLE  M2_DN_6_S_A 40  
VARIABLE  M2_DN_6_E_A 40  
VARIABLE  M2_DN_6     0.01 
VARIABLE  M2_DN_6_W_BC 10
VARIABLE  M2_DN_6_S_BC 5  
VARIABLE  M2_DN_6_E_BC 5
VARIABLE  M2_DN_6_A_B 6400
VARIABLE  M2_DN_6_A_C 18000
VARIABLE  M2_DN_6_U   30
VARIABLE  M2_DN_6_W_A_R 40 // user value 
VARIABLE  M2_DN_6_S_A_R 40 // user value
VARIABLE  M2_DN_6_E_A_R 20 // user value 
VARIABLE  M2_DN_6_R     0.01 // user value 
VARIABLE  M2_DN_6_W_BC_R 10 // user value
VARIABLE  M2_DN_6_S_BC_R 5 // user value 
VARIABLE  M2_DN_6_E_BC_R 5 // user value
VARIABLE  M2_DN_6_A_B_R 1600 // user value
VARIABLE  M2_DN_6_A_C_R 4500 // user value
VARIABLE  M2_DN_6_U_R   30 // user value
VARIABLE  M2_DN_6_CS_A_R	40
VARIABLE  M2_DN_6_CS_B_R	10 
VARIABLE  M2_DN_6_CS_C_R	10 

VARIABLE  VIA2_W_1     0.07 
VARIABLE  VIA2_S_1     0.07 
VARIABLE  VIA2_S_1_1   0.2
VARIABLE  VIA2_S_2     0.09 
VARIABLE  VIA2_S_2_D   0.098 
VARIABLE  VIA2_S_3     0.095  
VARIABLE  VIA2_S_3_1   0.11 
VARIABLE  VIA2_EN_1    0
VARIABLE  VIA2_EN_2    0.03 
VARIABLE  VIA2_EN_4    0.01
VARIABLE  VIA2_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA2_R_2_S1  0.14 
VARIABLE  VIA2_R_2_S2  0.63 
VARIABLE  VIA2_R_2_W   0.21 
VARIABLE  VIA2_R_3_S1  0.14 
VARIABLE  VIA2_R_3_S2  0.83 
VARIABLE  VIA2_R_3_W   0.55 
VARIABLE  VIA2_R_4_W   0.21
VARIABLE  VIA2_R_4_D   1.14
VARIABLE  VIA2_R_5_W   1.4
VARIABLE  VIA2_R_5_D   2.8
VARIABLE  VIA2_R_6_W   2.1
VARIABLE  VIA2_R_6_L   7.0
VARIABLE  VIA2_R_6_D   7.1
VARIABLE  VIA2_R_11_L1 5.0
VARIABLE  VIA2_R_11_A  5.0
VARIABLE  VIA2_R_11_L2  1.0
VARIABLE  VIA2_R_11_W  0.21
#ELSE
VARIABLE  VIA2_R_2_S1  0.16
VARIABLE  VIA2_R_2_S2  0.70
VARIABLE  VIA2_R_2_W   0.235
VARIABLE  VIA2_R_3_S1  0.16
VARIABLE  VIA2_R_3_S2  0.92
VARIABLE  VIA2_R_3_W   0.605
VARIABLE  VIA2_R_4_W   0.235
VARIABLE  VIA2_R_4_D   1.14
VARIABLE  VIA2_R_5_W   1.54
VARIABLE  VIA2_R_5_D   2.80
VARIABLE  VIA2_R_6_W   2.31
VARIABLE  VIA2_R_6_L   7.70
VARIABLE  VIA2_R_6_D   7.10
VARIABLE  VIA2_R_11_L2  1.00
VARIABLE  VIA2_R_11_W  0.235
VARIABLE  VIA2_R_11_A  5.00
VARIABLE  VIA2_R_11_L1 5.00
#ENDIF

VARIABLE  M3_W_1      0.07 
VARIABLE  M3_W_2      0.17
VARIABLE  M3_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M3_W_3      4.50
VARIABLE  M3_S_2      0.10 
VARIABLE  M3_S_2_W    0.17 
VARIABLE  M3_S_2_L    0.27
VARIABLE  M3_S_2_1    0.12 
VARIABLE  M3_S_2_1_W  0.24 
VARIABLE  M3_S_2_1_L  0.27
VARIABLE  M3_S_2_2    0.15 
VARIABLE  M3_S_2_2_W  0.31 
VARIABLE  M3_S_2_2_L  0.40
VARIABLE  M3_S_2_3    0.21 
VARIABLE  M3_S_2_3_W  0.62 
VARIABLE  M3_S_2_3_L  0.62
VARIABLE  M3_S_3      0.50 
VARIABLE  M3_S_3_W    1.50 
VARIABLE  M3_S_3_L    1.50 
#ELSE
VARIABLE  M3_W_3      4.95 
VARIABLE  M3_S_2      0.10
VARIABLE  M3_S_2_W    0.19
VARIABLE  M3_S_2_L    0.30
VARIABLE  M3_S_2_1    0.12
VARIABLE  M3_S_2_1_W  0.265
VARIABLE  M3_S_2_1_L  0.30
VARIABLE  M3_S_2_2    0.15
VARIABLE  M3_S_2_2_W  0.345
VARIABLE  M3_S_2_2_L  0.44
VARIABLE  M3_S_2_3    0.21
VARIABLE  M3_S_2_3_W  0.685
VARIABLE  M3_S_2_3_L  0.685
VARIABLE  M3_S_2_4    0.075
VARIABLE  M3_S_2_4_W  0.17
VARIABLE  M3_S_2_4_L  0.30
VARIABLE  M3_S_2_5    0.11
VARIABLE  M3_S_2_5_W  0.24
VARIABLE  M3_S_2_5_L  0.30
VARIABLE  M3_S_2_6    0.13
VARIABLE  M3_S_2_6_W  0.31
VARIABLE  M3_S_2_6_L  0.44
VARIABLE  M3_S_2_7    0.165
VARIABLE  M3_S_2_7_W  0.62
VARIABLE  M3_S_2_7_L  0.685
VARIABLE  M3_S_3      0.50
VARIABLE  M3_S_3_W    1.65
VARIABLE  M3_S_3_L    1.65
#ENDIF
VARIABLE  M3_S_5      0.10 
VARIABLE  M3_S_5_W    0.10 
VARIABLE  M3_S_5_T    0.035 
VARIABLE  M3_S_5_L    0.07	
VARIABLE  M3_S_5_1    0.12
//VARIABLE  M3_S_5_1_L  0.07
VARIABLE  M3_S_5_1_W  0.10 
VARIABLE  M3_S_5_1_T  0.035
VARIABLE  M3_S_5_1_E  0.05 
VARIABLE  M3_S_5_1_E2 0.035
VARIABLE  M3_S_5_1_E3 0.040
VARIABLE  M3_S_5_1_E4 0.045
VARIABLE  M3_S_5_1_S2 0.115
VARIABLE  M3_S_5_1_S3 0.110
VARIABLE  M3_S_5_1_S4 0.105
VARIABLE  M3_S_6      0.17
VARIABLE  M3_S_8      0.1 
VARIABLE  M3_S_8_1    0.08
VARIABLE  M3_S_1_1    0.09

VARIABLE  M3_S_8_2    0.18
VARIABLE  M3_S_9      0.15
VARIABLE  M3_S_9_A   0.06
VARIABLE  M3_S_9_B   0.12
VARIABLE  M3_S_9_C   0.13
VARIABLE  M3_S_9_D   0.01
VARIABLE  M3_EN_1     0
VARIABLE  M3_EN_2     0.03 
VARIABLE  M3_EN_3     0.01
VARIABLE  M3_EN_3_1   0.02 
VARIABLE  M3_A_1      0.027 
VARIABLE  M3_A_2      0.06 
VARIABLE  M3_A_2_W    0.07 
VARIABLE  M3_A_2_L1    0.17
VARIABLE  M3_A_2_L2    0.17
VARIABLE  M3_A_3      0.20 
VARIABLE  M3_DN_1    0.1 
VARIABLE  M3_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M3_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M3_DN_1_E  M3_DN_1_W/4
VARIABLE  M3_DN_1_1  0.85
VARIABLE  M3_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M3_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M3_DN_1_1_E  M3_DN_1_1_W/4
VARIABLE  M3_DN_4     0.5
VARIABLE  M3_DN_4_W   200 
VARIABLE  M3_DN_6_W_A 80  
VARIABLE  M3_DN_6_S_A 40  
VARIABLE  M3_DN_6_E_A 40  
VARIABLE  M3_DN_6     0.01 
VARIABLE  M3_DN_6_W_BC 10
VARIABLE  M3_DN_6_S_BC 5  
VARIABLE  M3_DN_6_E_BC 5
VARIABLE  M3_DN_6_A_B 6400
VARIABLE  M3_DN_6_A_C 18000
VARIABLE  M3_DN_6_U   30
VARIABLE  M3_DN_6_W_A_R 40 // user value 
VARIABLE  M3_DN_6_S_A_R 40 // user value
VARIABLE  M3_DN_6_E_A_R 20 // user value 
VARIABLE  M3_DN_6_R     0.01 // user value 
VARIABLE  M3_DN_6_W_BC_R 10 // user value
VARIABLE  M3_DN_6_S_BC_R 5 // user value 
VARIABLE  M3_DN_6_E_BC_R 5 // user value
VARIABLE  M3_DN_6_A_B_R 1600 // user value
VARIABLE  M3_DN_6_A_C_R 4500 // user value
VARIABLE  M3_DN_6_U_R   30 // user value
VARIABLE  M3_DN_6_CS_A_R	40
VARIABLE  M3_DN_6_CS_B_R	10 
VARIABLE  M3_DN_6_CS_C_R	10 
VARIABLE  M1_DN_5_W   62.5
VARIABLE  M1_DN_5_S   31.25
VARIABLE  M1_DN_5     0.85
VARIABLE  M1_DN_7_W   30  
VARIABLE  M1_DN_7_S   15 
VARIABLE  M1_DN_7_E   15 
VARIABLE  M1_DN_7     0.05 
VARIABLE  M1_DN_7_W_R 15 // user value 
VARIABLE  M1_DN_7_S_R 15 // user value 
VARIABLE  M1_DN_7_E_R 7.5 // user value
VARIABLE  M1_DN_7_R   0.05 // user value
VARIABLE  M1_DN_7_CS_R	15 

VARIABLE  VIA3_W_1     0.07 
VARIABLE  VIA3_S_1     0.07 
VARIABLE  VIA3_S_1_1   0.2
VARIABLE  VIA3_S_2     0.09 
VARIABLE  VIA3_S_2_D   0.098 
VARIABLE  VIA3_S_3     0.095  
VARIABLE  VIA3_S_3_1   0.11 
VARIABLE  VIA3_EN_1    0
VARIABLE  VIA3_EN_2    0.03 
VARIABLE  VIA3_EN_4    0.01
VARIABLE  VIA3_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA3_R_2_S1  0.14 
VARIABLE  VIA3_R_2_S2  0.63 
VARIABLE  VIA3_R_2_W   0.21 
VARIABLE  VIA3_R_3_S1  0.14 
VARIABLE  VIA3_R_3_S2  0.83 
VARIABLE  VIA3_R_3_W   0.55 
VARIABLE  VIA3_R_4_W   0.21
VARIABLE  VIA3_R_4_D   1.14
VARIABLE  VIA3_R_5_W   1.4
VARIABLE  VIA3_R_5_D   2.8
VARIABLE  VIA3_R_6_W   2.1
VARIABLE  VIA3_R_6_L   7.0
VARIABLE  VIA3_R_6_D   7.1
VARIABLE  VIA3_R_11_L1 5.0
VARIABLE  VIA3_R_11_A  5.0
VARIABLE  VIA3_R_11_L2  1.0
VARIABLE  VIA3_R_11_W  0.21
#ELSE
VARIABLE  VIA3_R_2_S1  0.16
VARIABLE  VIA3_R_2_S2  0.70
VARIABLE  VIA3_R_2_W   0.235
VARIABLE  VIA3_R_3_S1  0.16
VARIABLE  VIA3_R_3_S2  0.92
VARIABLE  VIA3_R_3_W   0.605
VARIABLE  VIA3_R_4_W   0.235
VARIABLE  VIA3_R_4_D   1.14
VARIABLE  VIA3_R_5_W   1.54
VARIABLE  VIA3_R_5_D   2.80
VARIABLE  VIA3_R_6_W   2.31
VARIABLE  VIA3_R_6_L   7.70
VARIABLE  VIA3_R_6_D   7.10
VARIABLE  VIA3_R_11_L2  1.00
VARIABLE  VIA3_R_11_W  0.235
VARIABLE  VIA3_R_11_A  5.00
VARIABLE  VIA3_R_11_L1 5.00
#ENDIF

VARIABLE  M4_W_1      0.07 
VARIABLE  M4_W_2      0.17
VARIABLE  M4_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M4_W_3      4.50
VARIABLE  M4_S_2      0.10 
VARIABLE  M4_S_2_W    0.17 
VARIABLE  M4_S_2_L    0.27
VARIABLE  M4_S_2_1    0.12 
VARIABLE  M4_S_2_1_W  0.24 
VARIABLE  M4_S_2_1_L  0.27
VARIABLE  M4_S_2_2    0.15 
VARIABLE  M4_S_2_2_W  0.31 
VARIABLE  M4_S_2_2_L  0.40
VARIABLE  M4_S_2_3    0.21 
VARIABLE  M4_S_2_3_W  0.62 
VARIABLE  M4_S_2_3_L  0.62
VARIABLE  M4_S_3      0.50 
VARIABLE  M4_S_3_W    1.50 
VARIABLE  M4_S_3_L    1.50 
#ELSE
VARIABLE  M4_W_3      4.95 
VARIABLE  M4_S_2      0.10
VARIABLE  M4_S_2_W    0.19
VARIABLE  M4_S_2_L    0.30
VARIABLE  M4_S_2_1    0.12
VARIABLE  M4_S_2_1_W  0.265
VARIABLE  M4_S_2_1_L  0.30
VARIABLE  M4_S_2_2    0.15
VARIABLE  M4_S_2_2_W  0.345
VARIABLE  M4_S_2_2_L  0.44
VARIABLE  M4_S_2_3    0.21
VARIABLE  M4_S_2_3_W  0.685
VARIABLE  M4_S_2_3_L  0.685
VARIABLE  M4_S_2_4    0.075
VARIABLE  M4_S_2_4_W  0.17
VARIABLE  M4_S_2_4_L  0.30
VARIABLE  M4_S_2_5    0.11
VARIABLE  M4_S_2_5_W  0.24
VARIABLE  M4_S_2_5_L  0.30
VARIABLE  M4_S_2_6    0.13
VARIABLE  M4_S_2_6_W  0.31
VARIABLE  M4_S_2_6_L  0.44
VARIABLE  M4_S_2_7    0.165
VARIABLE  M4_S_2_7_W  0.62
VARIABLE  M4_S_2_7_L  0.685
VARIABLE  M4_S_3      0.50
VARIABLE  M4_S_3_W    1.65
VARIABLE  M4_S_3_L    1.65
#ENDIF
VARIABLE  M4_S_5      0.10 
VARIABLE  M4_S_5_W    0.10 
VARIABLE  M4_S_5_T    0.035 
VARIABLE  M4_S_5_L    0.07	
VARIABLE  M4_S_5_1    0.12
//VARIABLE  M4_S_5_1_L  0.07
VARIABLE  M4_S_5_1_W  0.10 
VARIABLE  M4_S_5_1_T  0.035
VARIABLE  M4_S_5_1_E  0.05 
VARIABLE  M4_S_5_1_E2 0.035
VARIABLE  M4_S_5_1_E3 0.040
VARIABLE  M4_S_5_1_E4 0.045
VARIABLE  M4_S_5_1_S2 0.115
VARIABLE  M4_S_5_1_S3 0.110
VARIABLE  M4_S_5_1_S4 0.105
VARIABLE  M4_S_6      0.17
VARIABLE  M4_S_8      0.1 
VARIABLE  M4_S_8_1    0.08
VARIABLE  M4_S_1_1    0.09

VARIABLE  M4_S_8_2    0.18
VARIABLE  M4_S_9      0.15
VARIABLE  M4_S_9_A   0.06
VARIABLE  M4_S_9_B   0.12
VARIABLE  M4_S_9_C   0.13
VARIABLE  M4_S_9_D   0.01
VARIABLE  M4_EN_1     0
VARIABLE  M4_EN_2     0.03 
VARIABLE  M4_EN_3     0.01
VARIABLE  M4_EN_3_1   0.02 
VARIABLE  M4_A_1      0.027 
VARIABLE  M4_A_2      0.06 
VARIABLE  M4_A_2_W    0.07 
VARIABLE  M4_A_2_L1    0.17
VARIABLE  M4_A_2_L2    0.17
VARIABLE  M4_A_3      0.20 
VARIABLE  M4_DN_1    0.1 
VARIABLE  M4_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M4_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M4_DN_1_E  M4_DN_1_W/4
VARIABLE  M4_DN_1_1  0.85
VARIABLE  M4_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M4_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M4_DN_1_1_E  M4_DN_1_1_W/4
VARIABLE  M4_DN_4     0.5
VARIABLE  M4_DN_4_W   200 
VARIABLE  M4_DN_6_W_A 80  
VARIABLE  M4_DN_6_S_A 40  
VARIABLE  M4_DN_6_E_A 40  
VARIABLE  M4_DN_6     0.01 
VARIABLE  M4_DN_6_W_BC 10
VARIABLE  M4_DN_6_S_BC 5  
VARIABLE  M4_DN_6_E_BC 5
VARIABLE  M4_DN_6_A_B 6400
VARIABLE  M4_DN_6_A_C 18000
VARIABLE  M4_DN_6_U   30
VARIABLE  M4_DN_6_W_A_R 40 // user value 
VARIABLE  M4_DN_6_S_A_R 40 // user value
VARIABLE  M4_DN_6_E_A_R 20 // user value 
VARIABLE  M4_DN_6_R     0.01 // user value 
VARIABLE  M4_DN_6_W_BC_R 10 // user value
VARIABLE  M4_DN_6_S_BC_R 5 // user value 
VARIABLE  M4_DN_6_E_BC_R 5 // user value
VARIABLE  M4_DN_6_A_B_R 1600 // user value
VARIABLE  M4_DN_6_A_C_R 4500 // user value
VARIABLE  M4_DN_6_U_R   30 // user value
VARIABLE  M4_DN_6_CS_A_R	40
VARIABLE  M4_DN_6_CS_B_R	10 
VARIABLE  M4_DN_6_CS_C_R	10 
VARIABLE  M2_DN_5_W   62.5
VARIABLE  M2_DN_5_S   31.25
VARIABLE  M2_DN_5     0.85
VARIABLE  M2_DN_7_W   30  
VARIABLE  M2_DN_7_S   15 
VARIABLE  M2_DN_7_E   15 
VARIABLE  M2_DN_7     0.05 
VARIABLE  M2_DN_7_W_R 15 // user value 
VARIABLE  M2_DN_7_S_R 15 // user value 
VARIABLE  M2_DN_7_E_R 7.5 // user value
VARIABLE  M2_DN_7_R   0.05 // user value
VARIABLE  M2_DN_7_CS_R	15 

VARIABLE  VIA4_W_1     0.07 
VARIABLE  VIA4_S_1     0.07 
VARIABLE  VIA4_S_1_1   0.2
VARIABLE  VIA4_S_2     0.09 
VARIABLE  VIA4_S_2_D   0.098 
VARIABLE  VIA4_S_3     0.095  
VARIABLE  VIA4_S_3_1   0.11 
VARIABLE  VIA4_EN_1    0
VARIABLE  VIA4_EN_2    0.03 
VARIABLE  VIA4_EN_4    0.01
VARIABLE  VIA4_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA4_R_2_S1  0.14 
VARIABLE  VIA4_R_2_S2  0.63 
VARIABLE  VIA4_R_2_W   0.21 
VARIABLE  VIA4_R_3_S1  0.14 
VARIABLE  VIA4_R_3_S2  0.83 
VARIABLE  VIA4_R_3_W   0.55 
VARIABLE  VIA4_R_4_W   0.21
VARIABLE  VIA4_R_4_D   1.14
VARIABLE  VIA4_R_5_W   1.4
VARIABLE  VIA4_R_5_D   2.8
VARIABLE  VIA4_R_6_W   2.1
VARIABLE  VIA4_R_6_L   7.0
VARIABLE  VIA4_R_6_D   7.1
VARIABLE  VIA4_R_11_L1 5.0
VARIABLE  VIA4_R_11_A  5.0
VARIABLE  VIA4_R_11_L2  1.0
VARIABLE  VIA4_R_11_W  0.21
#ELSE
VARIABLE  VIA4_R_2_S1  0.16
VARIABLE  VIA4_R_2_S2  0.70
VARIABLE  VIA4_R_2_W   0.235
VARIABLE  VIA4_R_3_S1  0.16
VARIABLE  VIA4_R_3_S2  0.92
VARIABLE  VIA4_R_3_W   0.605
VARIABLE  VIA4_R_4_W   0.235
VARIABLE  VIA4_R_4_D   1.14
VARIABLE  VIA4_R_5_W   1.54
VARIABLE  VIA4_R_5_D   2.80
VARIABLE  VIA4_R_6_W   2.31
VARIABLE  VIA4_R_6_L   7.70
VARIABLE  VIA4_R_6_D   7.10
VARIABLE  VIA4_R_11_L2  1.00
VARIABLE  VIA4_R_11_W  0.235
VARIABLE  VIA4_R_11_A  5.00
VARIABLE  VIA4_R_11_L1 5.00
#ENDIF

VARIABLE  M5_W_1      0.07 
VARIABLE  M5_W_2      0.17
VARIABLE  M5_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M5_W_3      4.50
VARIABLE  M5_S_2      0.10 
VARIABLE  M5_S_2_W    0.17 
VARIABLE  M5_S_2_L    0.27
VARIABLE  M5_S_2_1    0.12 
VARIABLE  M5_S_2_1_W  0.24 
VARIABLE  M5_S_2_1_L  0.27
VARIABLE  M5_S_2_2    0.15 
VARIABLE  M5_S_2_2_W  0.31 
VARIABLE  M5_S_2_2_L  0.40
VARIABLE  M5_S_2_3    0.21 
VARIABLE  M5_S_2_3_W  0.62 
VARIABLE  M5_S_2_3_L  0.62
VARIABLE  M5_S_3      0.50 
VARIABLE  M5_S_3_W    1.50 
VARIABLE  M5_S_3_L    1.50 
#ELSE
VARIABLE  M5_W_3      4.95 
VARIABLE  M5_S_2      0.10
VARIABLE  M5_S_2_W    0.19
VARIABLE  M5_S_2_L    0.30
VARIABLE  M5_S_2_1    0.12
VARIABLE  M5_S_2_1_W  0.265
VARIABLE  M5_S_2_1_L  0.30
VARIABLE  M5_S_2_2    0.15
VARIABLE  M5_S_2_2_W  0.345
VARIABLE  M5_S_2_2_L  0.44
VARIABLE  M5_S_2_3    0.21
VARIABLE  M5_S_2_3_W  0.685
VARIABLE  M5_S_2_3_L  0.685
VARIABLE  M5_S_2_4    0.075
VARIABLE  M5_S_2_4_W  0.17
VARIABLE  M5_S_2_4_L  0.30
VARIABLE  M5_S_2_5    0.11
VARIABLE  M5_S_2_5_W  0.24
VARIABLE  M5_S_2_5_L  0.30
VARIABLE  M5_S_2_6    0.13
VARIABLE  M5_S_2_6_W  0.31
VARIABLE  M5_S_2_6_L  0.44
VARIABLE  M5_S_2_7    0.165
VARIABLE  M5_S_2_7_W  0.62
VARIABLE  M5_S_2_7_L  0.685
VARIABLE  M5_S_3      0.50
VARIABLE  M5_S_3_W    1.65
VARIABLE  M5_S_3_L    1.65
#ENDIF
VARIABLE  M5_S_5      0.10 
VARIABLE  M5_S_5_W    0.10 
VARIABLE  M5_S_5_T    0.035 
VARIABLE  M5_S_5_L    0.07	
VARIABLE  M5_S_5_1    0.12
//VARIABLE  M5_S_5_1_L  0.07
VARIABLE  M5_S_5_1_W  0.10 
VARIABLE  M5_S_5_1_T  0.035
VARIABLE  M5_S_5_1_E  0.05 
VARIABLE  M5_S_5_1_E2 0.035
VARIABLE  M5_S_5_1_E3 0.040
VARIABLE  M5_S_5_1_E4 0.045
VARIABLE  M5_S_5_1_S2 0.115
VARIABLE  M5_S_5_1_S3 0.110
VARIABLE  M5_S_5_1_S4 0.105
VARIABLE  M5_S_6      0.17
VARIABLE  M5_S_8      0.1 
VARIABLE  M5_S_8_1    0.08
VARIABLE  M5_S_1_1    0.09

VARIABLE  M5_S_8_2    0.18
VARIABLE  M5_S_9      0.15
VARIABLE  M5_S_9_A   0.06
VARIABLE  M5_S_9_B   0.12
VARIABLE  M5_S_9_C   0.13
VARIABLE  M5_S_9_D   0.01
VARIABLE  M5_EN_1     0
VARIABLE  M5_EN_2     0.03 
VARIABLE  M5_EN_3     0.01
VARIABLE  M5_EN_3_1   0.02 
VARIABLE  M5_A_1      0.027 
VARIABLE  M5_A_2      0.06 
VARIABLE  M5_A_2_W    0.07 
VARIABLE  M5_A_2_L1    0.17
VARIABLE  M5_A_2_L2    0.17
VARIABLE  M5_A_3      0.20 
VARIABLE  M5_DN_1    0.1 
VARIABLE  M5_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M5_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M5_DN_1_E  M5_DN_1_W/4
VARIABLE  M5_DN_1_1  0.85
VARIABLE  M5_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M5_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M5_DN_1_1_E  M5_DN_1_1_W/4
VARIABLE  M5_DN_4     0.5
VARIABLE  M5_DN_4_W   200 
VARIABLE  M5_DN_6_W_A 80  
VARIABLE  M5_DN_6_S_A 40  
VARIABLE  M5_DN_6_E_A 40  
VARIABLE  M5_DN_6     0.01 
VARIABLE  M5_DN_6_W_BC 10
VARIABLE  M5_DN_6_S_BC 5  
VARIABLE  M5_DN_6_E_BC 5
VARIABLE  M5_DN_6_A_B 6400
VARIABLE  M5_DN_6_A_C 18000
VARIABLE  M5_DN_6_U   30
VARIABLE  M5_DN_6_W_A_R 40 // user value 
VARIABLE  M5_DN_6_S_A_R 40 // user value
VARIABLE  M5_DN_6_E_A_R 20 // user value 
VARIABLE  M5_DN_6_R     0.01 // user value 
VARIABLE  M5_DN_6_W_BC_R 10 // user value
VARIABLE  M5_DN_6_S_BC_R 5 // user value 
VARIABLE  M5_DN_6_E_BC_R 5 // user value
VARIABLE  M5_DN_6_A_B_R 1600 // user value
VARIABLE  M5_DN_6_A_C_R 4500 // user value
VARIABLE  M5_DN_6_U_R   30 // user value
VARIABLE  M5_DN_6_CS_A_R	40
VARIABLE  M5_DN_6_CS_B_R	10 
VARIABLE  M5_DN_6_CS_C_R	10 
VARIABLE  M3_DN_5_W   62.5
VARIABLE  M3_DN_5_S   31.25
VARIABLE  M3_DN_5     0.85
VARIABLE  M3_DN_7_W   30  
VARIABLE  M3_DN_7_S   15 
VARIABLE  M3_DN_7_E   15 
VARIABLE  M3_DN_7     0.05 
VARIABLE  M3_DN_7_W_R 15 // user value 
VARIABLE  M3_DN_7_S_R 15 // user value 
VARIABLE  M3_DN_7_E_R 7.5 // user value
VARIABLE  M3_DN_7_R   0.05 // user value
VARIABLE  M3_DN_7_CS_R	15 

VARIABLE  VIA5_W_1   0.36 
VARIABLE  VIA5_S_1   0.34 
VARIABLE  VIA5_S_2   0.54 
VARIABLE  VIA5_S_2_D 0.56
VARIABLE  VIA5_EN_1  0.02 
VARIABLE  VIA5_EN_2  0.08 
#IFNDEF  WIDE_ADJUST
VARIABLE  VIA5_R_2_S 1.7 
VARIABLE  VIA5_R_2_W 1.8 
VARIABLE  VIA5_R_3_W 3.0
VARIABLE  VIA5_R_3_L 10.0
VARIABLE  VIA5_R_3_D 5.0
#ELSE
VARIABLE  VIA5_R_2_S 1.87
VARIABLE  VIA5_R_2_W 1.98
VARIABLE  VIA5_R_3_W 3.3
VARIABLE  VIA5_R_3_L 11.0
VARIABLE  VIA5_R_3_D 5.0
#ENDIF

VARIABLE  M6_W_1   0.40
VARIABLE  M6_S_1   0.40
#IFNDEF WIDE_ADJUST
VARIABLE  M6_W_2   12.0 
VARIABLE  M6_S_2   0.5 
VARIABLE  M6_S_2_W 1.5 
VARIABLE  M6_S_2_L 1.5 
VARIABLE  M6_S_3   1.5 
VARIABLE  M6_S_3_W 4.5 
VARIABLE  M6_S_3_L 4.5 
#ELSE
VARIABLE  M6_W_2   13.2 
VARIABLE  M6_S_2   0.50
VARIABLE  M6_S_2_W 1.65
VARIABLE  M6_S_2_L 1.65
VARIABLE  M6_S_3   1.50
VARIABLE  M6_S_3_W 4.95
VARIABLE  M6_S_3_L 4.95
#ENDIF
VARIABLE  M6_EN_1  0.02 
VARIABLE  M6_EN_2  0.08 
VARIABLE  M6_A_1   0.565 
VARIABLE  M6_A_2   0.565 
VARIABLE  M6_DN_1    0.2
VARIABLE  M6_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M6_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M6_DN_1_E  M6_DN_1_W/4
VARIABLE  M6_DN_1_1  0.85
VARIABLE  M6_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M6_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M6_DN_1_1_E  M6_DN_1_1_W/4
VARIABLE  M6_DN_4     0.5
VARIABLE  M6_DN_4_W   200 


VARIABLE LOWMEDN_W_1 0.14
VARIABLE LOWMEDN_W_2 0.14
VARIABLE LOWMEDN_S_1 0.14
VARIABLE LOWMEDN_S_2 0.14
VARIABLE LOWMEDN_R_5 4
VARIABLE VIAx_W_6A  0.07
VARIABLE VIAx_W_6B  0.075
VARIABLE VIAx_S_7  0.365
VARIABLE VIAx_S_8  0.74
VARIABLE VIAx_EN_8 0.21
VARIABLE Mx_EN_4   0.21
VARIABLE  RV_W_1A    3.0
VARIABLE  RV_S_1     2.0
VARIABLE  RV_EN_1    0.5

#IFDEF AP_36K_THICKNESS
VARIABLE  AP_W_1     3.0
#ELSE
VARIABLE  AP_W_1     2.0
#ENDIF
VARIABLE  AP_W_2     35.0
VARIABLE  AP_S_1     2.0
VARIABLE  AP_S_1_1   2.5
VARIABLE  AP_EN_1    0.5
VARIABLE  AP_EN_1I   0.5
VARIABLE  AP_DN_1    0.1
#IFDEF AP_36K_THICKNESS
VARIABLE  AP_DN_1_1  0.85
#ELSE
VARIABLE  AP_DN_1_1  0.7
#ENDIF


VARIABLE  MOM_S_2    0.1

#IFDEF MOM_33V
VARIABLE  MOM_A_1     1.31E6
#ELSE
#IFDEF MOM_25V
VARIABLE  MOM_A_1     2.27E7
#ELSE
#IFDEF MOM_18V
VARIABLE  MOM_A_1     4.15E8
#ELSE
VARIABLE  MOM_A_1     1.31E6
#ENDIF
#ENDIF
#ENDIF





VARIABLE  PO_EX_2_R	0.13
VARIABLE  PO_EX_2_PS    0.16
#IFDEF GS
VARIABLE  PO_S_5_R	0.06
VARIABLE  PO_S_6_R	0.07
#ELSE
VARIABLE  PO_S_5_R	0.10
VARIABLE  PO_S_6_R	0.10
#ENDIF

VARIABLE  DOD_R_4_R	1.8
VARIABLE  OD_DN_4_R     0.10
VARIABLE  OD_DN_5_R     0.70
VARIABLE  OD_DN_6_R     0.20
VARIABLE  OD_DN_7_R     0.70
VARIABLE  OD_DN_8_R     0.2
VARIABLE  OD_DN_9_R     0.6
VARIABLE  DNW_EN_1_R	1.00
#IFNDEF GS
VARIABLE  PO_S_2_R	0.14
#ENDIF
VARIABLE  PO_S_17_R	0.16
VARIABLE  PO_S_17_R_GL	0.04
VARIABLE  PO_S_17_R_GW	0.2
VARIABLE  PO_S_17_R_W	0.12
VARIABLE  PO_S_17_R_L	0.1
VARIABLE  PO_S_18_R_1   0.14
VARIABLE  PO_S_18_R_2   0.2
VARIABLE  PO_S_18_R_GL	0.08
VARIABLE  PO_S_18_R_S	0.2
VARIABLE  PO_S_18_R_W	0.08
VARIABLE  PO_EX_1_R	0.11
VARIABLE  PO_DN_4_R     0.05
VARIABLE  PO_DN_5_R     0.35
VARIABLE  PO_DN_6_R     0.15
VARIABLE  PO_DN_7_R     0.35
VARIABLE  PO_DN_8_R     0.15
VARIABLE  PO_DN_9_R     0.40
VARIABLE  ESDIMP_EN_1R  0.4 // user value
VARIABLE  SRDPO_W_1_R	0.04
VARIABLE  SRDPO_W_1_S_R  0.32

VARIABLE  SRDPO_S_1_R	0.12 // user value
VARIABLE  SRDPO_L_3_R	10 // user value
VARIABLE  SRDPO_L_1_R	0.5 // user value
VARIABLE  SRDPO_DN_1_R   0.04
VARIABLE  SRDOD_W_1_R     0.1
VARIABLE  SRDOD_S_3_R    0.05 // user value
VARIABLE  SRDOD_DN_1_R   0.08
VARIABLE  SRDOD_DN_1_R_S1 2.5
VARIABLE  SRDOD_DN_1_R_S2 0.4

VARIABLE  NWROD_S_3_R	0.30
VARIABLE  NWRSTI_EN_2_R	0.30
VARIABLE  OD_W_1_R	   0.08
VARIABLE  PO_S_4_1_R	   0.14
VARIABLE  PO_S_4_1_A_R	0.0196
VARIABLE  CO_EN_1_R	   0.03
VARIABLE  CO_EN_1_1_R	0.04
VARIABLE  CO_EN_3_R   	0.04
VARIABLE  CO_S_7_R_L    0.05
VARIABLE  CO_S_7_R_W    1.0
VARIABLE  CO_S_7_R_S    0.22
VARIABLE  HVD_CO_S_7_R_S    1.0
VARIABLE  CO_S_7_R          0.29

VARIABLE  OD_S_1_R	0.10
VARIABLE  PO_S_1_R	0.12
VARIABLE  CO_S_3_R	0.05
VARIABLE  M1_S_1_R	0.09
VARIABLE  M2_S_1_R	0.09 // user value
VARIABLE  M3_S_1_R	0.09 // user value
VARIABLE  M4_S_1_R	0.09 // user value
VARIABLE  M5_S_1_R	0.09 // user value

VARIABLE  M1_EN_1_R	0.03
VARIABLE  M1_EN_2_R	0.05
VARIABLE  M1_EN_5_R     0.015
VARIABLE  M1_EN_5_R_W   0.11
VARIABLE  M1_EN_5_R_S   0.08
VARIABLE  M1_A_1_R      0.0351
VARIABLE  VIA1_EN_1_R	0.03
VARIABLE  VIA1_EN_2_R	0.05
VARIABLE  M2_EN_1_R	0.03
VARIABLE  M2_EN_2_R	0.05
VARIABLE  M2_A_1_R     0.0351
VARIABLE  VIA2_EN_1_R	0.03
VARIABLE  VIA2_EN_2_R	0.05
VARIABLE  M3_EN_1_R	0.03
VARIABLE  M3_EN_2_R	0.05
VARIABLE  M3_A_1_R     0.0351
VARIABLE  VIA3_EN_1_R	0.03
VARIABLE  VIA3_EN_2_R	0.05
VARIABLE  M4_EN_1_R	0.03
VARIABLE  M4_EN_2_R	0.05
VARIABLE  M4_A_1_R     0.0351
VARIABLE  VIA4_EN_1_R	0.03
VARIABLE  VIA4_EN_2_R	0.05
VARIABLE  M5_EN_1_R	0.03
VARIABLE  M5_EN_2_R	0.05
VARIABLE  M5_A_1_R     0.0351

VARIABLE  M1_S_7_R	0.35
VARIABLE  M2_S_7_R	0.35
VARIABLE  M3_S_7_R	0.35
VARIABLE  M4_S_7_R	0.35
VARIABLE  M5_S_7_R	0.35

VARIABLE  M6_W_3_R	0.42 // user value
VARIABLE  M6_W_3_S_R	5.00
VARIABLE  M6_W_3_G_R	1.00

VARIABLE  Mx_DN_8_W   0.07 
VARIABLE  Mx_DN_8_L   0.52
VARIABLE  Mx_DN_8_S   0.07 
VARIABLE  Mx_DN_8_R1  0.209 
VARIABLE  Mx_DN_8_R2  0.52
VARIABLE  Mx_DN_8     0.065 // user value

#IFDEF GS
VARIABLE  PO_S_14_MR	0.8 // user value
VARIABLE  PO_EN_1_MR	1.0 // user value
VARIABLE  PO_EN_2_MR	3.7
VARIABLE  PO_EN_3_MR	2.3 // user value
#ELSE
VARIABLE  PO_S_14_MR	1.40 // user value
VARIABLE  PO_EN_1_MR	1.40 // user value
VARIABLE  PO_EN_2_MR	2.00
VARIABLE  PO_EN_3_MR	1.80 // user value
#ENDIF
VARIABLE  PO_S_5_MR	0.20
VARIABLE  PO_S_6_MR	0.10
VARIABLE  PO_S_6_1_MR	0.18
VARIABLE  PO_S_6_1_W_MR	0.3
VARIABLE  PO_S_6_1_L_MR	0.1
VARIABLE  PO_EX_1_MR	0.11
VARIABLE  PO_EX_2_L_MR	0.29
VARIABLE  PO_EX_2_H_MR	0.48
VARIABLE  BJT_R_2_S_R	2.00
VARIABLE  BJT_R_2_M_R	5.00
VARIABLE  BJT_R_2_B_R	10.0
VARIABLE  DTCD_DN_1_R   0.7
VARIABLE  DTCD_DN_1_WR  2000
VARIABLE  MOM_DN_1_R  0.3
VARIABLE  IND_DN_8_R  0.2
VARIABLE  IND_DN_9_R  0.15

VARIABLE ICOVL_S_1  40
VARIABLE ICOVL_S_2  2000
VARIABLE ICOVL_S_3  2
VARIABLE ICOVL_S_4  1.1
VARIABLE ICOVL_S_5  0.1
VARIABLE ICOVL_W_1  1.1
VARIABLE ICOVL_W_2  1.1
VARIABLE ICOVL_W_3  0.17
VARIABLE ICOVL_W_4  16.5
VARIABLE ICOVL_W_5  16.5
VARIABLE ICOVL_EN_1 3.3
VARIABLE ICOVL_EN_2 3.92

VARIABLE ICOVL_R_7      8
VARIABLE ICOVL_R_8      4
VARIABLE ICOVL_R_9      6500
VARIABLE ICOVL_R_10     6500
VARIABLE ICOVL_R_11     8000
VARIABLE ICOVL_R_12     8000
VARIABLE ICOVL_R_13     16000
VARIABLE ICOVL_R_14     16000
VARIABLE ICOVL_R_15     13000
VARIABLE ICOVL_R_16     13000
VARIABLE ICOVL_R_17     0.25
VARIABLE ICOVL_R_17_S1  16500
VARIABLE ICOVL_R_17_S2  15500
VARIABLE ICOVL_R_18     0.25
VARIABLE ICOVL_R_18_S1  16500
VARIABLE ICOVL_R_18_S2  15500
VARIABLE ICOVL_R_19     0.25
VARIABLE ICOVL_R_19_S1  13000
VARIABLE ICOVL_R_19_S2  10000
VARIABLE ICOVL_R_20     0.25
VARIABLE ICOVL_R_20_S1  13000
VARIABLE ICOVL_R_20_S2  10000
VARIABLE ICOVL_R_21     1
VARIABLE ICOVL_R_21_S   2380
VARIABLE ICOVL_R_22     1
VARIABLE ICOVL_R_22_S   2380


VARIABLE  LOGO_S_1   10.0

VARIABLE  DTCD_W_1A 12.0
VARIABLE  DTCD_W_1B 9.245
VARIABLE  DTCD_W_2A 0.43
VARIABLE  DTCD_W_2B 4.0
VARIABLE  DTCD_W_2C 5.0
VARIABLE  DTCD_W_3  0.04
VARIABLE  DTCD_S_1  0.14
VARIABLE  DTCD_DN_2_R   0.5
VARIABLE  DTCD_DN_2_WR  2000
VARIABLE  DTCD_W_1_1A 5.71
VARIABLE  DTCD_W_1_1B 3.57
VARIABLE  DTCD_W_1_2A 3.6
VARIABLE  DTCD_W_1_2B 6.33
VARIABLE  DTCD_W_2_1A 0.31
VARIABLE  DTCD_W_2_1B 0.41
VARIABLE  DTCD_W_2_1C 2.4
VARIABLE  DTCD_S_1_1A 0.14
VARIABLE  DTCD_S_1_1B 0.2
VARIABLE  DTCD_S_1_1W 2.0
VARIABLE  DTCD_S_1_2  0.14
VARIABLE  DTCD_S_1_2W 2.0
VARIABLE  DTCD_R_4    0.5

VARIABLE  DOD_W_1   0.5
VARIABLE  DOD_S_1   0.4
VARIABLE  DOD_S_2   0.34
VARIABLE  DOD_S_3   0.3
VARIABLE  DOD_S_5   0.3
VARIABLE  DOD_S_8   0.6
VARIABLE  DOD_S_10  1.2
VARIABLE  DOD_EN_1  0.3
VARIABLE  DOD_EN_2  0.6
VARIABLE  DPO_W_1   0.4
VARIABLE  DPO_S_1   0.3
VARIABLE  DPO_S_2   0.2
VARIABLE  DPO_S_3   0.5
VARIABLE  DPO_S_9   1.2
VARIABLE  DPO_EN_1  0.6
VARIABLE  DM1_W_2     3.0
VARIABLE  DM1_S_3     1.5
VARIABLE  DM1_S_3_W   4.5
VARIABLE  DM1_S_3_L   4.5
VARIABLE  DM1_EN_1    2.5

VARIABLE  DM2_W_2     3.0
VARIABLE  DM2_S_3     1.5
VARIABLE  DM2_S_3_W   4.5
VARIABLE  DM2_S_3_L   4.5
VARIABLE  DM2_EN_1    2.5

VARIABLE  DM3_W_2     3.0
VARIABLE  DM3_S_3     1.5
VARIABLE  DM3_S_3_W   4.5
VARIABLE  DM3_S_3_L   4.5
VARIABLE  DM3_EN_1    2.5

VARIABLE  DM4_W_2     3.0
VARIABLE  DM4_S_3     1.5
VARIABLE  DM4_S_3_W   4.5
VARIABLE  DM4_S_3_L   4.5
VARIABLE  DM4_EN_1    2.5

VARIABLE  DM5_W_2     3.0
VARIABLE  DM5_S_3     1.5
VARIABLE  DM5_S_3_W   4.5
VARIABLE  DM5_S_3_L   4.5
VARIABLE  DM5_EN_1    2.5

VARIABLE  DM6_W_2     3.0
VARIABLE  DM6_S_3     1.5
VARIABLE  DM6_S_3_W   4.5
VARIABLE  DM6_S_3_L   4.5
VARIABLE  DM6_EN_1    2.5


VARIABLE  DM1_W_1   0.14
VARIABLE  DM1_S_1   0.14
VARIABLE  DM1_S_2a  0.6
VARIABLE  DM1_S_2b  1.5
VARIABLE  DM1_A_1   0.16
VARIABLE  DM1_A_2   80.0
VARIABLE  DM1_EN_2  0.01

VARIABLE  DM2_W_1   0.14
VARIABLE  DM2_S_1   0.14
VARIABLE  DM2_S_2a  0.6
VARIABLE  DM2_S_2b  1.5
VARIABLE  DM2_A_1   0.16
VARIABLE  DM2_A_2   80.0
VARIABLE  DM2_EN_2  0.01

VARIABLE  DM3_W_1   0.14
VARIABLE  DM3_S_1   0.14
VARIABLE  DM3_S_2a  0.6
VARIABLE  DM3_S_2b  1.5
VARIABLE  DM3_A_1   0.16
VARIABLE  DM3_A_2   80.0
VARIABLE  DM3_EN_2  0.01

VARIABLE  DM4_W_1   0.14
VARIABLE  DM4_S_1   0.14
VARIABLE  DM4_S_2a  0.6
VARIABLE  DM4_S_2b  1.5
VARIABLE  DM4_A_1   0.16
VARIABLE  DM4_A_2   80.0
VARIABLE  DM4_EN_2  0.01

VARIABLE  DM5_W_1   0.14
VARIABLE  DM5_S_1   0.14
VARIABLE  DM5_S_2a  0.6
VARIABLE  DM5_S_2b  1.5
VARIABLE  DM5_A_1   0.16
VARIABLE  DM5_A_2   80.0
VARIABLE  DM5_EN_2  0.01

VARIABLE  DM6_W_1  0.4
VARIABLE  DM6_S_1  0.4
VARIABLE  DM6_S_2  0.6
VARIABLE  DM6_A_1  0.565
VARIABLE  DM6_A_2  160.0


VARIABLE  DVIA1_W_1   0.12
VARIABLE  DVIA1_S_1   0.2
VARIABLE  DVIA1_S_2   0.2
VARIABLE  DVIA1_EN_1  0.01
VARIABLE  DVIA1_R_3   0.01
VARIABLE  DVIA2_W_1   0.12
VARIABLE  DVIA2_S_1   0.2
VARIABLE  DVIA2_S_2   0.2
VARIABLE  DVIA2_EN_1  0.01
VARIABLE  DVIA2_R_3   0.01
VARIABLE  DVIA3_W_1   0.12
VARIABLE  DVIA3_S_1   0.2
VARIABLE  DVIA3_S_2   0.2
VARIABLE  DVIA3_EN_1  0.01
VARIABLE  DVIA3_R_3   0.01
VARIABLE  DVIA4_W_1   0.12
VARIABLE  DVIA4_S_1   0.2
VARIABLE  DVIA4_S_2   0.2
VARIABLE  DVIA4_EN_1  0.01
VARIABLE  DVIA4_R_3   0.01

VARIABLE  LUP_2       15.0
VARIABLE  LUP_2_S     5.0
VARIABLE  LUP_3_W     0.2
VARIABLE  LUP_3_1_1   2.0
VARIABLE  LUP_3_1_2   3.0
VARIABLE  LUP_3_2_1   2.3
VARIABLE  LUP_3_2_2   4.0
VARIABLE  LUP_3_3_1   2.6
VARIABLE  LUP_3_3_2   5.0
VARIABLE  LUP_3_4_1   4.0
VARIABLE  LUP_3_4_2   8.0
VARIABLE  LUP_3_5_1   10
VARIABLE  LUP_3_5_2   15
VARIABLE  LUP_4       0.12
VARIABLE  LUP_5_1_1   2.0
VARIABLE  LUP_5_1_2   3.0
VARIABLE  LUP_5_2_1   2.3
VARIABLE  LUP_5_2_2   4.0
VARIABLE  LUP_5_3_1   2.6
VARIABLE  LUP_5_3_2   5.0
VARIABLE  LUP_5_4_1   4.0
VARIABLE  LUP_5_4_2   8.0
VARIABLE  LUP_5_5_1   10
VARIABLE  LUP_5_5_2   15
VARIABLE  LUP_6       30.0
VARIABLE  LUP_6_SRAM  40.0
VARIABLE  LUP_10      75.0
VARIABLE  LUP_10E     3.0
VARIABLE  LUP_13      15.0
VARIABLE  LUP_14      0.2

VARIABLE  ESD_3g_MIN  15.0
VARIABLE  ESD_3g_MAX  60.0
VARIABLE  ESD_6g      2.00
VARIABLE  ESD_7g      1.20
VARIABLE  ESD_16g      360
VARIABLE  ESD_17g      480
VARIABLE  ESD_18g_33V 0.42
VARIABLE  ESD_18g_25V 0.35
VARIABLE  ESD_18g_18V 0.20

VARIABLE  ESD_18g_LV     0.10
VARIABLE  ESD_20g     0.06
VARIABLE  ESD_21g     1.00
VARIABLE  ESD_22g     0.60
VARIABLE  ESD_23g     0.22
VARIABLE  ESD_24g      360
VARIABLE  ESD_25g      480
VARIABLE  ESD_26g_5V  0.42
VARIABLE  ESD_26g_33V 0.35
VARIABLE  ESD_26g_25V 0.20
VARIABLE  ESD_28g     0.06
VARIABLE  ESD_29g     0.06
VARIABLE  ESD_30g     1.00
VARIABLE  ESD_31g     0.60
VARIABLE  ESD_32g     0.22
VARIABLE  ESD_33g     0.25
VARIABLE  ESD_33g_MIN  0.22
VARIABLE  ESD_37g_HV  1000
VARIABLE  ESD_37g_LV  1900
VARIABLE  ESD_38g_33V 0.42
VARIABLE  ESD_38g_25V 0.35
VARIABLE  ESD_38g_18V 0.20

VARIABLE  ESD_38g_LV  0.10
VARIABLE  ESD_39g     1000
VARIABLE  ESD_40g     0.06
VARIABLE  ESD_41g     0.6
VARIABLE  ESD_42g     0.11
VARIABLE  ESD_48g  360
VARIABLE  ESD_49g  360
VARIABLE  ESD_50g  0.35
VARIABLE  ESD_51g_MIN 15
VARIABLE  ESD_51g_MAX 60
VARIABLE  ESD_53g  0.86
VARIABLE  ESD_54g  1.95
VARIABLE  ESD_55g  0.1
VARIABLE  ESD_56g  0.22
VARIABLE  ESD_57g  2.4

VARIABLE  SRESD_W_1   0.18
VARIABLE  SRESD_W_2   0.10
VARIABLE  SRESD_W_3a  15
VARIABLE  SRESD_W_3b  60
VARIABLE  SRESD_S_1   0.18
VARIABLE  SRESD_EX_1  0.02
VARIABLE  SRESD_L_1   60



VARIABLE  SRAM_W_1     0.19
VARIABLE  SRAM_S_1     0.19
VARIABLE  SRAM_S_2     0.14

VARIABLE  SRAM_BTC_S_1 0.09
VARIABLE  SRAM_BTC_S_2 0.055
VARIABLE  SRAM_BTC_S_3 0.067
VARIABLE  SRAM_EN_1    0.14
VARIABLE  SRAM_EN_2    0.09
VARIABLE  SRAM_EX_1    0.19
VARIABLE  SRAM_O_1     0.19
VARIABLE  SRAM_A_1     11
VARIABLE  SRAM_R_31_W  0.3
VARIABLE  SRAM_R_31_S1 0.14
VARIABLE  SRAM_R_31_S2 0.63
VARIABLE  SRAM_R_32_W  0.3
VARIABLE  SRAM_R_32_D  1.14
VARIABLE  SRAM_WARN_1  5168000
VARIABLE  SRAM_WARN_2  10336000

VARIABLE  NPre_W_1   0.2
VARIABLE  NPre_S_1   0.18
VARIABLE  NPre_S_2   0.08
VARIABLE  NPre_S_4   0.02
VARIABLE  NPre_S_5   0.23
VARIABLE  NPre_S_7   0.14
VARIABLE  NPre_EX_4  0.03
VARIABLE  NPre_O_1   0.01
VARIABLE  NPre_A_1   0.11
VARIABLE  NPre_A_2   0.11
VARIABLE  NPre_L_1   0.50

VARIABLE  WLD_R_2   0.035
VARIABLE  WLD_R_3   0.1
VARIABLE  WLD_R_7   100
VARIABLE  WLD_R_9   2

VARIABLE  CO2_W_1   0.06
VARIABLE  CO2_R_2   0.015*0.005 // user value

VARIABLE  ROM_W_1A  0.12
VARIABLE  ROM_W_1B  0.35
VARIABLE  ROM_W_2A  0.045
VARIABLE  ROM_W_2B  0.05

VARIABLE  IND_W_1   0.28-2*GRID // user value
VARIABLE  IND_W_2   0.28-2*GRID // user value
VARIABLE  IND_W_3   0.40-2*GRID // user value
VARIABLE  IND_W_4   0.40-2*GRID // user value
VARIABLE  IND_W_5   0.55-2*GRID // user value
VARIABLE  IND_W_6   2.00-2*GRID // user value
VARIABLE  IND_W_7   4.50+2*GRID // user value
VARIABLE  IND_W_8   12.0+2*GRID // user value
VARIABLE  IND_W_9   30.0+2*GRID // user value
VARIABLE  IND_W_10  600+2*GRID // user value
VARIABLE  IND_S_1   0.28-2*GRID // user value
VARIABLE  IND_S_2   0.28-2*GRID // user value
VARIABLE  IND_S_3   0.40-2*GRID // user value
VARIABLE  IND_S_4   0.40-2*GRID // user value
VARIABLE  IND_S_5   0.55-2*GRID // user value
VARIABLE  IND_S_6   1.00-2*GRID // user value
VARIABLE  IND_S_7   0.50-2*GRID // user value
VARIABLE  IND_S_7_W 1.50
VARIABLE  IND_S_7_L 1.50
VARIABLE  IND_S_8   0.65-2*GRID // user value
VARIABLE  IND_S_8_W 1.50
VARIABLE  IND_S_8_L 1.50
VARIABLE  IND_S_9   1.50-2*GRID // user value
VARIABLE  IND_S_9_W 4.50
VARIABLE  IND_S_9_L 4.50
VARIABLE  IND_S_10   2.0-2*GRID // user value
VARIABLE  IND_S_10_W 12.0
VARIABLE  IND_S_10_L 12.0
VARIABLE  IND_R_2    1.7
VARIABLE  IND_R_3    1.7
VARIABLE  IND_R_4    1.7
VARIABLE  IND_DN_1   0.05
VARIABLE  IND_DN_2   0.85
VARIABLE  IND_DN_2_W 125
VARIABLE  IND_DN_2_S 62.5
VARIABLE  IND_DN_3   0.20
VARIABLE  IND_DN_7   0.14
VARIABLE  IND_DN_7_W 1600
VARIABLE  IND_DN_7_S  800
#IFDEF IND_INTER_MET_VIA
VARIABLE  IND_DN_6   0.15 // user value
VARIABLE  IND_DN_6R  4
VARIABLE  IND_DN_6W  125 // user value
VARIABLE  IND_R_11   0.14 // user value
VARIABLE  IND_R_11C  100 // user value
VARIABLE  IND_R_12   0.29 // user value
VARIABLE  IND_R_12C  81 // user value
VARIABLE  IND_R_13   0.57 // user value
VARIABLE  IND_R_13C  36 // user value
#ENDIF



VARIABLE OD_SEx_eDRAM  0.05
VARIABLE OD_SEy_eDRAM  0.002


// for analog variable
VARIABLE BJT_R_1_G1	0.3
VARIABLE BJT_R_8	0.13

VARIABLE  CSR_R_1    74
VARIABLE  CSR_W_1A   9
VARIABLE  CSR_W_1B   10 // user value
VARIABLE  CSR_L_1A   24
VARIABLE  CSR_L_1B   25 // user value
VARIABLE  CSR_R_3A   18 
VARIABLE  CSR_R_3B   20 // user value
VARIABLE  SR_S_1     6

VARIABLE CSR_DM1_W_1    0.8 // user value
VARIABLE CSR_DM1_S_1    0.4 // user value
VARIABLE CSR_DM1_S_2    0.5 // user value
VARIABLE CSR_DM1_O_1    0.7 // user value
VARIABLE SR_DM1_W_1     0.8 // user value
VARIABLE SR_DM1_S_1     0.4 // user value
VARIABLE SR_DM1_S_2     0.4 // user value
VARIABLE SR_DM1_O_1     0.7 // user value

VARIABLE CSR_DM2_W_1    0.8 // user value
VARIABLE CSR_DM2_S_1    0.4 // user value
VARIABLE CSR_DM2_S_2    0.5 // user value
VARIABLE CSR_DM2_O_1    0.7 // user value
VARIABLE SR_DM2_W_1     0.8 // user value
VARIABLE SR_DM2_S_1     0.4 // user value
VARIABLE SR_DM2_S_2     0.4 // user value
VARIABLE SR_DM2_O_1     0.7 // user value

VARIABLE CSR_DM3_W_1    0.8 // user value
VARIABLE CSR_DM3_S_1    0.4 // user value
VARIABLE CSR_DM3_S_2    0.5 // user value
VARIABLE CSR_DM3_O_1    0.7 // user value
VARIABLE SR_DM3_W_1     0.8 // user value
VARIABLE SR_DM3_S_1     0.4 // user value
VARIABLE SR_DM3_S_2     0.4 // user value
VARIABLE SR_DM3_O_1     0.7 // user value

VARIABLE CSR_DM4_W_1    0.8 // user value
VARIABLE CSR_DM4_S_1    0.4 // user value
VARIABLE CSR_DM4_S_2    0.5 // user value
VARIABLE CSR_DM4_O_1    0.7 // user value
VARIABLE SR_DM4_W_1     0.8 // user value
VARIABLE SR_DM4_S_1     0.4 // user value
VARIABLE SR_DM4_S_2     0.4 // user value
VARIABLE SR_DM4_O_1     0.7 // user value

VARIABLE CSR_DM5_W_1    0.8 // user value
VARIABLE CSR_DM5_S_1    0.4 // user value
VARIABLE CSR_DM5_S_2    0.5 // user value
VARIABLE CSR_DM5_O_1    0.7 // user value
VARIABLE SR_DM5_W_1     0.8 // user value
VARIABLE SR_DM5_S_1     0.4 // user value
VARIABLE SR_DM5_S_2     0.4 // user value
VARIABLE SR_DM5_O_1     0.7 // user value

VARIABLE CSR_DM6_W_1    0.8 // user value
VARIABLE CSR_DM6_S_1    0.4 // user value
VARIABLE CSR_DM6_S_2    0.5 // user value
VARIABLE CSR_DM6_O_1    0.7 // user value
VARIABLE SR_DM6_W_1     0.8 // user value 
VARIABLE SR_DM6_S_1     0.4 // user value
VARIABLE SR_DM6_S_2     0.4 // user value
VARIABLE SR_DM6_O_1     0.7 // user value



VARIABLE CSR_DV1_W_1    0.07  // user value
VARIABLE CSR_DV1_S_1    0.11  // user value
VARIABLE CSR_DV1_EN_1   0.135 // user value
VARIABLE SR_DV1_W_1     0.07  // user value      
VARIABLE SR_DV1_S_1     0.11  // user value
VARIABLE SR_DV1_EN_1    0.135 // user value


VARIABLE CSR_DV2_W_1    0.07  // user value
VARIABLE CSR_DV2_S_1    0.11  // user value
VARIABLE CSR_DV2_EN_1   0.135 // user value
VARIABLE SR_DV2_W_1     0.07  // user value      
VARIABLE SR_DV2_S_1     0.11  // user value
VARIABLE SR_DV2_EN_1    0.135 // user value


VARIABLE CSR_DV3_W_1    0.07  // user value
VARIABLE CSR_DV3_S_1    0.11  // user value
VARIABLE CSR_DV3_EN_1   0.135 // user value
VARIABLE SR_DV3_W_1     0.07  // user value      
VARIABLE SR_DV3_S_1     0.11  // user value
VARIABLE SR_DV3_EN_1    0.135 // user value


VARIABLE CSR_DV4_W_1    0.07  // user value
VARIABLE CSR_DV4_S_1    0.11  // user value
VARIABLE CSR_DV4_EN_1   0.135 // user value
VARIABLE SR_DV4_W_1     0.07  // user value      
VARIABLE SR_DV4_S_1     0.11  // user value
VARIABLE SR_DV4_EN_1    0.135 // user value


VARIABLE CSR_DV5_W_1    0.36 // user value
VARIABLE CSR_DV5_S_1    0.84 // user value
VARIABLE CSR_DV5_EN_1   0.17 // user value
VARIABLE SR_DV5_W_1     0.36 // user value
VARIABLE SR_DV5_S_1     0.84 // user value
VARIABLE SR_DV5_EN_1    0.17 // user value


// for box in box variable
VARIABLE BIB_S_1        4
VARIABLE BIB_S_2        1.5
#IFDEF P4_SEALRING
VARIABLE BIB_W_1        2
VARIABLE BIB_W_2        0.35
VARIABLE BIB_S_3        0.36
VARIABLE BIB_L_1        16
VARIABLE BIB_L_2        6
VARIABLE BIB_L_3        16
VARIABLE BIB_EN_1       3
VARIABLE BIB_EN_2       3
VARIABLE BIB_EN_3       3
#ELSE
VARIABLE BIB_W_1        1.1
VARIABLE BIB_W_2        0.17
VARIABLE BIB_W_3        0.965
VARIABLE BIB_S_3        0.095
VARIABLE BIB_L_1        16.5
VARIABLE BIB_L_2        7.7
VARIABLE BIB_L_3        16.5
VARIABLE BIB_L_4_1      6.265
VARIABLE BIB_L_4_2      6.53
VARIABLE BIB_EN_1       3.3
VARIABLE BIB_EN_2       4
VARIABLE BIB_EN_3       4
#ENDIF
VARIABLE BIB_EN_4       5 // user value
VARIABLE BIB_EN_5       5 // user value
VARIABLE BIB_R_2        52 // user value
VARIABLE BIB_R_3        28 // user value
VARIABLE CB_O_1         1 // user value
VARIABLE CB_W_3         2
VARIABLE CB_EN_2        1
VARIABLE AP_W_3         8
VARIABLE AP_EN_2        1
VARIABLE CB2_W_5        2
VARIABLE CB_W_4         2
VARIABLE CB_EN_3        1
VARIABLE AP_W_4         4
VARIABLE CB2_W_6        2

VARIABLE  CO_W_2        0.06
VARIABLE  M1_W_4        2
VARIABLE  M1_W_5        6
VARIABLE  M1_W_6        0.5

VARIABLE  VIA1_W_2      0.5
VARIABLE  VIA1_W_3      0.07
VARIABLE  VIA1_W_4      0.5
VARIABLE  VIA1_W_5      0.07
VARIABLE  VIA1_S_4      0.35
VARIABLE  VIA1_S_5      0.365
VARIABLE  VIA1_S_6      0.35
VARIABLE  VIA1_EN_5     0.21
VARIABLE  VIA1_EN_6     0.22
VARIABLE  VIA1_EN_7     0.015
VARIABLE  M2_W_4       2
VARIABLE  M2_W_5       6
VARIABLE  M2_W_6       0.5

VARIABLE  VIA2_W_2      0.5
VARIABLE  VIA2_W_3      0.07
VARIABLE  VIA2_W_4      0.5
VARIABLE  VIA2_W_5      0.07
VARIABLE  VIA2_S_4      0.35
VARIABLE  VIA2_S_5      0.365
VARIABLE  VIA2_S_6      0.35
VARIABLE  VIA2_EN_5     0.21
VARIABLE  VIA2_EN_6     0.22
VARIABLE  VIA2_EN_7     0.015
VARIABLE  M3_W_4       2
VARIABLE  M3_W_5       6
VARIABLE  M3_W_6       0.5

VARIABLE  VIA3_W_2      0.5
VARIABLE  VIA3_W_3      0.07
VARIABLE  VIA3_W_4      0.5
VARIABLE  VIA3_W_5      0.07
VARIABLE  VIA3_S_4      0.35
VARIABLE  VIA3_S_5      0.365
VARIABLE  VIA3_S_6      0.35
VARIABLE  VIA3_EN_5     0.21
VARIABLE  VIA3_EN_6     0.22
VARIABLE  VIA3_EN_7     0.015
VARIABLE  M4_W_4       2
VARIABLE  M4_W_5       6
VARIABLE  M4_W_6       0.5

VARIABLE  VIA4_W_2      0.5
VARIABLE  VIA4_W_3      0.07
VARIABLE  VIA4_W_4      0.5
VARIABLE  VIA4_W_5      0.07
VARIABLE  VIA4_S_4      0.35
VARIABLE  VIA4_S_5      0.365
VARIABLE  VIA4_S_6      0.35
VARIABLE  VIA4_EN_5     0.21
VARIABLE  VIA4_EN_6     0.22
VARIABLE  VIA4_EN_7     0.015
VARIABLE  M5_W_4       2
VARIABLE  M5_W_5       6
VARIABLE  M5_W_6       0.5

VARIABLE  VIA5_W_2   0.5
VARIABLE  VIA5_W_3   0.36
#IFDEF P3_SEALRING
VARIABLE  VIA5_W_2_P3   2 // user value
VARIABLE  VIA5_W_3_P3   6 // user value
#ENDIF
VARIABLE  VIA5_W_4   0.5
VARIABLE  VIA5_W_5   0.36
VARIABLE  VIA5_S_4   0.54
VARIABLE  VIA5_S_5   0.34
VARIABLE  VIA5_S_6   0.54
VARIABLE  VIA5_S_7   0.54
VARIABLE  VIA5_EN_5  0.21
VARIABLE  VIA5_EN_5_1 0.3
VARIABLE  VIA5_EN_6  0.21
VARIABLE  M6_W_4    2
VARIABLE  M6_W_5    6
VARIABLE  M6_W_6    3.5






LAYER RESOLUTION COi 1	// inside SRAM periphrial regions only
LAYER RESOLUTION POi 1	// inside SRAM periphrial regions only

// DRAWN LAYER DEFINITIONS
//------------------------
LAYER DNWi       1       // deep-nwell
LAYER NWi        3000    // nwell technology
LAYER MAP 3 DATATYPE >=0 <=255 3000
LAYER NWiOTHERS 3001     
LAYER MAP 3 DATATYPE >=1 <=255 3001
LAYER OD12i      1401    // define 1.2V core oxides
LAYER MAP 14 DATATYPE 1 1401
LAYER OD18i      16      // define 1.8V thick gate oxides
LAYER OD1815     442     // define 1.8V thick gate oxides underdrive 1.5v, drc dummy layer
LAYER MAP 16 DATATYPE 4 442
LAYER OD25i      18      // define 2.5V thick gate oxides
LAYER OD2533     451     // define 2.5V thick gate oxides overdrive 3.3v, drc dummy layer
LAYER MAP 18 DATATYPE 3 451
LAYER OD2518     452     // define 2.5V thick gate oxides underdrive 1.8v, drc dummy layer
LAYER MAP 18 DATATYPE 4 452
LAYER OD25_LK    453     // Low gate oxide leakage, reserve for N45 process
LAYER MAP 18 DATATYPE 6 453
LAYER OD33i      15      // define 3.3V thick gate oxides
LAYER ODDECAP    118     // decoupling capacitor device region
LAYER PPi        25      // P+ S/D imlant
LAYER NPi        26      // N+ S/D imlant
LAYER HVD_N      9101	// Define N-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 1 9101 
LAYER HVD_P      9102	// Define P-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 2 9102 
LAYER DEHVD_N    9109	// Define DENMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 9 9109 
LAYER COi        30      // Define connect for M1 to S/D and Gate
LAYER COPUSH     3011    // rule pushed contact in SRAM cell
LAYER MAP 30 DATATYPE 11 3011
LAYER COiSRAM 3012
LAYER MAP 30 DATATYPE >=11 <=13 3012
LAYER MAP 30 DATATYPE >=17 <=25 3012
LAYER COiOTHERS 3013
LAYER MAP 30 DATATYPE >=1 <=10 3013
LAYER MAP 30 DATATYPE >=12 <=255 3013
LAYER CBi        76      // Passivation opening for Bond Pad
LAYER CB2Fi      8600    // Passivation-2 opening for Flip-Chip
LAYER MAP 86 DATATYPE 0  8600
LAYER CB2Wi      8620    // Passivation-2 opening for Wire-Bond
LAYER MAP 86 DATATYPE 20 8620
LAYER RPOi       29      // Silicided Block Layer
LAYER NTNi       11000   // Native NMOS blocked implant
LAYER MAP 11 DATATYPE 0  11000
LAYER NCapNTNi   11020   // connected NMOS capacitors within same NT_N region
LAYER MAP 11 DATATYPE 20 11020
LAYER LPP_NTNi	 11010         // for LP+ NMOS native device
LAYER MAP 11 DATATYPE 10 11010
LAYER LPP_NTN_21i 11021
LAYER MAP 11 DATATYPE 21 11021
LAYER LPP_NTN_DPOi 11022
LAYER MAP 11 DATATYPE 22 11022
LAYER LPP_NTN_120i 11120
LAYER MAP 11 DATATYPE 120 11120
LAYER POFUSE     648     // Poly fuse implant layer, cover all poly fuse region    
LAYER MAP 156 DATATYPE 0 648
LAYER FUSELINK 649       // Dummy layer to cover poly fuse link region.   
LAYER MAP 156 DATATYPE 1 649
LAYER PMi      50000       // Polymide (if drawn)
LAYER MAP 5 DATATYPE 0 50000
LAYER PM1i   	 5001    // polyimide 1 window for WLCSP
LAYER MAP 5 DATATYPE 1 5001
LAYER PM2i   	 5002    // polyimide 2 window for WLCSP
LAYER MAP 5 DATATYPE 2 5002
LAYER MAP 170 DATATYPE 12 5002  // pad recognition layer for 2-mask WLCSP
LAYER SEALRING_ORI 1620         // INITIAL SR Region
LAYER MAP 162 DATATYPE 0 1620
LAYER SEALRING_DB 1621          // SLDB Region
LAYER MAP 162 DATATYPE 1 1621
LAYER SEALRING_ALL 1622         // SLDB+SR_ISO Region
LAYER MAP 162 DATATYPE 2 1622
LAYER VTHNi      67      // High Vt NMOS Implant for core device
LAYER VTHPi      68      // High Vt PMOS Implant for core device
LAYER VTLNi      1200      // Low Vt NMOS Implant for core device
LAYER MAP 12 DATATYPE 0 1200
LAYER VTLPi      1300      // Low Vt PMOS Implant for core device
LAYER MAP 13 DATATYPE 0 1300
LAYER VTULNi     1510     // Ultra low Vt NMOS Implant for eDRAM
LAYER MAP 151 DATATYPE 0 1510
LAYER VTULPi     1520     // Ultra low Vt PMOS Implant for eDRAM
LAYER MAP 152 DATATYPE 0 1520
LAYER ULVT_Ni     1511     //  Ultra low Vt NMOS Implant for core device
LAYER MAP 151 DATATYPE 1 1511
LAYER ULVT_Pi     1521     // Ultra low Vt PMOS Implant for core device
LAYER MAP 152 DATATYPE 1 1521
LAYER VTLN18      7901   // I/O 1.8V LVT device
LAYER MAP 79 DATATYPE 1 7901
LAYER CBDi       169     // CBD For solder Bump and RDL layer 
LAYER CBDB       16910   // Back-Side passivation window for bump (TSV)
LAYER MAP 169 DATATYPE 100 16910
LAYER UBMi       17000     // UBM For solder Bump and RDL layer 
LAYER MAP 170 DATATYPE 0 17000
LAYER UBMB       17010   // Back-Side under bump metal (TSV)
LAYER MAP 170 DATATYPE 100 17010
LAYER RH         117     // block NLDD/PLDD in OD/POLY resistor
LAYER RHDMY1     11704   // Dummy layer to exclude unsilicided OD/PO resistor with square number (length/width) less than one for non-precision usage
LAYER MAP 117 DATATYPE 4 11704
LAYER ESDIMP     1890    // ESD Implant layer
LAYER MAP 189 DATATYPE 0 1890
LAYER VARi       14300    // For both MOS and junction type varactor
LAYER MAP 143 DATATYPE 0 14300 
LAYER DVAR       14310   // For differential MOS varactor  
LAYER MAP 143 DATATYPE 10 14310  
LAYER APi        740
LAYER MAP 74 DATATYPE >=0 <=1 740
LAYER Cu_PPIi    7410    // Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 74 DATATYPE 10 7410
LAYER DMY_S_Pad  7413    // Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 74 DATATYPE 13 7413
LAYER DMY_U_Pad  7414    // Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 74 DATATYPE 14 7414
LAYER AP_BSL     7411    // Back-Side AlCu Redistributional layer (Al RDL) (TSV)
LAYER MAP 74 DATATYPE 100 7411
LAYER AP_BSP     7412    // Back-Side AP pin for text layer (TSV)
LAYER MAP 74 DATATYPE 102 7412
LAYER CBMi       88
LAYER CTMi       77
LAYER RVi        8500
LAYER MAP 85 DATATYPE 0 8500
LAYER RV_BSL     8510    // Back-Side Via hole for AlCu Redistributional layer (Al RDL) (TSV)
LAYER MAP 85 DATATYPE 100 8510
LAYER DCOi       9000    // Dual Core oxide layer used to cover G core device
LAYER MAP 90 DATATYPE 0  9000
LAYER DCO_LPPi   9010    // Daul Core oxide layer used to cover N40LP+ core device
LAYER MAP 90 DATATYPE 1  9010
LAYER DCODMY_SCi 9020
LAYER MAP 90 DATATYPE 2  9020
LAYER LMARK      109     // Alignment Mark Rule for Laser Repair
// SRAM LAYERS
LAYER SRM        5000
LAYER MAP 50 DATATYPE 0  5000 
LAYER SRMN       5010    // define SRAM NMOS cell implant
LAYER MAP 50 DATATYPE 1  5010 
LAYER SRMP       5020    // define SRAM PMOS cell implant
LAYER MAP 50 DATATYPE 2  5020 
LAYER SRMRP      5050    // to identify read port in 8T 2 port SRAM 
LAYER MAP 50 DATATYPE 5  5050 
LAYER NPreDOSRM  5021    // SRAM drawing layer for N+ Predoping area
LAYER MAP 50 DATATYPE 21 5021 
LAYER ROM        5006    // define ROM cell
LAYER MAP 50 DATATYPE 6  5006 
LAYER SRM_HS     5007    // Identify HS cell
LAYER MAP 50 DATATYPE 7  5007 
LAYER SRAMDMY            1860  // SRAM DRC violations waive layer		
LAYER MAP 186 DATATYPE 0 1860  		
LAYER SRAMDMY_PAS        1861  // SRAM pass gate region
LAYER MAP 186 DATATYPE 1 1861  		
LAYER SRAMDMY_PERI_LP    1864  // SRAM periphrial region for LP
LAYER MAP 186 DATATYPE 4 1864 
LAYER SRAMDMY_PERI_G     1865  // SRAM periphrial region for G
LAYER MAP 186 DATATYPE 5 1865
SRAMDMY_PERI = SRAMDMY_PERI_G OR SRAMDMY_PERI_LP
LAYER CO2         1000
LAYER MAP 100 DATATYPE 0 1000
LAYER DPSRM       8000            // 0.589
LAYER MAP 80 DATATYPE 0 8000       
LAYER PRSRM       8011    // bit-cell only area
LAYER MAP 80 DATATYPE 11 8011 
LAYER SRMLOP12    8012            // 0.252
LAYER MAP 80 DATATYPE 12 8012 
LAYER SRMLOP13    8013            // 0.374
LAYER MAP 80 DATATYPE 13 8013     
LAYER SRMLOP14    8014            // 0.299
LAYER MAP 80 DATATYPE 14 8014 
LAYER LVLOP       8015
LAYER MAP 80 DATATYPE 15 8015 
LAYER HCDPLOP     8016            // 0.741
LAYER MAP 80 DATATYPE 16 8016 
LAYER TPLOP_8T    8017
LAYER MAP 80 DATATYPE 17 8017 
LAYER TPLOP_10T   8018
LAYER MAP 80 DATATYPE 18 8018 

LAYER DUMMYOD1    8201
LAYER MAP 82 DATATYPE 1 8201
LAYER DUMMYOD2    8202
LAYER MAP 82 DATATYPE 2 8202
LAYER DUMMYOD3    8203
LAYER MAP 82 DATATYPE 3 8203
LAYER DUMMYOD4    8204
LAYER MAP 82 DATATYPE 4 8204
LAYER DUMMYOD5    8205
LAYER MAP 82 DATATYPE 5 8205
LAYER DUMMYOD6    8206
LAYER MAP 82 DATATYPE 6 8206
LAYER DUMMYOD7    8207
LAYER MAP 82 DATATYPE 7 8207
LAYER DUMMYOD8    8208
LAYER MAP 82 DATATYPE 8 8208
LAYER DUMMYOD9    8209
LAYER MAP 82 DATATYPE 9 8209
LAYER DUMMYOD10   8210
LAYER MAP 82 DATATYPE 10 8210
LAYER DUMMYOD11   8211
LAYER MAP 82 DATATYPE 11 8211
LAYER DUMMYOD12   8212
LAYER MAP 82 DATATYPE 12 8212
LAYER DUMMYOD13   8213
LAYER MAP 82 DATATYPE 13 8213
LAYER DUMMYOD14   8214
LAYER MAP 82 DATATYPE 14 8214
LAYER DUMMYOD15   8215
LAYER MAP 82 DATATYPE 15 8215
LAYER DUMMYOD16   8216
LAYER MAP 82 DATATYPE 16 8216

LAYER DUMMYPO1    8301
LAYER MAP 83 DATATYPE 1 8301
LAYER DUMMYPO2    8302
LAYER MAP 83 DATATYPE 2 8302
LAYER DUMMYPO3    8303
LAYER MAP 83 DATATYPE 3 8303
LAYER DUMMYPO4    8304
LAYER MAP 83 DATATYPE 4 8304
LAYER DUMMYPO5    8305
LAYER MAP 83 DATATYPE 5 8305
LAYER DUMMYPO6    8306
LAYER MAP 83 DATATYPE 6 8306
LAYER DUMMYPO7    8307
LAYER MAP 83 DATATYPE 7 8307
//eDRAM layers
LAYER RAM1TDMY   1600          // dummy layer to define eDRAM region
LAYER MAP 160 DATATYPE 0 1600 
LAYER OD1T       2700          // cell array oxide
LAYER MAP 27  DATATYPE 0 2700 
LAYER OD1TH      2701          // cell array oxide
LAYER MAP 27  DATATYPE 1 2701 
LAYER OD1TM      2702          // cell array oxide
LAYER MAP 27  DATATYPE 2 2702 
LAYER OD1T_WLD     2703          // cell array oxide
LAYER MAP 27  DATATYPE 3 2703 
LAYER OD1T_MOSCAP  2704          // cell array oxide
LAYER MAP 27  DATATYPE 4 2704 
LAYER OD1T_CP      2705          // cell array oxide
LAYER MAP 27  DATATYPE 5 2705 
LAYER OD1T_20      2706          // define OD1T device with the max operate DC bias >2.0V 
LAYER MAP 27  DATATYPE 6 2706 
LAYER OD1T_18      2707          // define OD1T device with the max operate DC bias >1.8V 
LAYER MAP 27  DATATYPE 7 2707 
LAYER OD1T_16      2708          // define OD1T device with the max operate DC bias >1.6V 
LAYER MAP 27  DATATYPE 8 2708 
LAYER CLDD       9200            // CLDD,1TRAM cell array region
LAYER MAP 92  DATATYPE 0 9200 
LAYER EDRAM_DECAP      9201      // Layer for drawing decoupling capacitor in EDRAM process
LAYER MAP 92  DATATYPE 1 9201 
LAYER SNCT       101           // NOde contact (bottom electrode contact)
LAYER CROWN      102           // capacitor bottom electrode
LAYER P3         103           // capacitor top electrode

//
// Dummy Layers
//
LAYER NWDMY      114     // NWEL resistor dummy layer
LAYER RPDMY      1150    // dummy layer to cover OD/PO resistor
LAYER MAP 115 DATATYPE 0 1150
LAYER MAP 115 DATATYPE 1 1150
LAYER SDI        1220     // cover IO ESD area
LAYER MAP 122 DATATYPE 0 1220
LAYER CSRDMY	 1660     // Layer to cover chip corner areas
LAYER MAP 166 DATATYPE 0 1660
LAYER CSRBIB1DMY 1661
LAYER MAP 166 DATATYPE 1 1661
LAYER CSRBIB2DMY 1662
LAYER MAP 166 DATATYPE 2 1662
LAYER CDUDMY     1650    // CDUDMY Dummy layer to cover CDU pattern in assembly isolation
LAYER MAP 165 DATATYPE 0  1650
LAYER TCDDMY     1651    // Dummy layer to cover TCD pattern
LAYER MAP 165 DATATYPE 1  1651
LAYER TCDDMY_H   1654    // Dummy layer to cover Horizontal TCD pattern
LAYER MAP 165 DATATYPE 4  1654
LAYER TCDDMY_V   1655    // Dummy layer to cover Vertical TCD pattern
LAYER MAP 165 DATATYPE 5  1655
LAYER ICOVL     1653     // Dummy layer for ICOVL pattern.
LAYER MAP 165 DATATYPE 3  1653
LAYER LOGO       158     // Dummy layer for product labels and LOGO
LAYER INDDMY     1440    // Dummy layer for inductor
LAYER MAP 144 DATATYPE >=0 <=14 1440
LAYER INDDMY_MD     1442    // Dummy layer for logic inductor with medium density
LAYER MAP 144 DATATYPE 42 1442
LAYER INDDMY_HD     1443    // Dummy layer for logic inductor with high medium density
LAYER MAP 144 DATATYPE 43 1443
LAYER TLDMY     11630     // Dummy layer for Transmission Lines
LAYER MAP 116 DATATYPE 30 11630
LAYER MOMDMY_1   1551    // Dummy layer for M1 MOM region
LAYER MAP 155 DATATYPE 1 1551
LAYER MOMDMY_2   1552    // Dummy layer for M2 MOM region
LAYER MAP 155 DATATYPE 2 1552
LAYER MOMDMY_3   1553    // Dummy layer for M3 MOM region
LAYER MAP 155 DATATYPE 3 1553
LAYER MOMDMY_4   1554    // Dummy layer for M4 MOM region
LAYER MAP 155 DATATYPE 4 1554
LAYER MOMDMY_5   1555    // Dummy layer for M5 MOM region
LAYER MAP 155 DATATYPE 5 1555
LAYER MOMDMY_6   1556    // Dummy layer for M6 MOM region
LAYER MAP 155 DATATYPE 6 1556
LAYER MOMDMY_AP  1570    // Dummy layer for AP MOM region
LAYER MAP 155 DATATYPE 20 1570
LAYER MOMDMY   1571     // Dummy layer for MOM
LAYER MAP 155 DATATYPE 21 1571
LAYER MOMDMY_0  1572     // Dummy layer for RTMOM
LAYER MAP 155 DATATYPE 0 1572
LAYER MOMDMY_100  1573   // Dummy layer for FMOM
LAYER MAP 155 DATATYPE 100 1573

LAYER MOMDMY_2T 15527
LAYER MAP 155 DATATYPE 27 15527
LAYER MOMDMY28 15528
LAYER MAP 155 DATATYPE 28 15528
LAYER MOMDMY31 15531
LAYER MAP 155 DATATYPE 31 15531
LAYER MOMDMY32 15532
LAYER MAP 155 DATATYPE 32 15532
LAYER MOMDMY33 15533
LAYER MAP 155 DATATYPE 33 15533
LAYER WBDMY      157     // For CUP purpose
LAYER DIODMYi     119  // Dummy layer for diode
LAYER DIO3TDMYi   1191   // Dummy layer to define 3 terminal diode 
LAYER MAP 119 DATATYPE 1 1191
DIODMY = DIODMYi or DIO3TDMYi
LAYER SRESD      1210    // SR (special rule) exclusion marker layer for N40G ESD device only
LAYER MAP 121 DATATYPE 0 1210
LAYER RODMY      49      // Dummy layer to exclude OD area in SRAM bit cell
LAYER RFDMY      1610    // For RF IP circuit
LAYER MAP 161 DATATYPE 0 1610
LAYER RFIPDMY    1611    // For RF IP circuit
LAYER MAP 161 DATATYPE 1 1611
LAYER LUPWDMY    2551    // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER LUPWDMY_2    2518    // DRC dummy layer to check Area Array IO LUP rules.
LAYER MAP 255 DATATYPE 18 2518




LAYER M1i         501			// Metal1 layer
LAYER MAP 31 DATATYPE 0  501		// Mapping (31;0) to 501 for M1i
LAYER MAP 31 DATATYPE 7  501		// Mapping (DM1_O, 31;7) to 501 for M1i, OPC dummy metal
LAYER DM1_O       781 
LAYER MAP 31 DATATYPE 7  781		// Mapping (DM1_O, 31;7) to 781 for DM1_O, OPC dummy metal
LAYER M1i_R       761			// Metal1 layer for real metal
LAYER MAP 31 DATATYPE 0  761	// Mapping (31;0) to 761 for M1i_R, real metal
LAYER DUM1        541			// dummy Metal1
LAYER MAP 31 DATATYPE 1  541		// Mapping (31;1) to 541 for DUM1
LAYER NOUSEM1     581                 
LAYER MAP 31 DATATYPE 20 581		// Mapping (31;20) to 581 for forbidden
LAYER MAP 31 DATATYPE 21 581		// Mapping (31;21) to 581 for forbidden
LAYER MAP 31 DATATYPE 40 581		// Mapping (31;40) to 581 for forbidden
LAYER MAP 31 DATATYPE 41 581		// Mapping (31;41) to 581 for forbidden
LAYER MAP 31 DATATYPE 60 581		// Mapping (31;60) to 581 for forbidden
LAYER MAP 31 DATATYPE 61 581		// Mapping (31;61) to 581 for forbidden
LAYER MAP 31 DATATYPE 80 581		// Mapping (31;80) to 581 for forbidden
LAYER MAP 31 DATATYPE 81 581		// Mapping (31;81) to 581 for forbidden
LAYER NOTUSEM1   621                       
LAYER MAP 31 DATATYPE >=161 <=165 621	// TSMC internal mask making layer (31;161-165)
LAYER DM1EXCL  371
LAYER MAP 150 DATATYPE 1 371
LAYER M1_LVi      901			// Metal1 LV Marker Layer
LAYER MAP 31 DATATYPE >= 200 < 215 901	// Mapping (31;200~214) to 901 for M1 LV Marker Layer
LAYER M1_MVi      921			// Metal1 MV Marker Layer
LAYER MAP 31 DATATYPE >= 215 < 218 921	// Mapping (31;215~217) to 921 for M1 MV Marker Layer
LAYER M1_HVi      961			// Metal1 HV Marker Layer
LAYER MAP 31 DATATYPE >= 218 <= 220 961	// Mapping (31;218~220) to 961 for M1 HV Marker Layer
LAYER M1_HV_5Vi   981		 // Metal1 HV_5V Marker Layer
LAYER MAP 31 DATATYPE 221 981 // Mapping (31;221) to 981 for M1 HV_5V Marker Layer


LAYER M2i         502			// Metal2 layer
LAYER MAP 32 DATATYPE 0  502		// Mapping (32;0) to 502 for M2i
LAYER MAP 32 DATATYPE 7  502		// Mapping (DM2_O, 32;7) to 502 for M2i, OPC dummy metal
LAYER DM2_O       782 
LAYER MAP 32 DATATYPE 7  782		// Mapping (DM2_O, 32;7) to 782 for DM2_O, OPC dummy metal
LAYER M2i_R       762			// Metal2 layer for real metal
LAYER MAP 32 DATATYPE 0  762	// Mapping (32;0) to 762 for M2i_R, real metal
LAYER DUM2        542			// dummy Metal2
LAYER MAP 32 DATATYPE 1  542		// Mapping (32;1) to 542 for DUM2
LAYER NOUSEM2     582                 
LAYER MAP 32 DATATYPE 20 582		// Mapping (32;20) to 582 for forbidden
LAYER MAP 32 DATATYPE 21 582		// Mapping (32;21) to 582 for forbidden
LAYER MAP 32 DATATYPE 40 582		// Mapping (32;40) to 582 for forbidden
LAYER MAP 32 DATATYPE 41 582		// Mapping (32;41) to 582 for forbidden
LAYER MAP 32 DATATYPE 60 582		// Mapping (32;60) to 582 for forbidden
LAYER MAP 32 DATATYPE 61 582		// Mapping (32;61) to 582 for forbidden
LAYER MAP 32 DATATYPE 80 582		// Mapping (32;80) to 582 for forbidden
LAYER MAP 32 DATATYPE 81 582		// Mapping (32;81) to 582 for forbidden
LAYER NOTUSEM2   622                       
LAYER MAP 32 DATATYPE >=161 <=165 622	// TSMC internal mask making layer (32;161-165)
LAYER DM2EXCL  372
LAYER MAP 150 DATATYPE 2 372
LAYER M2_LVi      902			// Metal2 LV Marker Layer
LAYER MAP 32 DATATYPE >= 200 < 215 902	// Mapping (32;200~214) to 902 for M2 LV Marker Layer
LAYER M2_MVi      922			// Metal2 MV Marker Layer
LAYER MAP 32 DATATYPE >= 215 < 218 922	// Mapping (32;215~217) to 922 for M2 MV Marker Layer
LAYER M2_HVi      962			// Metal2 HV Marker Layer
LAYER MAP 32 DATATYPE >= 218 <= 220 962	// Mapping (32;218~220) to 962 for M2 HV Marker Layer
LAYER M2_HV_5Vi   982		 // Metal2 HV_5V Marker Layer
LAYER MAP 32 DATATYPE 221 982 // Mapping (32;221) to 982 for M2 HV_5V Marker Layer


LAYER M3i         503			// Metal3 layer
LAYER MAP 33 DATATYPE 0  503		// Mapping (33;0) to 503 for M3i
LAYER MAP 33 DATATYPE 7  503		// Mapping (DM3_O, 33;7) to 503 for M3i, OPC dummy metal
LAYER DM3_O       783 
LAYER MAP 33 DATATYPE 7  783		// Mapping (DM3_O, 33;7) to 783 for DM3_O, OPC dummy metal
LAYER M3i_R       763			// Metal3 layer for real metal
LAYER MAP 33 DATATYPE 0  763	// Mapping (33;0) to 763 for M3i_R, real metal
LAYER DUM3        543			// dummy Metal3
LAYER MAP 33 DATATYPE 1  543		// Mapping (33;1) to 543 for DUM3
LAYER NOUSEM3     583                 
LAYER MAP 33 DATATYPE 20 583		// Mapping (33;20) to 583 for forbidden
LAYER MAP 33 DATATYPE 21 583		// Mapping (33;21) to 583 for forbidden
LAYER MAP 33 DATATYPE 40 583		// Mapping (33;40) to 583 for forbidden
LAYER MAP 33 DATATYPE 41 583		// Mapping (33;41) to 583 for forbidden
LAYER MAP 33 DATATYPE 60 583		// Mapping (33;60) to 583 for forbidden
LAYER MAP 33 DATATYPE 61 583		// Mapping (33;61) to 583 for forbidden
LAYER MAP 33 DATATYPE 80 583		// Mapping (33;80) to 583 for forbidden
LAYER MAP 33 DATATYPE 81 583		// Mapping (33;81) to 583 for forbidden
LAYER NOTUSEM3   623                       
LAYER MAP 33 DATATYPE >=161 <=165 623	// TSMC internal mask making layer (33;161-165)
LAYER DM3EXCL  373
LAYER MAP 150 DATATYPE 3 373
LAYER M3_LVi      903			// Metal3 LV Marker Layer
LAYER MAP 33 DATATYPE >= 200 < 215 903	// Mapping (33;200~214) to 903 for M3 LV Marker Layer
LAYER M3_MVi      923			// Metal3 MV Marker Layer
LAYER MAP 33 DATATYPE >= 215 < 218 923	// Mapping (33;215~217) to 923 for M3 MV Marker Layer
LAYER M3_HVi      963			// Metal3 HV Marker Layer
LAYER MAP 33 DATATYPE >= 218 <= 220 963	// Mapping (33;218~220) to 963 for M3 HV Marker Layer
LAYER M3_HV_5Vi   983		 // Metal3 HV_5V Marker Layer
LAYER MAP 33 DATATYPE 221 983 // Mapping (33;221) to 983 for M3 HV_5V Marker Layer


LAYER M4i         504			// Metal4 layer
LAYER MAP 34 DATATYPE 0  504		// Mapping (34;0) to 504 for M4i
LAYER MAP 34 DATATYPE 7  504		// Mapping (DM4_O, 34;7) to 504 for M4i, OPC dummy metal
LAYER DM4_O       784 
LAYER MAP 34 DATATYPE 7  784		// Mapping (DM4_O, 34;7) to 784 for DM4_O, OPC dummy metal
LAYER M4i_R       764			// Metal4 layer for real metal
LAYER MAP 34 DATATYPE 0  764	// Mapping (34;0) to 764 for M4i_R, real metal
LAYER DUM4        544			// dummy Metal4
LAYER MAP 34 DATATYPE 1  544		// Mapping (34;1) to 544 for DUM4
LAYER NOUSEM4     584                 
LAYER MAP 34 DATATYPE 20 584		// Mapping (34;20) to 584 for forbidden
LAYER MAP 34 DATATYPE 21 584		// Mapping (34;21) to 584 for forbidden
LAYER MAP 34 DATATYPE 40 584		// Mapping (34;40) to 584 for forbidden
LAYER MAP 34 DATATYPE 41 584		// Mapping (34;41) to 584 for forbidden
LAYER MAP 34 DATATYPE 60 584		// Mapping (34;60) to 584 for forbidden
LAYER MAP 34 DATATYPE 61 584		// Mapping (34;61) to 584 for forbidden
LAYER MAP 34 DATATYPE 80 584		// Mapping (34;80) to 584 for forbidden
LAYER MAP 34 DATATYPE 81 584		// Mapping (34;81) to 584 for forbidden
LAYER NOTUSEM4   624                       
LAYER MAP 34 DATATYPE >=161 <=165 624	// TSMC internal mask making layer (34;161-165)
LAYER DM4EXCL  374
LAYER MAP 150 DATATYPE 4 374
LAYER M4_LVi      904			// Metal4 LV Marker Layer
LAYER MAP 34 DATATYPE >= 200 < 215 904	// Mapping (34;200~214) to 904 for M4 LV Marker Layer
LAYER M4_MVi      924			// Metal4 MV Marker Layer
LAYER MAP 34 DATATYPE >= 215 < 218 924	// Mapping (34;215~217) to 924 for M4 MV Marker Layer
LAYER M4_HVi      964			// Metal4 HV Marker Layer
LAYER MAP 34 DATATYPE >= 218 <= 220 964	// Mapping (34;218~220) to 964 for M4 HV Marker Layer
LAYER M4_HV_5Vi   984		 // Metal4 HV_5V Marker Layer
LAYER MAP 34 DATATYPE 221 984 // Mapping (34;221) to 984 for M4 HV_5V Marker Layer


LAYER M5i         505			// Metal5 layer
LAYER MAP 35 DATATYPE 0  505		// Mapping (35;0) to 505 for M5i
LAYER MAP 35 DATATYPE 7  505		// Mapping (DM5_O, 35;7) to 505 for M5i, OPC dummy metal
LAYER DM5_O       785 
LAYER MAP 35 DATATYPE 7  785		// Mapping (DM5_O, 35;7) to 785 for DM5_O, OPC dummy metal
LAYER M5i_R       765			// Metal5 layer for real metal
LAYER MAP 35 DATATYPE 0  765	// Mapping (35;0) to 765 for M5i_R, real metal
LAYER DUM5        545			// dummy Metal5
LAYER MAP 35 DATATYPE 1  545		// Mapping (35;1) to 545 for DUM5
LAYER NOUSEM5     585                 
LAYER MAP 35 DATATYPE 20 585		// Mapping (35;20) to 585 for forbidden
LAYER MAP 35 DATATYPE 21 585		// Mapping (35;21) to 585 for forbidden
LAYER MAP 35 DATATYPE 40 585		// Mapping (35;40) to 585 for forbidden
LAYER MAP 35 DATATYPE 41 585		// Mapping (35;41) to 585 for forbidden
LAYER MAP 35 DATATYPE 60 585		// Mapping (35;60) to 585 for forbidden
LAYER MAP 35 DATATYPE 61 585		// Mapping (35;61) to 585 for forbidden
LAYER MAP 35 DATATYPE 80 585		// Mapping (35;80) to 585 for forbidden
LAYER MAP 35 DATATYPE 81 585		// Mapping (35;81) to 585 for forbidden
LAYER NOTUSEM5   625                       
LAYER MAP 35 DATATYPE >=161 <=165 625	// TSMC internal mask making layer (35;161-165)
LAYER DM5EXCL  375
LAYER MAP 150 DATATYPE 5 375
LAYER M5_LVi      905			// Metal5 LV Marker Layer
LAYER MAP 35 DATATYPE >= 200 < 215 905	// Mapping (35;200~214) to 905 for M5 LV Marker Layer
LAYER M5_MVi      925			// Metal5 MV Marker Layer
LAYER MAP 35 DATATYPE >= 215 < 218 925	// Mapping (35;215~217) to 925 for M5 MV Marker Layer
LAYER M5_HVi      965			// Metal5 HV Marker Layer
LAYER MAP 35 DATATYPE >= 218 <= 220 965	// Mapping (35;218~220) to 965 for M5 HV Marker Layer
LAYER M5_HV_5Vi   985		 // Metal5 HV_5V Marker Layer
LAYER MAP 35 DATATYPE 221 985 // Mapping (35;221) to 985 for M5 HV_5V Marker Layer


LAYER M6_OLD      506			// Metal6 layer
LAYER MAP 36 DATATYPE 0  506		// Mapping (36;0) to 506 for M6i
LAYER M6_NEW      526			// Metal6 layer
LAYER MAP 36 DATATYPE 40 526		// Mapping (36;40) to 526 for M6i
#IFDEF MIXED_SCHEME
M6i = M6_OLD OR M6_NEW
#ELSE
M6i = COPY M6_NEW
#ENDIF
LAYER DUM6_OLD    546         
LAYER MAP 36 DATATYPE 1  546
LAYER DUM6_NEW    566
LAYER MAP 36 DATATYPE 41 566
#IFDEF MIXED_SCHEME
DUM6 = DUM6_OLD OR DUM6_NEW
#ELSE
DUM6 = COPY DUM6_NEW
#ENDIF
LAYER NOUSEM6_NEW 586
LAYER MAP 36 DATATYPE 0  586
LAYER MAP 36 DATATYPE 1  586
LAYER NOUSEM6_OLD 606
LAYER MAP 36 DATATYPE 7  606
LAYER MAP 36 DATATYPE 20 606
LAYER MAP 36 DATATYPE 21 606
LAYER MAP 36 DATATYPE 60 606
LAYER MAP 36 DATATYPE 61 606
LAYER MAP 36 DATATYPE 80 606
LAYER MAP 36 DATATYPE 81 606
#IFDEF MIXED_SCHEME
NOUSEM6 = COPY NOUSEM6_OLD
#ELSE
NOUSEM6 = NOUSEM6_NEW OR NOUSEM6_OLD
#ENDIF
LAYER NOTUSEM6   626                       
LAYER MAP 36 DATATYPE >=161 <=165 626	// TSMC internal mask making layer (36;161-165)
LAYER DM6EXCL  376
LAYER MAP 150 DATATYPE 6 376
LAYER M6_LVi      906			// Metal6 LV Marker Layer
LAYER MAP 36 DATATYPE >= 200 < 215 906	// Mapping (36;200~214) to 906 for M6 LV Marker Layer
LAYER M6_MVi      926			// Metal6 MV Marker Layer
LAYER MAP 36 DATATYPE >= 215 < 218 926	// Mapping (36;215~217) to 926 for M6 MV Marker Layer
LAYER M6_HVi      966			// Metal6 HV Marker Layer
LAYER MAP 36 DATATYPE >= 218 <= 220 966	// Mapping (36;218~220) to 966 for M6 HV Marker Layer
LAYER M6_HV_5Vi   986		 // Metal6 HV_5V Marker Layer
LAYER MAP 36 DATATYPE 221 986 // Mapping (36;221) to 986 for M6 HV_5V Marker Layer

LAYER VIA1i      801
LAYER MAP 51 DATATYPE 0  801
LAYER DVIA1      401
LAYER MAP 51 DATATYPE 1  401
LAYER NOUSEV1    841  
LAYER MAP 51 DATATYPE 20 841    // Mapping (51;20) to 841 for forbidden
LAYER MAP 51 DATATYPE 40 841    // Mapping (51;40) to 841 for forbidden
LAYER MAP 51 DATATYPE 80 841    // Mapping (51;80) to 841 for forbidden

LAYER VIA2i      802
LAYER MAP 52 DATATYPE 0  802
LAYER DVIA2      402
LAYER MAP 52 DATATYPE 1  402
LAYER NOUSEV2    842  
LAYER MAP 52 DATATYPE 20 842    // Mapping (52;20) to 842 for forbidden
LAYER MAP 52 DATATYPE 40 842    // Mapping (52;40) to 842 for forbidden
LAYER MAP 52 DATATYPE 80 842    // Mapping (52;80) to 842 for forbidden

LAYER VIA3i      803
LAYER MAP 53 DATATYPE 0  803
LAYER DVIA3      403
LAYER MAP 53 DATATYPE 1  403
LAYER NOUSEV3    843  
LAYER MAP 53 DATATYPE 20 843    // Mapping (53;20) to 843 for forbidden
LAYER MAP 53 DATATYPE 40 843    // Mapping (53;40) to 843 for forbidden
LAYER MAP 53 DATATYPE 80 843    // Mapping (53;80) to 843 for forbidden

LAYER VIA4i      804
LAYER MAP 54 DATATYPE 0  804
LAYER DVIA4      404
LAYER MAP 54 DATATYPE 1  404
LAYER NOUSEV4    844  
LAYER MAP 54 DATATYPE 20 844    // Mapping (54;20) to 844 for forbidden
LAYER MAP 54 DATATYPE 40 844    // Mapping (54;40) to 844 for forbidden
LAYER MAP 54 DATATYPE 80 844    // Mapping (54;80) to 844 for forbidden

LAYER VIA5_OLD      805               
LAYER MAP 55 DATATYPE 0 805
LAYER VIA5_NEW      825
LAYER MAP 55 DATATYPE 40  825
#IFDEF MIXED_SCHEME
VIA5i = VIA5_OLD OR VIA5_NEW
#ELSE
VIA5i = COPY VIA5_NEW
#ENDIF
LAYER NOUSEV5_NEW    845
LAYER MAP 55 DATATYPE 0 845
LAYER NOUSEV5_OLD    865
LAYER MAP 55 DATATYPE 20 865
LAYER MAP 55 DATATYPE 80 865
LAYER MAP 55 DATATYPE 1  865
#IFDEF MIXED_SCHEME
NOUSEV5 = COPY NOUSEV5_OLD
#ELSE
NOUSEV5 = NOUSEV5_NEW OR NOUSEV5_OLD
#ENDIF




LAYER METAL_ABOVE_TOP 37
LAYER VIA_ABOVE_TOP 56


LAYER M1_PIN     1301
LAYER MAP 131 DATATYPE 0 1301 
LAYER M1_PIN_TEXT   11301
LAYER MAP 131 TEXTTYPE 0 11301
LAYER M2_PIN     1302
LAYER MAP 132 DATATYPE 0 1302 
LAYER M2_PIN_TEXT   11302
LAYER MAP 132 TEXTTYPE 0 11302
LAYER M3_PIN     1303
LAYER MAP 133 DATATYPE 0 1303 
LAYER M3_PIN_TEXT   11303
LAYER MAP 133 TEXTTYPE 0 11303
LAYER M4_PIN     1304
LAYER MAP 134 DATATYPE 0 1304 
LAYER M4_PIN_TEXT   11304
LAYER MAP 134 TEXTTYPE 0 11304
LAYER M5_PIN     1305
LAYER MAP 135 DATATYPE 0 1305 
LAYER M5_PIN_TEXT   11305
LAYER MAP 135 TEXTTYPE 0 11305
LAYER M6_PIN     1306
LAYER MAP 136 DATATYPE 0 1306 
LAYER M6_PIN_TEXT   11306
LAYER MAP 136 TEXTTYPE 0 11306
LAYER AP_PIN 1260
LAYER MAP 126 DATATYPE 0 1260
LAYER AP_PIN_TEXT 11260
LAYER MAP 126 TEXTTYPE 0 11260

LAYER ODi 350 7 8
LAYER MAP 6 DATATYPE 0           350
LAYER MAP 6 DATATYPE 2           350
LAYER MAP 6 DATATYPE >=4   <=6   350
LAYER MAP 6 DATATYPE >=8   <=160 350
LAYER MAP 6 DATATYPE >=166 <=255 350
LAYER ODiRFDRAIN 351 
LAYER MAP 6 DATATYPE 3 351  // for mixed-mode process to recognize RF MOS region
LAYER ODiSRAM    352 
LAYER MAP 6 DATATYPE 11 352 // for SRAM only
LAYER MAP 6 DATATYPE 12 352 // for SRAM only
LAYER MAP 6 DATATYPE 13 352 // for SRAM only
LAYER ODiOTHERS  353 7 8
LAYER MAP 6 DATATYPE 2           353
LAYER MAP 6 DATATYPE >=4 <=6     353
LAYER MAP 6 DATATYPE >=8 <=160   353
LAYER MAP 6 DATATYPE >=166 <=255 353
LAYER DOD 354
LAYER MAP 6 DATATYPE 1 354  // Mapping (6;1) to 354 for dummy OD
LAYER SRDOD     357
LAYER MAP 6 DATATYPE 7 357  // Mapping (6;7) to 357 for SR_DOD
LAYER NOTUSEOD 355
LAYER MAP 6 DATATYPE >=161 <=165 355  // TSMC internal mask making layer (6;161-165)

LAYER POi 364
LAYER MAP 17 DATATYPE 0           364
LAYER MAP 17 DATATYPE >=2   <=6   364
LAYER MAP 17 DATATYPE >=8   <=16  364
LAYER MAP 17 DATATYPE >=18  <=50  364
LAYER MAP 17 DATATYPE >=52  <=160 364
LAYER MAP 17 DATATYPE >=166 <=255 364
LAYER POiSRAM 365            
LAYER MAP 17 DATATYPE 11 365 // for SRAM only
LAYER MAP 17 DATATYPE 12 365 // for SRAM only 
LAYER MAP 17 DATATYPE 13 365 // for SRAM only
LAYER POiOTHERS 366
LAYER MAP 17 DATATYPE >=2   <=6   366
LAYER MAP 17 DATATYPE >=8   <=16  366
LAYER MAP 17 DATATYPE >=18  <=50  366
LAYER MAP 17 DATATYPE >=52  <=160 366
LAYER MAP 17 DATATYPE >=166 <=255 366
LAYER DPO        361
LAYER MAP 17 DATATYPE 1 361  // Mapping (17;1) to 361 for dummy PO
LAYER SRDPO     367
LAYER MAP 17 DATATYPE 7 367  // Mapping (17;7) to 367 for SR_DPO
LAYER mVTLi      362         // Used to generate poly logical operation in LVT process
LAYER MAP 17 DATATYPE 51 362 // Mapping (17;51, layer PO, purpose rule1) to 362 for mVTLi
LAYER NOTUSEPO   363
LAYER MAP 17 DATATYPE >=161 <=165 363   // TSMC internal mask making layer (17;161-165)
LAYER CPO        368
LAYER MAP 17 DATATYPE 17    368

LAYER ODBLK      392
LAYER MAP 150 DATATYPE 20 392
LAYER POBLK      393
LAYER MAP 150 DATATYPE 21 393

LAYER RRuleRequired      1821	// marker layer for action-required DFM rules
LAYER MAP 182 DATATYPE 1 1821
LAYER RRuleRecommended   1822	// marker layer for recommended DFM rule
LAYER MAP 182 DATATYPE 2 1822
LAYER RRuleAnalog        1823	// marker layer for analog rules and recommendations
LAYER MAP 182 DATATYPE 3 1823
LAYER RRuleGuideline     1824	// marker layer for DFM guidelines
LAYER MAP 182 DATATYPE 4 1824
LAYER excludeRRuleRequired    1831  // marker layer for excluding DFM action-required rules
LAYER MAP 182 DATATYPE 11     1831
LAYER excludeRRuleRecommended 1832  // marker layer for excluding DFM recommendations
LAYER MAP 182 DATATYPE 12     1832
LAYER excludeRRuleAnalog      1833  // marker layer for excluding analog rules and recommendations
LAYER MAP 182 DATATYPE 13     1833
LAYER excludeRRuleGuideline   1834  // marker layer for excluding DFM guidelines
LAYER MAP 182 DATATYPE 14     1834

LAYER BJT4TDMY   8107  // BJT dummy layer for DRC
LAYER MAP 110 DATATYPE 2 8107
LAYER BJTDMY   1100  // BJT dummy layer for DRC
LAYER MAP 110 DATATYPE 0 1100
LAYER BJTDMY1  1101  // BJT dummy layer for DRC
LAYER MAP 110 DATATYPE 1 1101
LAYER BJT7TDMY   1103  // Cover 7-terminal BJT device
LAYER MAP 110 DATATYPE 3 1103
LAYER BJTMDDMY   1104  // Dummy layer for multiple-BJT layer
LAYER MAP 110 DATATYPE 4 1104
LAYER BJTSNDMY   1105  // Dummy layer for separate node in multiple-BJT
LAYER MAP 110 DATATYPE 5 1105
LAYER BJT7TDMY_19   1106  // Dummy layer for multiple -BJT device  in 1X9 array
LAYER MAP 110 DATATYPE 6 1106
LAYER BJT7TDMY_33   1107  // Dummy layer for multiple -BJT device  in 3X3 array
LAYER MAP 110 DATATYPE 7 1107
LAYER BJT5TDMY   1108  // BJT dummy layer for DRC
LAYER MAP 110 DATATYPE 8 1108
BJTTDMY_DRC = BJT4TDMY or BJT7TDMY


LAYER VDDDMY 2554             // Dummy layer for Pewer(VDD) pad
LAYER MAP 255 DATATYPE 4 2554
LAYER VSSDMY 2555             // Dummy layer for Ground(VSS) pad
LAYER MAP 255 DATATYPE 5 2555
LAYER SENDMY 2558             // Dummy layer to define the sensitive devices for local OD/PO density check
LAYER MAP 255 DATATYPE 8 2558
LAYER RES200 2559             // Recognize resistor over 200ohm for ESD/LUP check
LAYER MAP 255 DATATYPE 9 2559
LAYER LOWMEDN 2560            // Dummy layer for low metal density region
LAYER MAP 255 DATATYPE 15 2560
LAYER MATCHING_HV  25525  // To define sensitive HVMOS with matching requirement
LAYER MAP 255 DATATYPE 25 25525
LAYER MATCHING     25526  // Define MATCHING dummy layer for cover the diffential pair region
LAYER MAP 255 DATATYPE 26 25526
MATCHINGi = MATCHING NOT SRAM_EXCLUDE
LAYER MATCHING_S   25528  // To recognize source and gate region
LAYER MAP 255 DATATYPE 28 25528
LAYER RES50  25545            // Recognize resistor over 50ohm for ESD/LUP check
LAYER MAP 255 DATATYPE 45 25545
LAYER POS1        2541          // GATE CD size-up 1nm/side
LAYER MAP 254 DATATYPE 1 2541
LAYER POS2        2542          // GATE CD size-up 2nm/side
LAYER MAP 254 DATATYPE 2 2542
LAYER POS_OTHERS  2543
LAYER MAP 254 DATATYPE >=3 <=255 2543

LAYER prBoundary 108  // For using layer prBoundary(108) as the boundary








LAYER RMDMY1     1161 // Metal1 resistor dummy layer
LAYER MAP 116 DATATYPE 1 1161
LAYER RMDMY2     1162 // Metal2 resistor dummy layer
LAYER MAP 116 DATATYPE 2 1162
LAYER RMDMY3     1163 // Metal3 resistor dummy layer
LAYER MAP 116 DATATYPE 3 1163
LAYER RMDMY4     1164 // Metal4 resistor dummy layer
LAYER MAP 116 DATATYPE 4 1164
LAYER RMDMY5     1165 // Metal5 resistor dummy layer
LAYER MAP 116 DATATYPE 5 1165
LAYER RMDMY6     1166 // Metal6 resistor dummy layer
LAYER MAP 116 DATATYPE 6 1166
LAYER RMDMYAP    11616  // AP Metal resistor dummy layer
LAYER MAP 116 DATATYPE 16 11616




LAYOUT BASE LAYER ODi POi COi



// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------
#IFDEF ChipWindowUsed
LAYER ChipWindow 500 // layer number for constructing chip boundary
POLYGON xLB yLB xRT yRT ChipWindow
CHIP       = PUSH ChipWindow
#ELSE
 CHIP  = EXTENT ( EXTENT DRAWN DNWi NWi OD12i OD18i OD25i OD25_LK OD33i ODDECAP PPi NPi HVD_N HVD_P DEHVD_N CBi CB2Fi CB2Wi RPOi NTNi LPP_NTNi LPP_NTN_21i LPP_NTN_DPOi LPP_NTN_120i POFUSE FUSELINK PMi PM1i PM2i VTHNi VTHPi VTLNi VTLPi VTULNi VTULPi ULVT_Ni ULVT_Pi VTLN18 CBDi CBDB UBMi UBMB RH RHDMY1 ESDIMP VARi DVAR APi Cu_PPIi DMY_S_Pad DMY_U_Pad AP_BSL AP_BSP CBMi CTMi RVi RV_BSL DCOi DCO_LPPi DCODMY_SCi LMARK SRM SRMN SRMP SRMRP NPreDOSRM ROM SRM_HS SRAMDMY SRAMDMY_PAS SRAMDMY_PERI_LP SRAMDMY_PERI_G CO2 DPSRM PRSRM SRMLOP12 SRMLOP13 SRMLOP14 LVLOP HCDPLOP TPLOP_8T TPLOP_10T RAM1TDMY OD1T OD1TH OD1TM OD1T_WLD OD1T_MOSCAP OD1T_CP OD1T_20 OD1T_18 OD1T_16 CLDD EDRAM_DECAP SNCT CROWN P3 ICOVL TLDMY DIO3TDMYi RODMY M1i DM1_O DUM1 M2i DM2_O DUM2 M3i DM3_O DUM3 M4i DM4_O DUM4 M5i DM5_O DUM5 M6_OLD M6_NEW DUM6_OLD DUM6_NEW DVIA1 DVIA2 DVIA3 DVIA4 ODi ODiSRAM DOD SRDOD POi POiSRAM DPO SRDPO mVTLi CPO BJT4TDMY BJTDMY BJTDMY1 BJT7TDMY BJTMDDMY BJTSNDMY BJT7TDMY_19 BJT7TDMY_33 BJT5TDMY MATCHING_HV MATCHING MATCHING_S RES50 POS1 POS2 POS_OTHERS RMDMY1 RMDMY2 RMDMY3 RMDMY4 RMDMY5 RMDMY6 RMDMYAP )
//CHIP       = EXTENT 
//CHIP       = EXTENT CELL "*" ORIGINAL 
#ENDIF

CHIPx        = MERGE CHIP
BULK         = SIZE CHIP BY 1.0
PWELi        = BULK NOT NWi


EMPTYi       = CHIP NOT BULK // for DRC coding
EMPTYu       = SIZE EMPTYi BY 1.0 // for DRC coding


#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING
#IFDEF OLD_SEALRING
SR_EDGE = CHIP NOT (SIZE CHIP BY -16)
SR_EXC  = EXT SR_EDGE < 73.715 ABUT == 90 REGION INTERSECTING ONLY 
SRCSR   = SR_EDGE OR SR_EXC   // Sealring + CSR Corner + Assembly isolation
#ELSE
SRCSR   = COPY SEALRING_ALL   // Sealring + SRDB + CSR Corner + Assembly isolation
#ENDIF
EMPTY_AREA = COPY EMPTYi
CHIP_EDGE_a = CHIP NOT SRCSR
ISO_REGION = (SIZE CHIP_EDGE_a BY SR_S_1) NOT CHIP_EDGE_a
CHIP_EDGE  = EXTENT CHIP_EDGE_a
#ELSE
SRCSR = COPY EMPTYi
EMPTY_AREA = INT CHIP < CSR_R_1 ABUT == 90 REGION INTERSECTING ONLY
CHIP_EDGE_a = CHIP NOT EMPTY_AREA
CHIP_EDGE = COPY CHIP
#ENDIF
#ELSE
EMPTY_AREA = COPY EMPTYi
SRCSR = COPY EMPTYi
#ENDIF

SEALRING_EXCLUDE = (SRCSR OR SEALRING_ALL) OR SEALRING_ORI

SRAM_EXCLUDE = COPY EMPTYi
SRAM_REGION  = SRAMDMY NOT RAM1TDMY // new SRAM exclude layer

ALL_OD = (ODi OR SRDOD) OR DOD
ALL_POLY = (POi OR SRDPO) OR DPO


M1x = M1i OR DUM1 
M2x = M2i OR DUM2 
M3x = M3i OR DUM3 
M4x = M4i OR DUM4 
M5x = M5i OR DUM5 
M6x = M6i OR DUM6 

// EXCLUDE UNCHECKED REGIONS
//--------------------------
PWEL    = PWELi   NOT SRAM_EXCLUDE
DNW     = DNWi    NOT INSIDE SRAM_EXCLUDE
NWEL    = NWi     NOT INSIDE SRAM_EXCLUDE
OD      = ODi     NOT SRAM_EXCLUDE
ODs     = ODi     NOT INSIDE SRAM_EXCLUDE
OD12    = OD12i   NOT SRAM_EXCLUDE
OD12s   = OD12i   NOT INSIDE SRAM_EXCLUDE
OD18    = OD18i   NOT SRAM_EXCLUDE
OD25    = OD25i   NOT SRAM_EXCLUDE
OD33    = OD33i   NOT SRAM_EXCLUDE
POLY    = POi     NOT SRAM_EXCLUDE
POLYs   = POi     NOT INSIDE SRAM_EXCLUDE
PP      = PPi     NOT INSIDE SRAM_EXCLUDE
NP      = NPi     NOT INSIDE SRAM_EXCLUDE
VTHN    = VTHNi   NOT SRAM_EXCLUDE
VTHNs   = VTHNi   NOT INSIDE SRAM_EXCLUDE
VTHP    = VTHPi   NOT SRAM_EXCLUDE
VTHPs   = VTHPi   NOT INSIDE SRAM_EXCLUDE
VTLN    = VTLNi   NOT SRAM_EXCLUDE
VTLNs   = VTLNi   NOT INSIDE SRAM_EXCLUDE
VTLP    = VTLPi   NOT SRAM_EXCLUDE
VTLPs   = VTLPi   NOT INSIDE SRAM_EXCLUDE
RPO     = RPOi    NOT SRAM_EXCLUDE
RPOs    = RPOi    NOT INSIDE SRAM_EXCLUDE
NTN     = NTNi    NOT SRAM_EXCLUDE
NTNs    = NTNi    NOT INSIDE SRAM_EXCLUDE
NCapNTN = NCapNTNi NOT SRAM_EXCLUDE  
CO      = COi     NOT SRAM_EXCLUDE
COs     = COi     NOT INSIDE SRAM_EXCLUDE
M1      = M1i     NOT SRAM_EXCLUDE
M1s     = M1i     NOT INSIDE SRAM_EXCLUDE
VIA1    = VIA1i   NOT SRAM_EXCLUDE
VIA1s   = VIA1i   NOT INSIDE SRAM_EXCLUDE
DCO     = DCOi    NOT SRAM_EXCLUDE
DCOs    = DCOi    NOT INSIDE SRAM_EXCLUDE
DCO_LPP     = DCO_LPPi NOT SRAM_EXCLUDE
DCO_LPPs    = DCO_LPPi NOT INSIDE SRAM_EXCLUDE
DCODMY_SC = DCODMY_SCi NOT SRAM_EXCLUDE
ULVT_N = ULVT_Ni NOT SRAM_EXCLUDE
ULVT_Ns = ULVT_Ni NOT INSIDE SRAM_EXCLUDE
ULVT_P = ULVT_Pi NOT SRAM_EXCLUDE
ULVT_Ps = ULVT_Pi NOT INSIDE SRAM_EXCLUDE

M2      = COPY M2i 
VIA2    = COPY VIA2i
M3      = COPY M3i 
VIA3    = COPY VIA3i
M4      = COPY M4i 
VIA4    = COPY VIA4i
M5      = COPY M5i 
VIA5    = COPY VIA5i
M6      = COPY M6i 

RV      = COPY RVi
AP      = COPY APi
CB      = COPY CBi  
PM      = COPY PMi  
CBM     = COPY CBMi
CTM     = COPY CTMi
VAR	= COPY VARi
mVTL    = COPY mVTLi


UBM_MT = UBMi INTERACT CBDi
#IFDEF WLCSP
UBM_EXC = SIZE CBDi BY 5 INSIDE OF M6i STEP M6_S_1*0.7
#ELSE
UBM_EXC = SIZE UBM_MT BY 5 INSIDE OF M6i STEP M6_S_1*0.7
#ENDIF

CBx  = CBi NOT INTERACT SEALRING_EXCLUDE
CB2x = CB2Wi NOT INTERACT SEALRING_EXCLUDE

CB_OPEN_EDGE = CONVEX EDGE CBx ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH == 3
CB_OPENING_REGION = (EXPAND EDGE CB_OPEN_EDGE OUTSIDE BY 3) NOT CBx
CB_RING = (CBx NOT (CBx WITH WIDTH > 5)) OR CB_OPENING_REGION
CB_HOLE_insideRING = HOLES CB_RING
CB_PAD_RAP = CB_RING OR (CB_HOLE_insideRING INTERACT CB_RING)
notch_CB = EXT CBx <5 NOTCH OPPOSITE REGION
CB_PAD_NON_RAP = CBx WITH WIDTH > 5
CB_PAD = CB_PAD_RAP OR CB_PAD_NON_RAP

CB_MT  = SIZE CB_PAD BY 5 INSIDE OF M6i STEP M6_S_1*0.7
CB_MT2 = SIZE CB_PAD BY 5 INSIDE OF M5i STEP M5_S_1*0.7

MTOP_EXC = UBM_EXC OR CB_MT	// For high density and max width rule

CB2 = COPY CB2x

VIA1_HOLE = RECTANGLE VIA1i == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
VIA1_BAR = VIA1i NOT VIA1_HOLE
VIA2_HOLE = RECTANGLE VIA2i == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
VIA2_BAR = VIA2i NOT VIA2_HOLE
VIA3_HOLE = RECTANGLE VIA3i == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
VIA3_BAR = VIA3i NOT VIA3_HOLE
VIA4_HOLE = RECTANGLE VIA4i == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
VIA4_BAR = VIA4i NOT VIA4_HOLE
LOWMEDN_CORE1 = SIZE LOWMEDN BY -1
LOWMEDN_CORE2 = SIZE LOWMEDN BY -4
LOWMEDN_CORE3 = SIZE LOWMEDN BY -5
P_RING_REGION1 = LOWMEDN NOT LOWMEDN_CORE1
P_RING_REGION = LOWMEDN NOT LOWMEDN_CORE2
P_RING_REGION2 = LOWMEDN NOT LOWMEDN_CORE3
LOWMEDN_IND = LOWMEDN INTERACT INDDMY
P_RING_VIA1 = P_RING_REGION AND VIA1_BAR
P_RING_VIA1_IND = P_RING_VIA1 INTERACT LOWMEDN_IND
P_RING_VIA1_noIND = P_RING_VIA1 NOT INTERACT LOWMEDN_IND
P_RING_VIA2 = P_RING_REGION AND VIA2_BAR
P_RING_VIA2_IND = P_RING_VIA2 INTERACT LOWMEDN_IND
P_RING_VIA2_noIND = P_RING_VIA2 NOT INTERACT LOWMEDN_IND
P_RING_VIA3 = P_RING_REGION AND VIA3_BAR
P_RING_VIA3_IND = P_RING_VIA3 INTERACT LOWMEDN_IND
P_RING_VIA3_noIND = P_RING_VIA3 NOT INTERACT LOWMEDN_IND
P_RING_VIA4 = P_RING_REGION AND VIA4_BAR
P_RING_VIA4_IND = P_RING_VIA4 INTERACT LOWMEDN_IND
P_RING_VIA4_noIND = P_RING_VIA4 NOT INTERACT LOWMEDN_IND

VIA_EXD = SEALRING_ORI OR SEALRING_DB
VIA1_EXD = (VIA1 NOT VIA_EXD) NOT P_RING_VIA1

VIA2_EXD = (VIA2 NOT VIA_EXD) NOT P_RING_VIA2

VIA3_EXD = (VIA3 NOT VIA_EXD) NOT P_RING_VIA3

VIA4_EXD = (VIA4 NOT VIA_EXD) NOT P_RING_VIA4

VIA5_EXD = VIA5 NOT VIA_EXD


INDDMY_ALL = INDDMY OR INDDMY_MD
IND_REGION = SIZE INDDMY_ALL BY 16
IND_EXD = SIZE INDDMY_ALL BY 22

//Metal Maximum Width Waive
M1_MAX_WIDTH_EXC_a = (SEALRING_ALL OR CSRDMY) OR IND_REGION
M1_MAX_WIDTH_EXC_b = COPY EMPTYi
M1_MAX_WIDTH = M1 NOT (M1_MAX_WIDTH_EXC_a OR M1_MAX_WIDTH_EXC_b)
M2_MAX_WIDTH_EXC_a = (SEALRING_ALL OR CSRDMY) OR IND_REGION
M2_MAX_WIDTH_EXC_b = COPY EMPTYi
M2_MAX_WIDTH = M2 NOT (M2_MAX_WIDTH_EXC_a OR M2_MAX_WIDTH_EXC_b)
M3_MAX_WIDTH_EXC_a = (SEALRING_ALL OR CSRDMY) OR IND_REGION
M3_MAX_WIDTH_EXC_b = COPY EMPTYi
M3_MAX_WIDTH = M3 NOT (M3_MAX_WIDTH_EXC_a OR M3_MAX_WIDTH_EXC_b)
M4_MAX_WIDTH_EXC_a = (SEALRING_ALL OR CSRDMY) OR IND_REGION
M4_MAX_WIDTH_EXC_b = COPY EMPTYi
M4_MAX_WIDTH = M4 NOT (M4_MAX_WIDTH_EXC_a OR M4_MAX_WIDTH_EXC_b)
M5_MAX_WIDTH_EXC_a = (SEALRING_ALL OR CSRDMY) OR IND_REGION
M5_MAX_WIDTH_EXC_b = WBDMY OR CB_MT2
M5_MAX_WIDTH = M5 NOT (M5_MAX_WIDTH_EXC_a OR M5_MAX_WIDTH_EXC_b)
M6_MAX_WIDTH_EXC_a = COPY IND_EXD
M6_MAX_WIDTH_EXC_b = MTOP_EXC OR LMARK 
M6_MAX_WIDTH = M6 NOT (M6_MAX_WIDTH_EXC_a OR M6_MAX_WIDTH_EXC_b)

//Density Waive
#IFDEF FULL_CHIP
DEN_EXC_LOW =  ((LOGO OR INDDMY) OR SEALRING_EXCLUDE) OR EMPTY_AREA    // exclude region for low density
DEN_EXC_HIGH =  SEALRING_EXCLUDE OR INDDMY_ALL 
#ELSE
DEN_EXC_LOW = LOGO OR INDDMY                // exclude region for low density
DEN_EXC_HIGH = CSRDMY OR INDDMY_ALL
#ENDIF
M1_EXC_LOW  = COPY DEN_EXC_LOW
M1_EXC_HIGH = COPY DEN_EXC_HIGH

M2_EXC_LOW  = COPY DEN_EXC_LOW
M2_EXC_HIGH = COPY DEN_EXC_HIGH

M3_EXC_LOW  = COPY DEN_EXC_LOW
M3_EXC_HIGH = COPY DEN_EXC_HIGH

M4_EXC_LOW  = COPY DEN_EXC_LOW
M4_EXC_HIGH = COPY DEN_EXC_HIGH

M5_EXC_LOW  = COPY DEN_EXC_LOW
M5_EXC_HIGH = DEN_EXC_HIGH OR (WBDMY OR CB_MT2) 

M6_EXC_LOW  = DEN_EXC_LOW OR INDDMY_MD
M6_EXC_HIGH = DEN_EXC_HIGH OR MTOP_EXC


NEW_DEN_EXC = EMPTY_AREA OR LOWMEDN


OD2 = (OD18 OR OD25) OR OD33
OD2i = (OD18i OR OD25i) OR OD33i

IMP          = NPi OR PPi
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD        // Diffusion contacts 
SR_COPO      = CO AND SRDPO     // SR_DPO contacts
COPO         = (CO NOT OD) NOT SRDPO // POLY contacts + floating contacts

RNWEL = NWEL INTERACT NWDMY	// NWEL resistor (Within OD & STI)
NWRES = RNWEL INTERACT RPO	// NWEL resistor (Within OD)
NONWR = NWEL NOT RNWEL		// NWEL exclude resistor area (Within OD)
ODWR  = OD INTERACT NWRES	// OD area of NW resistor (Within OD)
NPWR  = NP INTERACT NWRES	// N+ implant on NW resistor terminals (Within OD)
COWR  = COOD INTERACT NWRES	// Contact on NW resistor terminals (Within OD)
RHWR  = ODWR NOT RPO		// Silicided terminal of NW resistor (Within OD)
NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (Under STI)
ODWR_STI = OD INTERACT NWRES_STI	// OD area of NW resistor (Under STI)
NPWR_STI = NP INTERACT NWRES_STI
COWR_STI = COOD INTERACT NWRES_STI	// Contact on NW resistor terminals (Under STI)

NSTP         = NPOD AND NONWR          // NWEL tap diffusion



NACT         = NPOD NOT NWEL           // NMOS device active diffusion
PACT         = PPOD AND NWEL           // PMOS device active diffusion


NACT2        = NACT INTERACT OD2
PACT2        = PACT INTERACT OD2

PSTP         = PPOD NOT NWEL           // Substrate (pwell) tap diffusion

DSTP         = NSTP OR PSTP

DACT         = NACT OR PACT            // NMOS/PMOS device active diffusion
GATE         = POLY AND OD	       // Gate regions for NMOS and PMOS

GATEi        = POi AND ODi	       // Gate regions for NMOS and PMOS
SD           = (DACT ENCLOSE GATE) NOT GATE  // Source, drain areas
FPO1         = POLY NOT OD             // Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2
GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP
GATE_W       = POLY COIN INSIDE EDGE GATE      // Gate width
GATE_Wi      = POi COIN INSIDE EDGE GATEi
GATE_L       = GATE NOT TOUCH EDGE GATE_W
GATE_Li      = GATEi NOT TOUCH EDGE GATE_Wi

GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP
HV_GATE_W    = GATE_W INSIDE EDGE OD2         // 2.5V/1.8V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2
HV_GATE_L    = GATE_L INSIDE EDGE OD2         // 2.5V/1.8V MOS gates
LV_GATE_L    = GATE_L NOT INSIDE EDGE OD2
18V_GATE_W   = HV_GATE_W INSIDE EDGE OD18
25V_GATE_W   = HV_GATE_W INSIDE EDGE OD25
33V_GATE_W   = HV_GATE_W INSIDE EDGE OD33


HVD_NMOS_DRAIN = SD INTERACT HVD_N
HVD_NGATE = HV_GATE INTERACT HVD_N
HVD_PMOS_DRAIN = SD INTERACT HVD_P
HVD_PGATE = HV_GATE INTERACT HVD_P
HVD_GATE  = HVD_NGATE OR HVD_PGATE

SR_POLY      = SRDPO OR POLY
SR_GATE      = SRDPO AND OD
SR_GATE_W    = SRDPO COIN INSIDE EDGE SR_GATE
SR_GATE_L    = SR_GATE NOT TOUCH EDGE SR_GATE_W
SR_HV_GATE   = SR_GATE AND OD2


RPDMYi        = RPDMY NOT INTERACT RPOi	 // silicided od/poly resistor dummy layer
RPO_RPDMY     = RPOi OR RPDMYi           // unsilicided/silicided od/poly resistor
ILP1          = POLY NOT RPO_RPDMY       // interconnect poly
INOD          = OD NOT RPO_RPDMY
FOD           = (OD OUTSIDE NWDMY) NOT GATE



//resistor definition
OD_RES_RPO    = ((RPDMY AND OD) AND RH) AND RPO
OD_RES_noRPO  = ((RH AND OD) NOT INTERACT RPO) AND RPDMY
OD_RES        =  OD_RES_RPO OR OD_RES_noRPO
PO_RES_RPO    = ((RPDMY AND POLY) AND RH) AND RPO
PO_RES_noRPO  = ((RH AND POLY) NOT INTERACT RPO) AND RPDMY
PO_RES        =  PO_RES_RPO OR PO_RES_noRPO
OD_RES_RPO_PP = PP AND OD_RES_RPO
OD_RES_RPO_NP = NP AND OD_RES_RPO 
PO_RES_RPO_PP = PP AND PO_RES_RPO 
PO_RES_RPO_NP = NP AND PO_RES_RPO 
ODPO_RES_RPO_PP = OD_RES_RPO_PP OR PO_RES_RPO_PP 
ODPO_RES_RPO_NP = OD_RES_RPO_NP OR PO_RES_RPO_NP 
ODPO_RES_RPO    = OD_RES_RPO OR PO_RES_RPO 

NW_RES = NWEL AND NWDMY
NW_RES_underOD  = NW_RES AND OD
NW_RES_underSTI = NW_RES NOT OD
NWROD  = NWEL INTERACT NW_RES_underOD
NWRSTI = NWEL INTERACT NW_RES_underSTI
NWROD_or_NWRSTI = NWROD OR NWRSTI

OD_RES_200ohm = OD_RES AND RES200  
PO_RES_200ohm = PO_RES AND RES200
NW_RES_200ohm = NW_RES AND RES200
PO_RES_50ohm = PO_RES AND (RES50 OR RES200)

SEN_GATE = (((GATE INTERACT SENDMY) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)
SEN_GATE_005 = ((((GATE INTERACT SENDMY) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)) WITH EDGE (LENGTH GATE_L <= 0.05)
SEN_PO_RES_RPO = SENDMY AND PO_RES_RPO
    
NP_PP_BTE     = NPOD COIN OUTSIDE EDGE PPOD
BUTT_PSTP     = PSTP TOUCH NACT
BUTT_NSTP     = NSTP TOUCH PACT

// For BJT Device
PP_EMOD = PACT AND BJTDMY
NP_EMOD = NACT AND BJTDMY
EMOD = PP_EMOD OR NP_EMOD



#IFDEF FULL_CHIP
CHIP_M1 = COPY CHIP
CHIP_M2 = COPY CHIP
CHIP_M3 = COPY CHIP
CHIP_M4 = COPY CHIP
CHIP_M5 = COPY CHIP
CHIP_M6 = COPY CHIP
#ELSE
CHIP_M1 = CHIP INTERACT M1x
CHIP_M2 = CHIP INTERACT M2x
CHIP_M3 = CHIP INTERACT M3x
CHIP_M4 = CHIP INTERACT M4x
CHIP_M5 = CHIP INTERACT M5x
CHIP_M6 = CHIP INTERACT M6x
#ENDIF

// DFM
Block = LOGO OR SRCSR 


EMPTYmom = SIZE EMPTYi BY 18   // For MOM.R.6 check
SRDPOi = EMPTYmom OR SRDPO     // For MOM.R.6 check
// Nodal NWEL connectivity checks
ILP1i = POi NOT RPO_RPDMY // Interconnect poly
NONWRi = NWi NOT CUT NWDMY 
NWRiT = (NWi CUT NWDMY) NOT NWDMY // NWR terminal
//RWi   = DNWi NOT NWi
RWi = PWELi INSIDE DNWi
NPODi = NPi AND ODi
PPODi = PPi AND ODi
NACTi = NPODi NOT NWi
PACTi = PPODi AND NWi


NSDi  = NACTi NOT POi		// NMOS source/drain
PSDi  = PACTi NOT POi		// PMOS source/drain
NSDc  = NSDi NOT RPO_RPDMY	// NMOS source/drain for connection
PSDc  = PSDi NOT RPO_RPDMY	// PMOS source/drain for connection
NSTPi = NPODi AND NONWRi        // Break the connection at NWR  


PSTPi = PPODi NOT NWi


BTC = (COi NOT COPUSH) AND SRM
#IFDEF WIRE_BOND
CB1i = COPY CBi
CB2i = COPY CB2Wi
#ELSE
CB1i = COPY CBDi
CB2i = COPY CB2Fi
#ENDIF

//======================================
CONNECT NWEL DNW 	// For DNW.S.2 check only, not for electrical connection.
CONNECT NSTPi NWi
CONNECT NSTPi PSDc	// For butted pickup
CONNECT PSTPi RWi	// For DNW connection
CONNECT PSTPi PWELi     // For DNW connection
CONNECT PSTPi NSDc	// For butted pickup
CONNECT COi PSDc        // For butted CO
CONNECT COi NSDc        // For butted CO
CONNECT COi ILP1i       // For butted CO
CONNECT COi SRDPO       // To fix CO.S.2.1 error
CONNECT M1i SRDPOi BY COi
CONNECT M1i ILP1i NSTPi PSTPi PSDc NSDc NWRiT BY COi
CONNECT M1i M2i BY VIA1i
CONNECT M2i M3i BY VIA2i
CONNECT M3i M4i BY VIA3i
CONNECT M4i M5i BY VIA4i
CONNECT M5i M6i BY VIA5i

CONNECT CB1i M6i
#IFDEF SINGLE_PASSIVATION
CONNECT UBMi M6i BY CB1i
CONNECT UBMi APi BY EMPTYi
#ELSE
#IFDEF WITH_APRDL
CONNECT M6i APi  BY RVi
#ENDIF
CONNECT M6i APi  BY CB1i
CONNECT CB2i APi         
#IFNDEF WLCSP
CONNECT UBMi APi BY CB2i
#ELSE
CONNECT Cu_PPIi APi BY CB2i
CONNECT PM2i Cu_PPIi
CONNECT UBMi PM2i
#ENDIF

#ENDIF




//======================================
NWu   = EMPTYu OR NWi
RWu   = EMPTYu OR RWi
PWELu = EMPTYu OR PWELi
NWRuT = EMPTYu OR NWRiT
POu   = EMPTYu OR POi
NSDu  = EMPTYu OR NSDi
PSDu  = EMPTYu OR PSDi
NSTPu = NPODi AND NWi

PSTPu = EMPTYu OR PSTPi
COu   = EMPTYu OR COi
M1u   = EMPTYu OR M1i
VIA1u = EMPTYu OR VIA1i
M2u   = EMPTYu OR M2i
VIA2u = EMPTYu OR VIA2i
M3u   = EMPTYu OR M3i
VIA3u = EMPTYu OR VIA3i
M4u   = EMPTYu OR M4i
VIA4u = EMPTYu OR VIA4i
M5u   = EMPTYu OR M5i
VIA5u = EMPTYu OR VIA5i
M6u   = EMPTYu OR M6i
RVu   = EMPTYu OR RVi
CB1u  = EMPTYu OR CB1i
CB2u  = EMPTYu OR CB2i
APu   = EMPTYu OR APi
Cu_PPIu = EMPTYu OR Cu_PPIi
PM1u   = EMPTYu OR PM1i
PM2u   = EMPTYu OR PM2i
UBMu  = EMPTYu OR UBMi
CONNECT NSTPu NWu
CONNECT NSTPu PSDu	// For butted pickup
CONNECT PSTPu RWu	// For DNW connection
CONNECT PSTPu PWELu	// For DNW connection
CONNECT PSTPu NSDu	// For butted pickup
CONNECT COu PSDu        // For butted CO
CONNECT COu NSDu        // For butted CO
CONNECT COu POu         // For butted CO
CONNECT M1u POu NSTPu PSTPu PSDu NSDu BY COu

CONNECT M1u NWRuT BY COu // prevent from connection shielding
CONNECT M1u M2u BY VIA1u
CONNECT M2u M3u BY VIA2u
CONNECT M3u M4u BY VIA3u
CONNECT M4u M5u BY VIA4u
CONNECT M5u M6u BY VIA5u

CONNECT CB1u M6u
#IFDEF SINGLE_PASSIVATION
CONNECT UBMu M6u BY CB1u
CONNECT UBMu APu BY EMPTYi
#ELSE
#IFDEF WITH_APRDL
CONNECT M6u APu  BY RVu
#ENDIF
CONNECT M6u APu  BY CB1u
CONNECT CB2u APu
#IFNDEF WLCSP
CONNECT UBMu APu BY CB2u
#ELSE
CONNECT Cu_PPIu APu BY CB2u 
CONNECT PM2u Cu_PPIu
CONNECT UBMu PM2u
#ENDIF
#ENDIF


//======================================
NWj   = NWi NOT NW_RES_200ohm
NWRjT = EMPTYi OR NWRiT
RWj   = EMPTYi OR RWi
PWELj = EMPTYi OR PWELi
POj   = POi NOT PO_RES_200ohm
SRDPOj = EMPTYi OR SRDPO

NSDj  = NSDi NOT OD_RES_200ohm
PSDj  = PSDi NOT OD_RES_200ohm
NSTPj = EMPTYi OR (NPODi AND NWi)

PSTPj = EMPTYi OR PSTPi
COj   = EMPTYi OR COi
M1j   = EMPTYi OR M1i
VIA1j = EMPTYi OR VIA1i
M2j   = EMPTYi OR M2i
VIA2j = EMPTYi OR VIA2i
M3j   = EMPTYi OR M3i
VIA3j = EMPTYi OR VIA3i
M4j   = EMPTYi OR M4i
VIA4j = EMPTYi OR VIA4i
M5j   = EMPTYi OR M5i
VIA5j = EMPTYi OR VIA5i
M6j   = EMPTYi OR M6i
RVj   = EMPTYi OR RVi
CB1j  = EMPTYi OR CB1i
CB2j  = EMPTYi OR CB2i
APj   = EMPTYi OR APi
Cu_PPIj = EMPTYi OR Cu_PPIi
PM1j  = EMPTYi OR PM1i
PM2j  = EMPTYi OR PM2i
UBMj  = EMPTYi OR UBMi

CONNECT NSTPj NWj
CONNECT NSTPj PSDj	// For butted pickup
CONNECT PSTPj RWj	// For DNW connection
CONNECT PSTPj PWELj	// For DNW connection
CONNECT PSTPj NSDj	// For butted pickup
CONNECT COj PSDj        // For butted CO
CONNECT COj NSDj        // For butted CO
CONNECT COj POj         // For butted CO
CONNECT M1j SRDPOj BY COj
CONNECT M1j POj NSTPj PSTPj PSDj NSDj BY COj
CONNECT M1j NWRjT BY COj
CONNECT M1j M2j BY VIA1j
CONNECT M2j M3j BY VIA2j
CONNECT M3j M4j BY VIA3j
CONNECT M4j M5j BY VIA4j
CONNECT M5j M6j BY VIA5j

CONNECT CB1j M6j
#IFDEF SINGLE_PASSIVATION
CONNECT UBMj M6j BY CB1j
CONNECT UBMj APj BY EMPTYi
#ELSE
#IFDEF WITH_APRDL
CONNECT M6j APj  BY RVj
#ENDIF
CONNECT M6j APj  BY CB1j
CONNECT CB2j APj
#IFNDEF WLCSP
CONNECT UBMj APj BY CB2j
#ELSE
CONNECT Cu_PPIj APj BY CB2j 
CONNECT PM2j Cu_PPIj
CONNECT UBMj PM2j
#ENDIF
#ENDIF


#IFDEF SINGLE_PASSIVATION
PADi = CB1i NOT EMPTYi
PADj = CB1j NOT EMPTYi 
PADu = CB1u NOT EMPTYi 
#ELSE
#IFDEF WLCSP
PADi = PM2i NOT EMPTYi
PADj = PM2j NOT EMPTYi
PADu = PM2u NOT EMPTYi
#ELSE
#IFDEF WIRE_BOND
#IFDEF WITH_APRDL
PADi = CB2i NOT EMPTYi
PADj = CB2j NOT EMPTYi
PADu = CB2u NOT EMPTYi
#ELSE
PADi = CB1i NOT EMPTYi
PADj = CB1j NOT EMPTYi
PADu = CB1u NOT EMPTYi
#ENDIF
#ELSE // FLIP_CHIP
PADi = CB2i NOT EMPTYi
PADj = CB2j NOT EMPTYi
PADu = CB2u NOT EMPTYi
#ENDIF


#ENDIF
#ENDIF

PSTPix    = PSTPi NOT INSIDE RWi

SD_HVD    = SD AND (HVD_N OR HVD_P)

SD_OD2    = (SD AND (OD2i NOT OD1815)) NOT SD_HVD

SD_UD15   = SD AND (OD2i AND OD1815)
SD_CORE   = SD NOT OD2i



PSD_HVD   = STAMP SD_HVD BY PSDc
NSD_HVD   = STAMP SD_HVD BY NSDc
S_HVD_GATE = STAMP HVD_GATE BY ILP1i
PSD_OD2   = STAMP SD_OD2 BY PSDc
NSD_OD2   = STAMP SD_OD2 BY NSDc

S_HV_GATE = STAMP (HV_GATE NOT OD1815) BY ILP1i
PSD_UD15  = STAMP SD_UD15 BY PSDc
NSD_UD15  = STAMP SD_UD15 BY NSDc
S_MV_GATE = STAMP (HV_GATE AND OD1815) BY ILP1i

PSD_CORE  = STAMP SD_CORE BY PSDc
NSD_CORE  = STAMP SD_CORE BY NSDc
S_LV_GATE = STAMP LV_GATE BY ILP1i




M1_HV_5V = STAMP (M1_HV_5Vi AND M1i) BY M1i
M1_HV = STAMP (M1_HVi AND M1i) BY M1i
M1_MV = STAMP (M1_MVi AND M1i) BY M1i
M1_LV = STAMP (M1_LVi AND M1i) BY M1i

M2_HV_5V = STAMP (M2_HV_5Vi AND M2i) BY M2i
M2_HV = STAMP (M2_HVi AND M2i) BY M2i
M2_MV = STAMP (M2_MVi AND M2i) BY M2i
M2_LV = STAMP (M2_LVi AND M2i) BY M2i

M3_HV_5V = STAMP (M3_HV_5Vi AND M3i) BY M3i
M3_HV = STAMP (M3_HVi AND M3i) BY M3i
M3_MV = STAMP (M3_MVi AND M3i) BY M3i
M3_LV = STAMP (M3_LVi AND M3i) BY M3i

M4_HV_5V = STAMP (M4_HV_5Vi AND M4i) BY M4i
M4_HV = STAMP (M4_HVi AND M4i) BY M4i
M4_MV = STAMP (M4_MVi AND M4i) BY M4i
M4_LV = STAMP (M4_LVi AND M4i) BY M4i

M5_HV_5V = STAMP (M5_HV_5Vi AND M5i) BY M5i
M5_HV = STAMP (M5_HVi AND M5i) BY M5i
M5_MV = STAMP (M5_MVi AND M5i) BY M5i
M5_LV = STAMP (M5_LVi AND M5i) BY M5i

M6_HV_5V = STAMP (M6_HV_5Vi AND M6i) BY M6i
M6_HV = STAMP (M6_HVi AND M6i) BY M6i
M6_MV = STAMP (M6_MVi AND M6i) BY M6i
M6_LV = STAMP (M6_LVi AND M6i) BY M6i














M1_HVN_5V = NET AREA RATIO M1i OVER M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M1_HVN = NET AREA RATIO M1i OVER M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M1_MVN = NET AREA RATIO M1i OVER M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M1_LVN = NET AREA RATIO M1i OVER M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0




M1_NOMARK = (((M1i NOT M1_HVN_5V) NOT M1_HVN) NOT M1_MVN) NOT M1_LVN



#IFDEF Mx_S_8_IO_NET
  M1_NOMARK_5V = NET AREA RATIO M1_NOMARK PSD_HVD NSD_HVD PSTPix > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)]
  M1_NOMARK_HV = NET AREA RATIO M1_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)]
  M1_NOMARK_MV = NET AREA RATIO M1_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)]
#ELSE              
  M1_NOMARK_5V = NET AREA RATIO M1_NOMARK PSD_HVD NSD_HVD PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M1_NOMARK_HV = NET AREA RATIO M1_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M1_NOMARK_MV = NET AREA RATIO M1_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 

#ENDIF 

M1_5V_ALL = M1_HVN_5V OR M1_NOMARK_5V  
M1_HV_ALL = M1_HVN OR M1_NOMARK_HV
M1_MV_ALL = M1_MVN OR M1_NOMARK_MV

M2_HVN_5V = NET AREA RATIO M2i OVER M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M2_HVN = NET AREA RATIO M2i OVER M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M2_MVN = NET AREA RATIO M2i OVER M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M2_LVN = NET AREA RATIO M2i OVER M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0




M2_NOMARK = (((M2i NOT M2_HVN_5V) NOT M2_HVN) NOT M2_MVN) NOT M2_LVN



#IFDEF Mx_S_8_IO_NET
  M2_NOMARK_5V = NET AREA RATIO M2_NOMARK PSD_HVD NSD_HVD PSTPix > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)]
  M2_NOMARK_HV = NET AREA RATIO M2_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)]
  M2_NOMARK_MV = NET AREA RATIO M2_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)]
#ELSE              
  M2_NOMARK_5V = NET AREA RATIO M2_NOMARK PSD_HVD NSD_HVD PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M2_NOMARK_HV = NET AREA RATIO M2_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M2_NOMARK_MV = NET AREA RATIO M2_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 

#ENDIF 

M2_5V_ALL = M2_HVN_5V OR M2_NOMARK_5V  
M2_HV_ALL = M2_HVN OR M2_NOMARK_HV
M2_MV_ALL = M2_MVN OR M2_NOMARK_MV

M3_HVN_5V = NET AREA RATIO M3i OVER M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M3_HVN = NET AREA RATIO M3i OVER M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M3_MVN = NET AREA RATIO M3i OVER M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M3_LVN = NET AREA RATIO M3i OVER M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0




M3_NOMARK = (((M3i NOT M3_HVN_5V) NOT M3_HVN) NOT M3_MVN) NOT M3_LVN



#IFDEF Mx_S_8_IO_NET
  M3_NOMARK_5V = NET AREA RATIO M3_NOMARK PSD_HVD NSD_HVD PSTPix > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)]
  M3_NOMARK_HV = NET AREA RATIO M3_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)]
  M3_NOMARK_MV = NET AREA RATIO M3_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)]
#ELSE              
  M3_NOMARK_5V = NET AREA RATIO M3_NOMARK PSD_HVD NSD_HVD PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M3_NOMARK_HV = NET AREA RATIO M3_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M3_NOMARK_MV = NET AREA RATIO M3_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 

#ENDIF 

M3_5V_ALL = M3_HVN_5V OR M3_NOMARK_5V  
M3_HV_ALL = M3_HVN OR M3_NOMARK_HV
M3_MV_ALL = M3_MVN OR M3_NOMARK_MV

M4_HVN_5V = NET AREA RATIO M4i OVER M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M4_HVN = NET AREA RATIO M4i OVER M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M4_MVN = NET AREA RATIO M4i OVER M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M4_LVN = NET AREA RATIO M4i OVER M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0




M4_NOMARK = (((M4i NOT M4_HVN_5V) NOT M4_HVN) NOT M4_MVN) NOT M4_LVN



#IFDEF Mx_S_8_IO_NET
  M4_NOMARK_5V = NET AREA RATIO M4_NOMARK PSD_HVD NSD_HVD PSTPix > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)]
  M4_NOMARK_HV = NET AREA RATIO M4_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)]
  M4_NOMARK_MV = NET AREA RATIO M4_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)]
#ELSE              
  M4_NOMARK_5V = NET AREA RATIO M4_NOMARK PSD_HVD NSD_HVD PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M4_NOMARK_HV = NET AREA RATIO M4_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M4_NOMARK_MV = NET AREA RATIO M4_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 

#ENDIF 

M4_5V_ALL = M4_HVN_5V OR M4_NOMARK_5V  
M4_HV_ALL = M4_HVN OR M4_NOMARK_HV
M4_MV_ALL = M4_MVN OR M4_NOMARK_MV

M5_HVN_5V = NET AREA RATIO M5i OVER M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M5_HVN = NET AREA RATIO M5i OVER M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M5_MVN = NET AREA RATIO M5i OVER M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M5_LVN = NET AREA RATIO M5i OVER M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0




M5_NOMARK = (((M5i NOT M5_HVN_5V) NOT M5_HVN) NOT M5_MVN) NOT M5_LVN



#IFDEF Mx_S_8_IO_NET
  M5_NOMARK_5V = NET AREA RATIO M5_NOMARK PSD_HVD NSD_HVD PSTPix > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)]
  M5_NOMARK_HV = NET AREA RATIO M5_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)]
  M5_NOMARK_MV = NET AREA RATIO M5_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)]
#ELSE              
  M5_NOMARK_5V = NET AREA RATIO M5_NOMARK PSD_HVD NSD_HVD PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M5_NOMARK_HV = NET AREA RATIO M5_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M5_NOMARK_MV = NET AREA RATIO M5_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPix PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPix)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 

#ENDIF 

M5_5V_ALL = M5_HVN_5V OR M5_NOMARK_5V  
M5_HV_ALL = M5_HVN OR M5_NOMARK_HV
M5_MV_ALL = M5_MVN OR M5_NOMARK_MV


RFIP = RFDMY AND RFIPDMY
// waive for eDRAM
OD_RAM = OD INSIDE RAM1TDMY
OD_SF1 = OD_RAM WITH WIDTH == OD_SEx_eDRAM
OD_SF2 = (OD_RAM TOUCH EDGE OD_SF1) NOT COIN INSIDE EDGE OD_SF1
OD_SF3 = EXPAND EDGE OD_SF2 INSIDE BY OD_SEy_eDRAM
OD_NSF = (OD NOT OD_SF1) NOT OD_SF3
OD_DMY = (OD_RAM NOT INTERACT CO) NOT INTERACT SNCT

RAM_OD = OD NOT OUTSIDE RAM1TDMY
RAM_POLY = POLY NOT OUTSIDE RAM1TDMY
RAM_GATE_W = GATE_W INSIDE EDGE RAM1TDMY
RAM_GATE = GATE INSIDE RAM1TDMY



#IFDEF SINGLE_PASSIVATION
CHIP_AP = COPY EMPTYi  
#ELSE
#IFDEF WITH_APRDL
CHIP_AP = COPY CHIPx
#ELSE
#IFDEF WIRE_BOND
CHIP_AP = COPY EMPTYi  
#ELSE
CHIP_AP = COPY CHIPx
#ENDIF
#ENDIF
#ENDIF

AP_PAD_pre = (WITH WIDTH APi <= AP_W_2) WITH WIDTH >= AP_W_1
AP_PAD = (APi NOT AP_PAD_pre) WITH WIDTH >= AP_W_1






#IFDEF MOM_18V
#IFDEF MOM_25V
#IFDEF MOM_33V
OPTION.MOM:ERROR1 { @ 'MOM_18V', 'MOM_25V', and 'MOM_33V' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF
#ENDIF

#IFDEF MOM_18V
#IFDEF MOM_25V
OPTION.MOM:ERROR2 { @ 'MOM_18V', and 'MOM_25V' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF MOM_18V
#IFDEF MOM_33V
OPTION.MOM:ERROR3 { @ 'MOM_18V', and 'MOM_33V' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF MOM_25V
#IFDEF MOM_33V
OPTION.MOM:ERROR4 { @ 'MOM_25V', and 'MOM_33V' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF HVMOS_25
#IFDEF HVMOS_18
OPTION.HVMOS:ERROR1 { @ Only One of HVMOS_25 or HVMOS_18 switch can be enabled
  COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF HVMOS_25
OPTION.HVMOS:ERROR2 { @ HVMOS_25 is enabled, but OD18 is found
  CHIP INTERACT OD18i
}
#ENDIF

#IFDEF HVMOS_18
OPTION.HVMOS:ERROR3 { @ HVMOS_18 is enabled, but OD25 is found
  CHIP INTERACT OD25i
}
#ENDIF
#IFDEF HVMOS_25
OPTION.HVMOS:ERROR4 { @ HVMOS_25 is enabled, but DEHVD_N is found
  CHIP INTERACT DEHVD_N
}
#ENDIF

#IFDEF HVMOS_18
OPTION.HVMOS:ERROR5 { @ HVMOS_18 is enabled, but DEHVD_N is found
  CHIP INTERACT DEHVD_N
}
#ENDIF

#IFDEF HVMOS_18
#IFNDEF HALF_NODE
OPTION.HVMOS:ERROR6 { @ Gate voltage 1.8V HVMOS can be used in N40LP only.
	COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3_SEALRING
#IFDEF P3R_SEALRING
OPTION.SEALRING:ERROR1 { @ 'P3_SEALRING' and 'P3R_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3_SEALRING
#IFDEF P4_SEALRING
OPTION.SEALRING:ERROR2 { @ 'P3_SEALRING' and 'P4_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3R_SEALRING
#IFDEF P4_SEALRING
OPTION.SEALRING:ERROR3 { @ 'P3R_SEALRING' and 'P4_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF WITH_SEALRING
#IFNDEF FULL_CHIP
OPTION.SEALRING:ERROR4 { @ If you turn on 'WITH_SEALRING' option, please turn on 'FULL_CHIP' option also.
   COPY CHIP
}
#ENDIF
#ENDIF


#IFDEF P3_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING:ERROR5 { @ If you turn on 'P3_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3R_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING:ERROR6 { @ If you turn on 'P3R_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P4_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING:ERROR7 { @ If you turn on 'P4_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF


#IFDEF COMPATIBLE_MODE
#IFDEF HALF_NODE
OPTION.COMPATIBLE_MODE:ERROR1 { @ 'COMPATIBLE_MODE' option and 'HALF_NODE' option should not be enabled at the same time.
                 @ If these two options are all enabled, only 'HALF_NODE' option will be effective.
  COPY CHIP
}
#ENDIF
#IFDEF GS
OPTION.COMPATIBLE_MODE:ERROR2 { @ 'COMPATIBLE_MODE' option is only for N45LP/N40LP, please turn off this option in N45GS(N40G).
  COPY CHIP
}
#ENDIF
#ENDIF



#IFDEF GS
3.3V_IO:WARNING1 { @ 3.3V IO is not standard offer in N45GS(N40G)
   COPY OD33i
}
DCO:WARNING1 { @ DCO layer is not standard offer in N45GS(N40G)
   COPY DCOi 
}
5V_HVMOS:WARNING1 { @ 5V HVMOS is not standard offer in N45GS(N40G) 
   COPY HVD_N
   COPY HVD_P
}
DENMOS:WARNING1 { @ 5V DENMOS is not standard offer in N45GS(N40G) 
   COPY DEHVD_N
}
DCO_LPP:WARNING1 { @ DCO_LPP layer is not standard offer in N45GS(N40G) 
   COPY DCO_LPPi
}
ULVT_N:WARNING1 { @ ULVT_N layer is not standard offer in N45GS(N40G) 
   COPY ULVT_Ni
}
ULVT_P:WARNING1 { @ ULVT_P layer is not standard offer in N45GS(N40G) 
   COPY ULVT_Pi
}
#ELSE
#IFNDEF HALF_NODE
3.3V_IO:WARNING2 { @ 3.3V IO is not standard offer in N45LP/N45LPG
   COPY OD33i
}
OD18_15:WARNING1 { @ 1.8V underdrive to 1.5V is not standard offer in N45LP/N45LPG
   COPY OD1815
}
DENMOS:WARNING1 { @ 5V DENMOS is not standard offer in N45LP/N45LPG 
   COPY DEHVD_N
}
DCO_LPP:WARNING1 { @ DCO_LPP layer is not standard offer in N45LP/N45LPG 
   COPY DCO_LPPi
}
ULVT_N:WARNING1 { @ ULVT_N layer is not standard offer in N45LP/N45LPG
   COPY ULVT_Ni
}
ULVT_P:WARNING1 { @ ULVT_P layer is not standard offer in N45LP/N45LPG
   COPY ULVT_Pi
}
#IFDEF LPG
2.5V_IO:WARNING1 { @ 2.5V IO is not standard offer in N45LPG
   COPY OD25i
}
#ENDIF
#ELSE
#IFDEF LPG
1.8V_IO:WARNING1 { @ 1.8V IO is not standard offer in N40LPG
   COPY OD18i
}
2.5V_IO:WARNING2 { @ 2.5V IO is not standard offer in N40LPG
   COPY OD25i
}
DENMOS:WARNING1 { @ 5V DENMOS is not standard offer in N40LPG 
   COPY DEHVD_N
}
DCO_LPP:WARNING1 { @ DCO_LPP layer is not standard offer in N40LPG
   COPY DCO_LPPi
}
ULVT_N:WARNING1 { @ ULVT_N layer is not standard offer in N40LPG 
   COPY ULVT_Ni
}
ULVT_P:WARNING1 { @ ULVT_P layer is not standard offer in N40LPG 
   COPY ULVT_Pi
}
#ELSE
3.3V_IO:WARNING4 { @ 3.3V IO is not standard offer in N40LP
   COPY OD33i
}
#ENDIF
#ENDIF
OD12:WARNING1 { @ 1.2V Core Oxide is not standard offer in N45LP/N45LPG/N40LP/N40LPG 
   COPY  OD12i
}
#ENDIF


#IFDEF OLD_SEALRING
SEALRING:WARNING1 { @ Phase3 and Phase3R Sealring were phased out. Please use Phase4R Sealring.
   COPY CHIPx
}
#ENDIF

#IFDEF P4_SEALRING
SEALRING:WARNING2 { @ Phase4 sealring was phased out. Please use Phase4R Sealring with updated BIB/CDU pattern. 
   COPY CHIPx
}
#ENDIF

M7_VIA6:WARNING1 { @ This is 6M DRC. If customer wants to check M7. Please use M7 DRC command file.
  COPY METAL_ABOVE_TOP
  COPY VIA_ABOVE_TOP
}

#IFNDEF WITH_POLYIMIDE
OPTION.PM:WARNING1 { @ PMi (5;0) shouldn't exist if WITH_POLYIMIDE is turned off.
  COPY PMi
}
#ENDIF
#IFDEF WIRE_BOND
#IFNDEF WITH_APRDL
OPTION.APRDL:WARNING1 { @ APi (74;0) is derived from logic operation, and it shouldn't exist if WIREBOND Without APRDL (FBEOL option 1) is used.
  COPY APi
}
#ENDIF
#ENDIF

#IFDEF CHECK_PRBOUNDARY_DENSITY
OPTION.prBoundary:WARNING1 { @ Turn on 'CHECK_PRBOUNDARY_DENSITY' option will use prBoundary as chip edge for Mx.DN.6R/Mx.DN.7R, please turn off this option if there exists no prBoundary.
  CHIPx NOT INTERACT prBoundary
}
#ENDIF

#IFDEF DISCONNECT_ALL_RESISTOR
#IFDEF CONNECT_ALL_RESISTOR
LUP.WARN.1 { @ DRC LUP switch setting conflict detected (refer to section XXX for details): Please follow one of the following LUP switch settings: 1 [Default setting: RES200 usage] Turns off both "DISCONNECT_ALL_RESISTOR", and "CONNECT_ALL_RESISTOR": circuits after RES200 will NOT be recognized as OD injector, or 2 Turns on "DISCONNECT_ALL_RESISTOR" only: circuits after any resistor will NOT recognized as OD injector, or 3 Turns on "CONNECT_ALL_RESISTOR" only: circuits after any resistor will always be recognized as OD injector Please DO NOT turn on both "DISCONNECT_ALL_RESISTOR", and "CONNECT_ALL_RESISTOR" at the same time, otherwise "DISCONNECT_ALL_RESISTOR" will have higher priority   
  COPY CHIPx
}
#ENDIF
#ENDIF


RM.WARN.1 { @ CO overlap {NWDMY AND NW} is not allowed
  CO AND (NWDMY AND NWi)
}
RM.WARN.2 { @ CO overlap silicided OD/PO resistor is not allowed
  CO AND OD_RES_noRPO
  CO AND PO_RES_noRPO
}
RM.WARN.3 { @ CO overlap {RMDMY1 AND M1} is not allowed
	CO AND (RMDMY1 AND M1i)
}
RM.WARN.4:M1 { @ VIA1 overlap {RMDMY1 AND M1} is not allowed.
  (RMDMY1 AND M1i) AND VIA1i
}


RM.WARN.4:M2 { @ {VIA2 OR VIA1} overlap {RMDMY2 AND M2} is not allowed.
	(RMDMY2 AND M2i) AND (VIA2i OR VIA1i)
}


RM.WARN.4:M3 { @ {VIA3 OR VIA2} overlap {RMDMY3 AND M3} is not allowed.
	(RMDMY3 AND M3i) AND (VIA3i OR VIA2i)
}


RM.WARN.4:M4 { @ {VIA4 OR VIA3} overlap {RMDMY4 AND M4} is not allowed.
	(RMDMY4 AND M4i) AND (VIA4i OR VIA3i)
}


RM.WARN.4:M5 { @ {VIA5 OR VIA4} overlap {RMDMY5 AND M5} is not allowed.
	(RMDMY5 AND M5i) AND (VIA5i OR VIA4i)
}


RM.WARN.4:M6 { @ VIA5 overlap {RMDMY6 AND M6} is not allowed.
  (RMDMY6 AND M6i) AND VIA5i
}


RM.WARN.5 { @ RV overlap {{RMDMYAP AND AP} OR {RMDMYn AND Mn}} is not allowed. (n = top)
  RV AND (RMDMYAP AND AP)
  RV AND (RMDMY6 AND M6i)
}


#IFDEF N45_LP
#IFDEF N40_LP 
OPTION.PROCESS:WARNING1 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N45_LPG
OPTION.PROCESS:WARNING2 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N40_LPG
OPTION.PROCESS:WARNING3 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N40_G  
OPTION.PROCESS:WARNING4 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF N40_LP 
#IFDEF N45_LPG
OPTION.PROCESS:WARNING5 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N40_LPG
OPTION.PROCESS:WARNING6 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N40_G  
OPTION.PROCESS:WARNING7 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF N45_LPG
#IFDEF N40_LPG
OPTION.PROCESS:WARNING8 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#IFDEF N40_G  
OPTION.PROCESS:WARNING9 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF N40_LPG
#IFDEF N40_G  
OPTION.PROCESS:WARNING10 { @ Please only turn on one process switch at a time.
  COPY CHIP
}
#ENDIF
#ENDIF






DRM.R.1 { @ DRM.R.1 is a rule created to remind you that the following DRM and DRC must be checked before tape-out.
	@ 1. T-N45-CL-DR-003 & T-N45-CL-DR-017 are pad and assembly related design rule that is not included into this design rule. Please make sure the DRC of T-N45-CL-DR-003 & T-N45-CL-DR-017 has been executed before tape-out.  
	@ 2. Antenna deck is seperated from the main deck. Please make sure the Antenna deck has been executed before tape-out.
	@ If the above items have been checked, this violation can be ignored. (please refer to the following Figure)
     COPY CHIPx
}

#IFNDEF DFM_ONLY


G.1:DNWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DNWi 5
}
G.1:NWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NWi 5
}
G.1:OD12i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD12i 5
}
G.1:OD18i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD18i 5
}
G.1:OD1815 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1815 5
}
G.1:OD25i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25i 5
}
G.1:OD2533 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD2533 5
}
G.1:OD2518 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD2518 5
}
G.1:OD25_LK { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25_LK 5
}
G.1:OD33i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD33i 5
}
G.1:ODDECAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID ODDECAP 5
}
G.1:PPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID PPi 5
}
G.1:NPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NPi 5
}
G.1:HVD_N { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_N 5
}
G.1:HVD_P { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_P 5
}
G.1:DEHVD_N { @ grid must be an integer multiple of ^Grid um
  OFFGRID DEHVD_N 5
}
G.1:CBi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBi 5
}
G.1:RPOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RPOi 5
}
G.1:NTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NTNi 5
}
G.1:LPP_NTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTNi 5
}
G.1:LPP_NTN_21i { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_21i 5
}
G.1:LPP_NTN_DPOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_DPOi 5
}
G.1:LPP_NTN_120i { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_120i 5
}
G.1:POFUSE { @ grid must be an integer multiple of ^Grid um
  OFFGRID POFUSE 5
}
G.1:FUSELINK { @ grid must be an integer multiple of ^Grid um
  OFFGRID FUSELINK 5
}
G.1:SEALRING_ORI { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_ORI 5
}
G.1:SEALRING_DB { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_DB 5
}
G.1:SEALRING_ALL { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_ALL 5
}
G.1:VTHNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTHNi 5
}
G.1:VTHPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTHPi 5
}
G.1:VTLNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLNi 5
}
G.1:VTLPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLPi 5
}
G.1:VTULNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTULNi 5
}
G.1:VTULPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTULPi 5
}
G.1:ULVT_Ni { @ grid must be an integer multiple of ^Grid um
  OFFGRID ULVT_Ni 5
}
G.1:ULVT_Pi { @ grid must be an integer multiple of ^Grid um
  OFFGRID ULVT_Pi 5
}
G.1:VTLN18 { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLN18 5
}
G.1:CBDB { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBDB 5
}
G.1:UBMB { @ grid must be an integer multiple of ^Grid um
  OFFGRID UBMB 5
}
G.1:RH { @ grid must be an integer multiple of ^Grid um
  OFFGRID RH 5
}
G.1:RHDMY1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RHDMY1 5
}
G.1:ESDIMP { @ grid must be an integer multiple of ^Grid um
  OFFGRID ESDIMP 5
}
G.1:VARi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VARi 5
}
G.1:DVAR { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVAR 5
}
G.1:DMY_S_Pad { @ grid must be an integer multiple of ^Grid um
  OFFGRID DMY_S_Pad 5
}
G.1:DMY_U_Pad { @ grid must be an integer multiple of ^Grid um
  OFFGRID DMY_U_Pad 5
}
G.1:AP_BSL { @ grid must be an integer multiple of ^Grid um
  OFFGRID AP_BSL 5
}
G.1:AP_BSP { @ grid must be an integer multiple of ^Grid um
  OFFGRID AP_BSP 5
}
G.1:CBMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBMi 5
}
G.1:CTMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMi 5
}
G.1:RVi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RVi 5
}
G.1:RV_BSL { @ grid must be an integer multiple of ^Grid um
  OFFGRID RV_BSL 5
}
G.1:DCOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DCOi 5
}
G.1:DCO_LPPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DCO_LPPi 5
}
G.1:DCODMY_SCi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DCODMY_SCi 5
}
G.1:LMARK { @ grid must be an integer multiple of ^Grid um
  OFFGRID LMARK 5
}
G.1:SRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM 5
}
G.1:SRMN { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMN 5
}
G.1:SRMP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMP 5
}
G.1:SRMRP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMRP 5
}
G.1:NPreDOSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID NPreDOSRM 5
}
G.1:ROM { @ grid must be an integer multiple of ^Grid um
  OFFGRID ROM 5
}
G.1:SRM_HS { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM_HS 5
}
G.1:SRAMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY 5
}
G.1:SRAMDMY_PAS { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PAS 5
}
G.1:SRAMDMY_PERI_LP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PERI_LP 5
}
G.1:SRAMDMY_PERI_G { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PERI_G 5
}
G.1:CO2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID CO2 5
}
G.1:DPSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID DPSRM 5
}
G.1:PRSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID PRSRM 5
}
G.1:SRMLOP12 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP12 5
}
G.1:SRMLOP13 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP13 5
}
G.1:SRMLOP14 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP14 5
}
G.1:LVLOP { @ grid must be an integer multiple of ^Grid um
  OFFGRID LVLOP 5
}
G.1:HCDPLOP { @ grid must be an integer multiple of ^Grid um
  OFFGRID HCDPLOP 5
}
G.1:TPLOP_8T { @ grid must be an integer multiple of ^Grid um
  OFFGRID TPLOP_8T 5
}
G.1:TPLOP_10T { @ grid must be an integer multiple of ^Grid um
  OFFGRID TPLOP_10T 5
}
G.1:RAM1TDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RAM1TDMY 5
}
G.1:OD1T { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T 5
}
G.1:OD1TH { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1TH 5
}
G.1:OD1TM { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1TM 5
}
G.1:OD1T_WLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_WLD 5
}
G.1:OD1T_MOSCAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_MOSCAP 5
}
G.1:OD1T_CP { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_CP 5
}
G.1:OD1T_20 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_20 5
}
G.1:OD1T_18 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_18 5
}
G.1:OD1T_16 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_16 5
}
G.1:CLDD { @ grid must be an integer multiple of ^Grid um
  OFFGRID CLDD 5
}
G.1:EDRAM_DECAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID EDRAM_DECAP 5
}
G.1:SNCT { @ grid must be an integer multiple of ^Grid um
  OFFGRID SNCT 5
}
G.1:CDUDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID CDUDMY 5
}
G.1:TCDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY 5
}
G.1:TCDDMY_H { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY_H 5
}
G.1:TCDDMY_V { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY_V 5
}
G.1:ICOVL { @ grid must be an integer multiple of ^Grid um
  OFFGRID ICOVL 5
}
G.1:LOGO { @ grid must be an integer multiple of ^Grid um
  OFFGRID LOGO 5
}
G.1:TLDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID TLDMY 5
}
G.1:DIODMYi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DIODMYi 5
}
G.1:DIO3TDMYi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DIO3TDMYi 5
}
G.1:RFDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RFDMY 5
}
G.1:RFIPDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RFIPDMY 5
}
G.1:LUPWDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID LUPWDMY 5
}
G.1:LUPWDMY_2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID LUPWDMY_2 5
}
G.1:M1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M1i 5
}
G.1:DM1_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM1_O 5
}
G.1:DUM1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM1 5
}
G.1:M2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M2i 5
}
G.1:DM2_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM2_O 5
}
G.1:DUM2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM2 5
}
G.1:M3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M3i 5
}
G.1:DM3_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM3_O 5
}
G.1:DUM3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM3 5
}
G.1:M4i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M4i 5
}
G.1:DM4_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM4_O 5
}
G.1:DUM4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM4 5
}
G.1:M5i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M5i 5
}
G.1:DM5_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM5_O 5
}
G.1:DUM5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM5 5
}
G.1:M6_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M6_OLD 5
}
G.1:M6_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M6_NEW 5
}
G.1:DUM6_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM6_OLD 5
}
G.1:DUM6_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM6_NEW 5
}
G.1:VIA1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA1i 5
}
G.1:DVIA1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA1 5
}
G.1:VIA2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA2i 5
}
G.1:DVIA2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA2 5
}
G.1:VIA3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA3i 5
}
G.1:DVIA3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA3 5
}
G.1:VIA4i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA4i 5
}
G.1:DVIA4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA4 5
}
G.1:VIA5_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA5_OLD 5
}
G.1:VIA5_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA5_NEW 5
}
G.1:DOD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DOD 5
}
G.1:SRDOD { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRDOD 5
}
G.1:DPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID DPO 5
}
G.1:SRDPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRDPO 5
}
G.1:mVTLi { @ grid must be an integer multiple of ^Grid um
  OFFGRID mVTLi 5
}
G.1:CPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID CPO 5
}
G.1:BJT4TDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJT4TDMY 5
}
G.1:BJTDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTDMY 5
}
G.1:BJTDMY1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTDMY1 5
}
G.1:BJT7TDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJT7TDMY 5
}
G.1:BJTMDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTMDDMY 5
}
G.1:BJTSNDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTSNDMY 5
}
G.1:BJT7TDMY_19 { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJT7TDMY_19 5
}
G.1:BJT7TDMY_33 { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJT7TDMY_33 5
}
G.1:BJT5TDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJT5TDMY 5
}
G.1:MATCHING_HV { @ grid must be an integer multiple of ^Grid um
  OFFGRID MATCHING_HV 5
}
G.1:MATCHING { @ grid must be an integer multiple of ^Grid um
  OFFGRID MATCHING 5
}
G.1:MATCHING_S { @ grid must be an integer multiple of ^Grid um
  OFFGRID MATCHING_S 5
}
G.1:RES50 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RES50 5
}
G.1:POS1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS1 5
}
G.1:POS2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS2 5
}
G.1:POS_OTHERS { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS_OTHERS 5
}
G.1:RMDMY1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY1 5
}
G.1:RMDMY2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY2 5
}
G.1:RMDMY3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY3 5
}
G.1:RMDMY4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY4 5
}
G.1:RMDMY5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY5 5
}
G.1:RMDMY6 { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMY6 5
}
G.1:RMDMYAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID RMDMYAP 5
}
G.1:CO { @ ^Grid um grid is required for CO outside SRAM periphrial regions
  X = COi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
G.1:PO { @ ^Grid um grid is required for PO outside SRAM periphrial regions
  X = POi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
G.1:OD { @ grid must be an integer multiple of 0.005 um
  OFFGRID OD 5
}
#IFDEF WLCSP
G.1:CBD { @ grid must be an integer multiple of 0.005 um 
  OFFGRID CBDi 5	
}
G.1:CB2F { @ grid must be an integer multiple of 0.005 um
  X = CB2Fi NOT Cu_PPIi
  OFFGRID X 5	
}
G.1:CB2W { @ grid must be an integer multiple of 0.005 um
  X = CB2Wi NOT Cu_PPIi
  OFFGRID X 5	
}
G.1:PM2i { @ grid must be an integer multiple of 0.005 um
  X = PM2i NOT UBMi
  OFFGRID X 5
}
#ELSE
G.1:CBD { @ grid must be an integer multiple of 0.005 um 
  X = CBDi NOT UBMi
  OFFGRID X 5	
}
G.1:CB2F { @ grid must be an integer multiple of 0.005 um
  X = CB2Fi NOT UBMi
  OFFGRID X 5	
}
G.1:CB2W { @ grid must be an integer multiple of 0.005 um
  OFFGRID CB2Wi 5	
}
G.1:PM { @ grid must be an integer multiple of 0.005 um
  X = PMi NOT UBMi
  OFFGRID X 5	
}
#ENDIF
G.1:APi { @ grid must be an integer multiple of 0.005 um
  X = OFFGRID APi 5 REGION GRID
  X NOT INTERACT AP_PAD
}
G.2:DNWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD12i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD12i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD12i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD18i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD18i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD18i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1815 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1815 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1815 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD25i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD2533 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD2533 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2533 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD2518 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD2518 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2518 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD25_LK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25_LK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25_LK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD33i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD33i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD33i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODDECAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODDECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODDECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:HVD_N { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:HVD_P { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DEHVD_N { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DEHVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DEHVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:COi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:COPUSH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COPUSH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COPUSH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:COiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RPOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LPP_NTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LPP_NTN_21i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_21i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_21i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LPP_NTN_DPOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_DPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_DPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LPP_NTN_120i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_120i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_120i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POFUSE { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:FUSELINK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SEALRING_ORI { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_ORI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_ORI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SEALRING_DB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_DB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_DB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SEALRING_ALL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_ALL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_ALL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTHNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTHNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTHNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTHPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTHPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTHPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTLNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTLPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTULNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTULNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTULNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTULPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTULPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTULPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ULVT_Ni { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ULVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ULVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ULVT_Pi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ULVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ULVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTLN18 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLN18 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLN18 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBDB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBDB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:UBMB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT UBMB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RHDMY1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RHDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RHDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ESDIMP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VARi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DVAR { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVAR < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVAR < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DMY_S_Pad { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DMY_S_Pad < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMY_S_Pad < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DMY_U_Pad { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DMY_U_Pad < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMY_U_Pad < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:AP_BSL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT AP_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:AP_BSP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT AP_BSP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_BSP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CTMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RVi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RV_BSL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RV_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RV_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DCOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DCO_LPPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DCO_LPPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DCO_LPPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DCODMY_SCi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DCODMY_SCi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DCODMY_SCi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMRP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMRP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMRP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NPreDOSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NPreDOSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPreDOSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ROM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ROM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ROM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRM_HS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM_HS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM_HS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY_PAS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PAS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PAS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY_PERI_LP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PERI_LP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PERI_LP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY_PERI_G { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PERI_G < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PERI_G < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CO2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CO2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CO2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DPSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DPSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PRSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PRSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PRSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMLOP12 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP12 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP12 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMLOP13 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP13 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP13 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRMLOP14 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP14 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP14 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LVLOP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LVLOP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LVLOP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:HCDPLOP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HCDPLOP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HCDPLOP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TPLOP_8T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TPLOP_8T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TPLOP_8T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TPLOP_10T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TPLOP_10T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TPLOP_10T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RAM1TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1TH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1TH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1TH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1TM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1TM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1TM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_WLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_WLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_WLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_MOSCAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_MOSCAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_MOSCAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_CP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_CP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_CP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_20 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_20 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_20 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_18 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_18 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_18 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD1T_16 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_16 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_16 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CLDD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CLDD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CLDD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:EDRAM_DECAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT EDRAM_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EDRAM_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SNCT { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SNCT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SNCT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CROWN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CROWN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CROWN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:P3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT P3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT P3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CDUDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TCDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TCDDMY_H { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY_H < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY_H < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TCDDMY_V { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY_V < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY_V < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ICOVL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ICOVL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ICOVL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LOGO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:TLDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DIODMYi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DIODMYi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIODMYi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DIO3TDMYi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DIO3TDMYi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIO3TDMYi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RFDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RFIPDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RFIPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFIPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LUPWDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LUPWDMY_2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LUPWDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LUPWDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM1_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM2_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM3_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M4i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM4_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M5i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM5_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM6_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM6_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DVIA1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DVIA2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DVIA3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA4i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DVIA4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA5_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA5_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODiRFDRAIN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODiRFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODiRFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DOD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRDOD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRDOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRDOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRDPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRDPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRDPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:mVTLi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJT4TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJT4TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJT4TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJTDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJTDMY1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJT7TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJT7TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJT7TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJTMDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTMDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTMDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJTSNDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTSNDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTSNDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJT7TDMY_19 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJT7TDMY_19 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJT7TDMY_19 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJT7TDMY_33 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJT7TDMY_33 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJT7TDMY_33 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJT5TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJT5TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJT5TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MATCHING_HV { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MATCHING_HV < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MATCHING_HV < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MATCHING { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MATCHING < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MATCHING < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MATCHING_S { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MATCHING_S < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MATCHING_S < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RES50 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RES50 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RES50 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POS1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POS2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POS_OTHERS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMY6 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMY6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMY6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RMDMYAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RMDMYAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RMDMYAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
#IFDEF WLCSP
G.2:CBD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CB2F { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CB2Fi NOT Cu_PPIi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CB2W { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CB2Wi NOT Cu_PPIi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PM2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = PM2i NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
#ELSE
G.2:CBD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CBDi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CB2F { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CB2Fi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CB2W { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CB2Wi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2Wi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = PMi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
#ENDIF
G.2:APi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = INT APi < 0.1 ABUT < 90 INTERSECTING ONLY REGION
  Y = EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY REGION
  X NOT INTERACT AP_PAD
  Y NOT INTERACT AP_PAD
}
G.3:DNWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DNWi >0  <45    
  ANGLE DNWi >45 <90    
}
G.3:NWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NWi >0  <45    
  ANGLE NWi >45 <90    
}
G.3:OD12i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD12i >0  <45    
  ANGLE OD12i >45 <90    
}
G.3:OD18i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD18i >0  <45    
  ANGLE OD18i >45 <90    
}
G.3:OD1815 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1815 >0  <45    
  ANGLE OD1815 >45 <90    
}
G.3:OD25i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25i >0  <45    
  ANGLE OD25i >45 <90    
}
G.3:OD2533 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD2533 >0  <45    
  ANGLE OD2533 >45 <90    
}
G.3:OD2518 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD2518 >0  <45    
  ANGLE OD2518 >45 <90    
}
G.3:OD25_LK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25_LK >0  <45    
  ANGLE OD25_LK >45 <90    
}
G.3:OD33i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD33i >0  <45    
  ANGLE OD33i >45 <90    
}
G.3:ODDECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODDECAP >0  <45    
  ANGLE ODDECAP >45 <90    
}
G.3:PPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PPi >0  <45    
  ANGLE PPi >45 <90    
}
G.3:NPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NPi >0  <45    
  ANGLE NPi >45 <90    
}
G.3:HVD_N { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_N >0  <45    
  ANGLE HVD_N >45 <90    
}
G.3:HVD_P { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_P >0  <45    
  ANGLE HVD_P >45 <90    
}
G.3:DEHVD_N { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DEHVD_N >0  <45    
  ANGLE DEHVD_N >45 <90    
}
G.3:COi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COi >0  <45    
  ANGLE COi >45 <90    
}
G.3:COPUSH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COPUSH >0  <45    
  ANGLE COPUSH >45 <90    
}
G.3:COiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COiSRAM >0  <45    
  ANGLE COiSRAM >45 <90    
}
G.3:CBi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBi >0  <45    
  ANGLE CBi >45 <90    
}
G.3:RPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RPOi >0  <45    
  ANGLE RPOi >45 <90    
}
G.3:NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NTNi >0  <45    
  ANGLE NTNi >45 <90    
}
G.3:LPP_NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTNi >0  <45    
  ANGLE LPP_NTNi >45 <90    
}
G.3:LPP_NTN_21i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_21i >0  <45    
  ANGLE LPP_NTN_21i >45 <90    
}
G.3:LPP_NTN_DPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_DPOi >0  <45    
  ANGLE LPP_NTN_DPOi >45 <90    
}
G.3:LPP_NTN_120i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_120i >0  <45    
  ANGLE LPP_NTN_120i >45 <90    
}
G.3:POFUSE { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POFUSE >0  <45    
  ANGLE POFUSE >45 <90    
}
G.3:FUSELINK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FUSELINK >0  <45    
  ANGLE FUSELINK >45 <90    
}
G.3:SEALRING_ORI { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_ORI >0  <45    
  ANGLE SEALRING_ORI >45 <90    
}
G.3:SEALRING_DB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_DB >0  <45    
  ANGLE SEALRING_DB >45 <90    
}
G.3:SEALRING_ALL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_ALL >0  <45    
  ANGLE SEALRING_ALL >45 <90    
}
G.3:VTHNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTHNi >0  <45    
  ANGLE VTHNi >45 <90    
}
G.3:VTHPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTHPi >0  <45    
  ANGLE VTHPi >45 <90    
}
G.3:VTLNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLNi >0  <45    
  ANGLE VTLNi >45 <90    
}
G.3:VTLPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLPi >0  <45    
  ANGLE VTLPi >45 <90    
}
G.3:VTULNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTULNi >0  <45    
  ANGLE VTULNi >45 <90    
}
G.3:VTULPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTULPi >0  <45    
  ANGLE VTULPi >45 <90    
}
G.3:ULVT_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ULVT_Ni >0  <45    
  ANGLE ULVT_Ni >45 <90    
}
G.3:ULVT_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ULVT_Pi >0  <45    
  ANGLE ULVT_Pi >45 <90    
}
G.3:VTLN18 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLN18 >0  <45    
  ANGLE VTLN18 >45 <90    
}
G.3:CBDB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBDB >0  <45    
  ANGLE CBDB >45 <90    
}
G.3:UBMB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE UBMB >0  <45    
  ANGLE UBMB >45 <90    
}
G.3:RH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RH >0  <45    
  ANGLE RH >45 <90    
}
G.3:RHDMY1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RHDMY1 >0  <45    
  ANGLE RHDMY1 >45 <90    
}
G.3:ESDIMP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ESDIMP >0  <45    
  ANGLE ESDIMP >45 <90    
}
G.3:VARi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VARi >0  <45    
  ANGLE VARi >45 <90    
}
G.3:DVAR { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVAR >0  <45    
  ANGLE DVAR >45 <90    
}
G.3:DMY_S_Pad { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DMY_S_Pad >0  <45    
  ANGLE DMY_S_Pad >45 <90    
}
G.3:DMY_U_Pad { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DMY_U_Pad >0  <45    
  ANGLE DMY_U_Pad >45 <90    
}
G.3:AP_BSL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE AP_BSL >0  <45    
  ANGLE AP_BSL >45 <90    
}
G.3:AP_BSP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE AP_BSP >0  <45    
  ANGLE AP_BSP >45 <90    
}
G.3:CBMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBMi >0  <45    
  ANGLE CBMi >45 <90    
}
G.3:CTMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMi >0  <45    
  ANGLE CTMi >45 <90    
}
G.3:RVi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RVi >0  <45    
  ANGLE RVi >45 <90    
}
G.3:RV_BSL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RV_BSL >0  <45    
  ANGLE RV_BSL >45 <90    
}
G.3:DCOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DCOi >0  <45    
  ANGLE DCOi >45 <90    
}
G.3:DCO_LPPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DCO_LPPi >0  <45    
  ANGLE DCO_LPPi >45 <90    
}
G.3:DCODMY_SCi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DCODMY_SCi >0  <45    
  ANGLE DCODMY_SCi >45 <90    
}
G.3:SRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM >0  <45    
  ANGLE SRM >45 <90    
}
G.3:SRMN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMN >0  <45    
  ANGLE SRMN >45 <90    
}
G.3:SRMP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMP >0  <45    
  ANGLE SRMP >45 <90    
}
G.3:SRMRP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMRP >0  <45    
  ANGLE SRMRP >45 <90    
}
G.3:NPreDOSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NPreDOSRM >0  <45    
  ANGLE NPreDOSRM >45 <90    
}
G.3:ROM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ROM >0  <45    
  ANGLE ROM >45 <90    
}
G.3:SRM_HS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM_HS >0  <45    
  ANGLE SRM_HS >45 <90    
}
G.3:SRAMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY >0  <45    
  ANGLE SRAMDMY >45 <90    
}
G.3:SRAMDMY_PAS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PAS >0  <45    
  ANGLE SRAMDMY_PAS >45 <90    
}
G.3:SRAMDMY_PERI_LP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PERI_LP >0  <45    
  ANGLE SRAMDMY_PERI_LP >45 <90    
}
G.3:SRAMDMY_PERI_G { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PERI_G >0  <45    
  ANGLE SRAMDMY_PERI_G >45 <90    
}
G.3:CO2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CO2 >0  <45    
  ANGLE CO2 >45 <90    
}
G.3:DPSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DPSRM >0  <45    
  ANGLE DPSRM >45 <90    
}
G.3:PRSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PRSRM >0  <45    
  ANGLE PRSRM >45 <90    
}
G.3:SRMLOP12 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP12 >0  <45    
  ANGLE SRMLOP12 >45 <90    
}
G.3:SRMLOP13 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP13 >0  <45    
  ANGLE SRMLOP13 >45 <90    
}
G.3:SRMLOP14 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP14 >0  <45    
  ANGLE SRMLOP14 >45 <90    
}
G.3:LVLOP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LVLOP >0  <45    
  ANGLE LVLOP >45 <90    
}
G.3:HCDPLOP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HCDPLOP >0  <45    
  ANGLE HCDPLOP >45 <90    
}
G.3:TPLOP_8T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TPLOP_8T >0  <45    
  ANGLE TPLOP_8T >45 <90    
}
G.3:TPLOP_10T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TPLOP_10T >0  <45    
  ANGLE TPLOP_10T >45 <90    
}
G.3:RAM1TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RAM1TDMY >0  <45    
  ANGLE RAM1TDMY >45 <90    
}
G.3:OD1T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T >0  <45    
  ANGLE OD1T >45 <90    
}
G.3:OD1TH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1TH >0  <45    
  ANGLE OD1TH >45 <90    
}
G.3:OD1TM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1TM >0  <45    
  ANGLE OD1TM >45 <90    
}
G.3:OD1T_WLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_WLD >0  <45    
  ANGLE OD1T_WLD >45 <90    
}
G.3:OD1T_MOSCAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_MOSCAP >0  <45    
  ANGLE OD1T_MOSCAP >45 <90    
}
G.3:OD1T_CP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_CP >0  <45    
  ANGLE OD1T_CP >45 <90    
}
G.3:OD1T_20 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_20 >0  <45    
  ANGLE OD1T_20 >45 <90    
}
G.3:OD1T_18 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_18 >0  <45    
  ANGLE OD1T_18 >45 <90    
}
G.3:OD1T_16 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_16 >0  <45    
  ANGLE OD1T_16 >45 <90    
}
G.3:CLDD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CLDD >0  <45    
  ANGLE CLDD >45 <90    
}
G.3:EDRAM_DECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE EDRAM_DECAP >0  <45    
  ANGLE EDRAM_DECAP >45 <90    
}
G.3:SNCT { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SNCT >0  <45    
  ANGLE SNCT >45 <90    
}
G.3:CROWN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CROWN >0  <45    
  ANGLE CROWN >45 <90    
}
G.3:P3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE P3 >0  <45    
  ANGLE P3 >45 <90    
}
G.3:CDUDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CDUDMY >0  <45    
  ANGLE CDUDMY >45 <90    
}
G.3:TCDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY >0  <45    
  ANGLE TCDDMY >45 <90    
}
G.3:TCDDMY_H { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY_H >0  <45    
  ANGLE TCDDMY_H >45 <90    
}
G.3:TCDDMY_V { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY_V >0  <45    
  ANGLE TCDDMY_V >45 <90    
}
G.3:ICOVL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ICOVL >0  <45    
  ANGLE ICOVL >45 <90    
}
G.3:LOGO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LOGO >0  <45    
  ANGLE LOGO >45 <90    
}
G.3:TLDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TLDMY >0  <45    
  ANGLE TLDMY >45 <90    
}
G.3:DIODMYi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DIODMYi >0  <45    
  ANGLE DIODMYi >45 <90    
}
G.3:DIO3TDMYi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DIO3TDMYi >0  <45    
  ANGLE DIO3TDMYi >45 <90    
}
G.3:RFDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RFDMY >0  <45    
  ANGLE RFDMY >45 <90    
}
G.3:RFIPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RFIPDMY >0  <45    
  ANGLE RFIPDMY >45 <90    
}
G.3:LUPWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LUPWDMY >0  <45    
  ANGLE LUPWDMY >45 <90    
}
G.3:LUPWDMY_2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LUPWDMY_2 >0  <45    
  ANGLE LUPWDMY_2 >45 <90    
}
G.3:M1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M1i >0  <45    
  ANGLE M1i >45 <90    
}
G.3:DM1_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM1_O >0  <45    
  ANGLE DM1_O >45 <90    
}
G.3:DUM1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM1 >0  <45    
  ANGLE DUM1 >45 <90    
}
G.3:M2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M2i >0  <45    
  ANGLE M2i >45 <90    
}
G.3:DM2_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM2_O >0  <45    
  ANGLE DM2_O >45 <90    
}
G.3:DUM2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM2 >0  <45    
  ANGLE DUM2 >45 <90    
}
G.3:M3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M3i >0  <45    
  ANGLE M3i >45 <90    
}
G.3:DM3_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM3_O >0  <45    
  ANGLE DM3_O >45 <90    
}
G.3:DUM3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM3 >0  <45    
  ANGLE DUM3 >45 <90    
}
G.3:M4i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M4i >0  <45    
  ANGLE M4i >45 <90    
}
G.3:DM4_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM4_O >0  <45    
  ANGLE DM4_O >45 <90    
}
G.3:DUM4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM4 >0  <45    
  ANGLE DUM4 >45 <90    
}
G.3:M5i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M5i >0  <45    
  ANGLE M5i >45 <90    
}
G.3:DM5_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM5_O >0  <45    
  ANGLE DM5_O >45 <90    
}
G.3:DUM5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM5 >0  <45    
  ANGLE DUM5 >45 <90    
}
G.3:M6_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M6_OLD >0  <45    
  ANGLE M6_OLD >45 <90    
}
G.3:M6_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M6_NEW >0  <45    
  ANGLE M6_NEW >45 <90    
}
G.3:DUM6_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM6_OLD >0  <45    
  ANGLE DUM6_OLD >45 <90    
}
G.3:DUM6_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM6_NEW >0  <45    
  ANGLE DUM6_NEW >45 <90    
}
G.3:VIA1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA1i >0  <45    
  ANGLE VIA1i >45 <90    
}
G.3:DVIA1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA1 >0  <45    
  ANGLE DVIA1 >45 <90    
}
G.3:VIA2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA2i >0  <45    
  ANGLE VIA2i >45 <90    
}
G.3:DVIA2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA2 >0  <45    
  ANGLE DVIA2 >45 <90    
}
G.3:VIA3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA3i >0  <45    
  ANGLE VIA3i >45 <90    
}
G.3:DVIA3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA3 >0  <45    
  ANGLE DVIA3 >45 <90    
}
G.3:VIA4i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA4i >0  <45    
  ANGLE VIA4i >45 <90    
}
G.3:DVIA4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA4 >0  <45    
  ANGLE DVIA4 >45 <90    
}
G.3:VIA5_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA5_OLD >0  <45    
  ANGLE VIA5_OLD >45 <90    
}
G.3:VIA5_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA5_NEW >0  <45    
  ANGLE VIA5_NEW >45 <90    
}
G.3:ODi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODi >0  <45    
  ANGLE ODi >45 <90    
}
G.3:ODiRFDRAIN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODiRFDRAIN >0  <45    
  ANGLE ODiRFDRAIN >45 <90    
}
G.3:ODiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODiSRAM >0  <45    
  ANGLE ODiSRAM >45 <90    
}
G.3:DOD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DOD >0  <45    
  ANGLE DOD >45 <90    
}
G.3:SRDOD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRDOD >0  <45    
  ANGLE SRDOD >45 <90    
}
G.3:POi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POi >0  <45    
  ANGLE POi >45 <90    
}
G.3:POiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POiSRAM >0  <45    
  ANGLE POiSRAM >45 <90    
}
G.3:DPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DPO >0  <45    
  ANGLE DPO >45 <90    
}
G.3:SRDPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRDPO >0  <45    
  ANGLE SRDPO >45 <90    
}
G.3:mVTLi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE mVTLi >0  <45    
  ANGLE mVTLi >45 <90    
}
G.3:CPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CPO >0  <45    
  ANGLE CPO >45 <90    
}
G.3:BJT4TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJT4TDMY >0  <45    
  ANGLE BJT4TDMY >45 <90    
}
G.3:BJTDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTDMY >0  <45    
  ANGLE BJTDMY >45 <90    
}
G.3:BJTDMY1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTDMY1 >0  <45    
  ANGLE BJTDMY1 >45 <90    
}
G.3:BJT7TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJT7TDMY >0  <45    
  ANGLE BJT7TDMY >45 <90    
}
G.3:BJTMDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTMDDMY >0  <45    
  ANGLE BJTMDDMY >45 <90    
}
G.3:BJTSNDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTSNDMY >0  <45    
  ANGLE BJTSNDMY >45 <90    
}
G.3:BJT7TDMY_19 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJT7TDMY_19 >0  <45    
  ANGLE BJT7TDMY_19 >45 <90    
}
G.3:BJT7TDMY_33 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJT7TDMY_33 >0  <45    
  ANGLE BJT7TDMY_33 >45 <90    
}
G.3:BJT5TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJT5TDMY >0  <45    
  ANGLE BJT5TDMY >45 <90    
}
G.3:MATCHING_HV { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MATCHING_HV >0  <45    
  ANGLE MATCHING_HV >45 <90    
}
G.3:MATCHING { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MATCHING >0  <45    
  ANGLE MATCHING >45 <90    
}
G.3:MATCHING_S { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MATCHING_S >0  <45    
  ANGLE MATCHING_S >45 <90    
}
G.3:RES50 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RES50 >0  <45    
  ANGLE RES50 >45 <90    
}
G.3:POS1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS1 >0  <45    
  ANGLE POS1 >45 <90    
}
G.3:POS2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS2 >0  <45    
  ANGLE POS2 >45 <90    
}
G.3:POS_OTHERS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS_OTHERS >0  <45    
  ANGLE POS_OTHERS >45 <90    
}
G.3:RMDMY1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY1 >0  <45    
  ANGLE RMDMY1 >45 <90    
}
G.3:RMDMY2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY2 >0  <45    
  ANGLE RMDMY2 >45 <90    
}
G.3:RMDMY3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY3 >0  <45    
  ANGLE RMDMY3 >45 <90    
}
G.3:RMDMY4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY4 >0  <45    
  ANGLE RMDMY4 >45 <90    
}
G.3:RMDMY5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY5 >0  <45    
  ANGLE RMDMY5 >45 <90    
}
G.3:RMDMY6 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMY6 >0  <45    
  ANGLE RMDMY6 >45 <90    
}
G.3:RMDMYAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RMDMYAP >0  <45    
  ANGLE RMDMYAP >45 <90    
}
#IFDEF WLCSP
G.3:CBDi { @ Shapes must be orthogonal or on a 45 degree angle except {CBDi AND Cu_PPI}
  ANGLE CBDi >0  <45    
  ANGLE CBDi >45 <90    
}
G.3:CB2Fi { @ Shapes must be orthogonal or on a 45 degree angle except {CB2Fi AND UBM}
  ANGLE (CB2Fi NOT Cu_PPIi) >0  <45    
  ANGLE (CB2Fi NOT Cu_PPIi) >45 <90    
}
G.3:CB2Wi { @ Shapes must be orthogonal or on a 45 degree angle except {CB2Fi AND UBM}
  ANGLE (CB2Wi NOT Cu_PPIi) >0  <45    
  ANGLE (CB2Wi NOT Cu_PPIi) >45 <90    
}
G.3:PM2i { @ Shapes must be orthogonal or on a 45 degree angle except {PM2i AND UBM} for WLCSP process
  ANGLE (PM2i NOT UBMi) >0  <45    
  ANGLE (PM2i NOT UBMi) >45 <90    
}
#ELSE
G.3:CBDi { @ Shapes must be orthogonal or on a 45 degree angle except {CBDi AND UBM}
  ANGLE (CBDi NOT UBMi) >0  <45    
  ANGLE (CBDi NOT UBMi) >45 <90    
}
G.3:CB2Fi { @ Shapes must be orthogonal or on a 45 degree angle except {CB2Fi AND UBM}
  ANGLE (CB2Fi NOT UBMi) >0  <45    
  ANGLE (CB2Fi NOT UBMi) >45 <90    
}
G.3:CB2Wi { @ Shapes must be orthogonal or on a 45 degree angle except {CB2Fi AND UBM}
  ANGLE CB2Wi >0  <45    
  ANGLE CB2Wi >45 <90    
}
G.3:PMi { @ Shapes must be orthogonal or on a 45 degree angle except {PMi AND UBM}
  ANGLE (PMi NOT UBMi) >0  <45    
  ANGLE (PMi NOT UBMi) >45 <90    
}
#ENDIF
G.3:APi { @ Shapes must be orthogonal or on a 45 degree angle except {APi AND UBM}
  X = ANGLE APi >0  <45    
  Y = ANGLE APi >45 <90    
  (EXPAND EDGE X BY GRID) NOT INTERACT AP_PAD
  (EXPAND EDGE Y BY GRID) NOT INTERACT AP_PAD
}

G.4:PPi { @ Adjacent edges with length less than min. width is not allowed.
  PPia = PPi NOT INSIDE SRAM_REGION
  X = LENGTH PPia < PP_W_1
  PPi_ShortExp = EXPAND EDGE X BY 0.01
  PPi_SmallJog = (VERTEX PPi_ShortExp > 4) NOT INSIDE SRAM_REGION
  PPi INSIDE EDGE PPi_SmallJog
}
G.4:NPi { @ Adjacent edges with length less than min. width is not allowed.
  NPia = NPi NOT INSIDE SRAM_REGION
  X = LENGTH NPia < NP_W_1
  NPi_ShortExp = EXPAND EDGE X BY 0.01
  NPi_SmallJog = (VERTEX NPi_ShortExp > 4) NOT INSIDE SRAM_REGION
  NPi INSIDE EDGE NPi_SmallJog
}
G.4:ODi { @ Adjacent edges with length less than min. width is not allowed.
  ODia = COPY OD
  X = LENGTH ODia < OD_W_1
  ODi_ShortExp = EXPAND EDGE X BY 0.01
  ODi_SmallJog = VERTEX ODi_ShortExp > 4
  ODi INSIDE EDGE ODi_SmallJog
}
G.4:POi { @ Adjacent edges with length less than min. width is not allowed.
  POia = POi NOT INSIDE RAM1TDMY
  X = LENGTH POia < PO_W_1
  POi_ShortExp = EXPAND EDGE X BY 0.01
  POi_SmallJog = (VERTEX POi_ShortExp > 4) NOT INSIDE RAM1TDMY
  POi INSIDE EDGE POi_SmallJog
}
G.4:VTHNi { @ Adjacent edges with length less than min. width is not allowed.
  VTHNia = VTHNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTHNia < VTHN_W_1
  VTHNi_ShortExp = EXPAND EDGE X BY 0.01
  VTHNi_SmallJog = (VERTEX VTHNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTHNi INSIDE EDGE VTHNi_SmallJog
}
G.4:VTHPi { @ Adjacent edges with length less than min. width is not allowed.
  VTHPia = VTHPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTHPia < VTHP_W_1
  VTHPi_ShortExp = EXPAND EDGE X BY 0.01
  VTHPi_SmallJog = (VERTEX VTHPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTHPi INSIDE EDGE VTHPi_SmallJog
}
G.4:VTLNi { @ Adjacent edges with length less than min. width is not allowed.
  VTLNia = VTLNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTLNia < VTLN_W_1
  VTLNi_ShortExp = EXPAND EDGE X BY 0.01
  VTLNi_SmallJog = (VERTEX VTLNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTLNi INSIDE EDGE VTLNi_SmallJog
}
G.4:VTLPi { @ Adjacent edges with length less than min. width is not allowed.
  VTLPia = VTLPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTLPia < VTLP_W_1
  VTLPi_ShortExp = EXPAND EDGE X BY 0.01
  VTLPi_SmallJog = (VERTEX VTLPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTLPi INSIDE EDGE VTLPi_SmallJog
}
G.4:M1i { @ Adjacent edges with length less than min. width is not allowed.
  M1ia = M1i NOT INSIDE SRAM_EXCLUDE
  X = LENGTH M1ia < M1_W_1
  M1i_ShortExp = EXPAND EDGE X BY 0.01
  M1i_SmallJog = (VERTEX M1i_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  M1i INSIDE EDGE M1i_SmallJog
}
G.4:SRDOD { @ Adjacent edges with length less than min. width is not allowed.
  SRDODa = SRDOD NOT INSIDE SRAM_EXCLUDE
  X = LENGTH SRDODa < SRDOD_W_1
  SRDOD_ShortExp = EXPAND EDGE X BY 0.01
  SRDOD_SmallJog = (VERTEX SRDOD_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  SRDOD INSIDE EDGE SRDOD_SmallJog
}
G.4:SRDPO { @ Adjacent edges with length less than min. width is not allowed.
  SRDPOa = SRDPO NOT INSIDE SRAM_EXCLUDE
  X = LENGTH SRDPOa < SRDPO_W_1
  SRDPO_ShortExp = EXPAND EDGE X BY 0.01
  SRDPO_SmallJog = (VERTEX SRDPO_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  SRDPO INSIDE EDGE SRDPO_SmallJog
}
G.4:ULVT_Ni { @ Adjacent edges with length less than min. width is not allowed.
  ULVT_Nia = ULVT_Ni NOT INSIDE SRAM_EXCLUDE
  X = LENGTH ULVT_Nia < ULVT_N_W_1
  ULVT_Ni_ShortExp = EXPAND EDGE X BY 0.01
  ULVT_Ni_SmallJog = (VERTEX ULVT_Ni_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  ULVT_Ni INSIDE EDGE ULVT_Ni_SmallJog
}
G.4:ULVT_Pi { @ Adjacent edges with length less than min. width is not allowed.
  ULVT_Pia = ULVT_Pi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH ULVT_Pia < ULVT_P_W_1
  ULVT_Pi_ShortExp = EXPAND EDGE X BY 0.01
  ULVT_Pi_SmallJog = (VERTEX ULVT_Pi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  ULVT_Pi INSIDE EDGE ULVT_Pi_SmallJog
}
G.4:DCO_LPPi { @ Adjacent edges with length less than min. width is not allowed.
  DCO_LPPa = DCO_LPPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH DCO_LPPa < DCO_LPP_W_1
  DCO_LPPi_ShortExp = EXPAND EDGE X BY 0.01
  DCO_LPPi_SmallJog = (VERTEX DCO_LPPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  DCO_LPPi INSIDE EDGE DCO_LPPi_SmallJog
}
// G.4 is checked by G.4:M2i
G.4:M2i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M2i < M2_W_1
  M2i_ShortExp = EXPAND EDGE X BY 0.01
  M2i_SmallJog = VERTEX M2i_ShortExp > 4
  M2i INSIDE EDGE M2i_SmallJog
}
// G.4 is checked by G.4:M3i
G.4:M3i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M3i < M3_W_1
  M3i_ShortExp = EXPAND EDGE X BY 0.01
  M3i_SmallJog = VERTEX M3i_ShortExp > 4
  M3i INSIDE EDGE M3i_SmallJog
}
// G.4 is checked by G.4:M4i
G.4:M4i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M4i < M4_W_1
  M4i_ShortExp = EXPAND EDGE X BY 0.01
  M4i_SmallJog = VERTEX M4i_ShortExp > 4
  M4i INSIDE EDGE M4i_SmallJog
}
// G.4 is checked by G.4:M5i
G.4:M5i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M5i < M5_W_1
  M5i_ShortExp = EXPAND EDGE X BY 0.01
  M5i_SmallJog = VERTEX M5i_ShortExp > 4
  M5i INSIDE EDGE M5i_SmallJog
}

// Rules G.4:VIAx are unnecessary to check (Covered by rule VIAx.W.1)


USER_GUIDE.M1 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM1
}    
USER_GUIDE.M2 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM2
}    
USER_GUIDE.M3 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM3
}    
USER_GUIDE.M4 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM4
}    
USER_GUIDE.M5 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM5
}    
USER_GUIDE.M6 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM6
}    
USER_GUIDE.VIA1 { @ Via layers with forbidden datatypes.
  COPY NOUSEV1
}    
USER_GUIDE.VIA2 { @ Via layers with forbidden datatypes.
  COPY NOUSEV2
}    
USER_GUIDE.VIA3 { @ Via layers with forbidden datatypes.
  COPY NOUSEV3
}    
USER_GUIDE.VIA4 { @ Via layers with forbidden datatypes.
  COPY NOUSEV4
}    
USER_GUIDE.VIA5 { @ Via layers with forbidden datatypes.
  COPY NOUSEV5
}    


#IFDEF DATATYPE_WARNING
NW_DATATYPE:WARNING { @ Extreme user care needs to be taken when using any layer other than (3;0) that default MT form considers to create NW mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to NW in the MT form to ensure complete fabrication. It is strongly recommended to use NW;drawing (3;0) layer to define NW regions.
  COPY NWiOTHERS
}
OD_DATATYPE:WARNING1 { @ Extreme user care needs to be taken when using any other layer to create OD mask such as pdiff (7;0), ndiff (8;0) or any layer other than (6;0), and (6;1) that default MT form considers. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to OD in the MT form to ensure complete fabrication.  It is strongly recommended to use only OD;drawing (6;0) and OD;dummy (6;1) layers to defined OD and DOD regions.
  COPY ODiOTHERS
}
OD_DATATYPE:WARNING2 { @ SRAM OD (6;11-13) layer are only allowed in SRAM region
  ODiSRAM NOT (SRM OR SRAMDMY)
}
OD_DATATYPE:WARNING3 { @ Layer (6;3) is for recognition purpose of RF devices, please take care if this layer is adopted for non-RF designs and not for masking purpose of diffusion regions together with OD (6;0). 
  ODiRFDRAIN NOT RFDMY
  ODiRFDRAIN AND POi
  ODiRFDRAIN NOT ODi
}
PO_DATATYPE:WARNING1 { @ Extreme user care needs to be taken when using any layer other than (17;0), and (17,1) that default MT form considers to create PO mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to PO in the MT form to ensure complete fabrication. It is strongly recommended to use PO;drawing (17;0) and PO;dummy (17;1) layer to define PO and DPO regions.
  COPY POiOTHERS
}
PO_DATATYPE:WARNING2 { @ SRAM PO (17;11-13) layer are only allowed in SRAM region. 
  POiSRAM NOT (SRM OR SRAMDMY)
}
CO_DATATYPE:WARNING1 { @ Extreme user care needs to be taken when using any layer other than (30;0) that default MT form considers to create CO mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to CO in the MT form to ensure complete fabrication. It is strongly recommended to use CO;drawing (30;0) to define CO regions. 
  COPY COiOTHERS
}
CO_DATATYPE:WARNING2 { @ SRAM CO (30;11-13) layers are only allowed in SRAM region. 
  COiSRAM NOT (SRM OR SRAMDMY)  
}
#ENDIF


#IFDEF FRONT_END


//NW CHECKS
//=========

NW2V = NWEL AND OD2
NW1V = NWEL NOT OD2
NW.W.1 { @ Width, except SRAMDMY >= 0.34 
  A = (INT NWi < NW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION 
  A OUTSIDE SRAM_REGION
  B = A CUT SRAM_REGION
  C = (NWi INTERACT B) NOT SRAM_REGION
  D = INT C < NW_W_1 ABUT < 90 SINGULAR REGION 
  B INTERACT D 
}
NW.S.1 { @ Space >= 0.34 
  (EXT NWEL < NW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.2 { @ Space of 2 NW1V with different potentials (*) >= 0.8 
  NW1V_NODAL = STAMP NW1V BY NWi
  (EXT NW1V_NODAL < NW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.3 { @ NW1V space to NW2V with different potentials (*) >= 1 
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  (EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED) NOT INSIDE SRAM_EXCLUDE
}
NW.S.4 { @ Space of 2 NW2V with different potentials (*) >= 1 
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF NW_SUGGESTED
NW.S.3__NW.S.4:SUGGESTED { @ A more conservative way to check NW.S.3, NW.S.4 with 
		          @ varied operating voltages determination of nwels.
  NW1V = NWEL OUTSIDE OD2
  NW2V = NWEL NOT OUTSIDE OD2
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 NOT CONNECTED SINGULAR REGION
  NW2V_NODAL = STAMP NW2V BY NWi
  EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
#ENDIF


NW.S.5 { @ Space to PW STRAP >= 0.08 
  EXT NWi PPOD < NW_S_5 ABUT < 90 SINGULAR REGION
  PPOD CUT NWi
}


NW.S.6 { @ Space to N+ ACTIVE (except NW resistor) >= 0.08 
  A = NPOD NOT INTERACT RNWEL
  (EXT NWi A < NW_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
  (A CUT NWi) NOT INSIDE SRAM_REGION
}
NW.S.6.1 { @ Space to N+ ACTIVE [at least one edge at each corner] (except NW resistor) >= 0.16 
   NACTx = (NPOD NOT INTERACT RNWEL) NOT NWi 
   OD_CONVEX_CORNER = INT [NACTx] < GRID ABUT == 90 INTERSECTING ONLY 
   NW_CONCAVE_CORNER = EXT [NWi] < (NW_S_6_1-NW_S_6+GRID) ABUT == 90 INTERSECTING ONLY 
   X1 = ANGLE  OD_CONVEX_CORNER == 0
   X2 = ANGLE  NW_CONCAVE_CORNER == 0
   A = EXT [X1] X2 < NW_S_6_1 OPPOSITE EXTENDED NW_S_6
   X3 = ANGLE  OD_CONVEX_CORNER == 90
   X4 = ANGLE  NW_CONCAVE_CORNER == 90
   B = EXT [X3] X4 < NW_S_6_1 OPPOSITE EXTENDED NW_S_6  
   (INT A B < GRID ABUT == 90 INTERSECTING ONLY REGION) NOT INSIDE SRAM_REGION
}

NW.S.7 { @ Space to {N+ ACTIVE INTERACT OD2} >= 0.22 
  EXT NWi NACT2 < NW_S_7 ABUT < 90 SINGULAR REGION
}


NW.EN.1 { @ Enclosure of NW STRAP (except NW resistor) >= 0.08 
  A = NPOD NOT INSIDE SRAM_REGION
  ENC A NONWR < NW_EN_1 ABUT < 90 SINGULAR REGION
}
NW.EN.2 { @ Enclosure of P+ ACTIVE >= 0.08 
   A = PPOD NOT INSIDE SRAM_REGION
   ENC A NONWR < NW_EN_2 ABUT < 90 SINGULAR REGION
}
NW.EN.2.1 { @ Enclosure of P+ ACTIVE [at least one edge at each corner] >= 0.16 
   OD_CONVEX_CORNER = INT [PACT] < GRID ABUT == 90 INTERSECTING ONLY 
   NW_CONVEX_CORNER = INT [NONWR] < (NW_EN_2_1-NW_EN_2+GRID) ABUT == 90 INTERSECTING ONLY 
   X1 = ANGLE OD_CONVEX_CORNER == 0
   X2 = ANGLE NW_CONVEX_CORNER == 0
   A = ENC [X1] X2 < NW_EN_2_1 OPPOSITE EXTENDED NW_EN_2  
   X3 = ANGLE OD_CONVEX_CORNER == 90
   X4 = ANGLE NW_CONVEX_CORNER == 90
   B = ENC [X3] X4 < NW_EN_2_1 OPPOSITE EXTENDED NW_EN_2  
   INT A B < GRID ABUT == 90 INTERSECTING ONLY
}

NW.EN.3 { @ Enclosure of {P+ ACTIVE INTERACT OD2} >= 0.22 
  ENC PACT2 NWi < NW_EN_3 ABUT < 90 SINGULAR REGION
}


NW.A.1 { @ Area >= 0.64 
  AREA NWEL < NW_A_1
}
NW.A.2 { @ Enclosed area >= 0.64 
  A = HOLES NWEL INNER
  B = A NOT NWEL
  (AREA B < NW_A_2) NOT INSIDE SRAM_EXCLUDE
}




//NWROD CHECKS
//=============
NWROD.W.1 { @ Width >= ^NWROD_W_1
  INT RNWEL < NWROD_W_1 ABUT < 90 SINGULAR REGION
}
NWROD.S.1 { @ Space between segments of NW resistor or NW resistor to other NW  ^NWROD_S_1 um
  EXT RNWEL < NWROD_S_1 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < NWROD_S_1 ABUT < 90 SINGULAR REGION 
}  
NWROD.S.2 { @ Space to RPO >= 0.3 
  EXT NWRES RPO < NWROD_S_2 ABUT < 90 SINGULAR REGION
  (NWRES AND RPO) NOT INTERACT NWDMY
  A = RPO INSIDE EDGE NWRES
  EXT A < RPO_W_1 ABUT == 90 REGION INTERSECTING ONLY
}
NWROD.EN.1 { @ Enclosure by OD >= 1 
  ENC NWRES ODWR < NWROD_EN_1 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR
}
NWROD.EN.2 { @ Enclosure of CO >= 0.3 
  X = RHWR AND NWRES	// Terminal
  ENC COWR X < NWROD_EN_2 ABUT < 90 SINGULAR REGION
  COWR NOT X
}
NWROD.O.1 { @ RPO overlap of NP. Use exact value (0.4 um) on sides touching NWDMY = 0.4 
  INT NPWR RPO < NWROD_O_1 ABUT < 90 SINGULAR REGION
  A = RHWR INSIDE EDGE NWEL
  B = EXPAND EDGE A OUTSIDE BY NWROD_O_1
  ((NPWR AND RPO) AND NWRES) NOT B
  RHWR NOT NPWR
}
NWROD.O.2 { @ {OD AND NWDMY} overlap of {NP, PP, VTH_N, VTH_P, VTL_N, or VTL_P} (all implant layers except NW) is not allowed   
  A = OD AND NWDMY
  A AND NP
  A AND PP
  A AND VTHN
  A AND VTHP
  A AND VTLN
  A AND VTLP
}
// NWROD.R.3g is checked by RR:GL:NWROD.R.3__NWRSTI.R.3
NWROD.R.4 { @ Only one NW inside NWROD is allowed in one OD
  A = OD INTERACT (RNWEL AND OD) > 1
  RNWEL INTERACT A
}
NWROD.R.5 { @ Only two NPs in NWROD is allowed in one OD
  A = OD INTERACT NWRES
  B = NP INTERACT NWRES    
  C = A NOT INTERACT B == 2
  NP INTERACT C
}
NWROD.R.6 { @ Only two RPO holes(Salicide) NWROD are allowed in same OD 
  A = OD INTERACT RNWEL
  B = HOLES RPO INNER
  C = A NOT INTERACT B == 2
  RPO INTERACT C
}
NWROD.R.7 { @ For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be parallel to NW edge. DRC can only flag the pattern without OD space while 2 edges of NW [NW space or notch <= 5 um] parallel length > 0 um
  ((EXT RNWEL <= 5 NOTCH OPPOSITE REGION) NOT RNWEL) INSIDE OD
}

//NWRSTI CHECKS
//=============

//NWRSTI.W.1 is checked by NWROD.W.1
//NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.1 { @ NP enclosure of OD >= 0.4 
  ENC ODWR_STI NPWR_STI < NWRSTI_EN_1 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}
NWRSTI.EN.2 { @ OD enclosure of CO >= 0.3 
  X = ODWR_STI AND NWRES_STI	// Terminal
  ENC COWR_STI X < NWRSTI_EN_2 ABUT < 90 SINGULAR REGION
  COWR_STI NOT X
}

// NWRSTI.EN.3 is checked by NWRSTI.EN.2

NWRSTI.EX.1 { @ OD extension on NWRSTI >= 0.3 
  ENC NWRES_STI ODWR_STI < NWRSTI_EX_1 ABUT < 90 SINGULAR REGION
  A = ODWR_STI INSIDE EDGE NWRES_STI
  INT A < OD_W_1 ABUT == 90 REGION INTERSECTING ONLY
  ANGLE A == 45
  (NWRES_STI NOT NWDMY) NOT OD
}
NWRSTI.O.1 { @ {NP INTERACT NWDMY} overlap of {PP, VTH_P, or VTL_P} (all p-type implant layers) is not allowed   
  A = NP INTERACT NWDMY
  A AND PP
  A AND VTHP
  A AND VTLP
}



//NT_N RULES CHECK
//================
 
NTN_OD      = NTN AND OD
NTN_PO      = NTN AND POLY
NTN_GATE_W  = NTN_PO INSIDE EDGE NTN_OD
NTN_2533V_GATE_W = NTN_GATE_W INSIDE EDGE (((OD25 OR OD33) NOT OD2533) NOT OD2518)
NTN_18V_GATE_W   = NTN_GATE_W INSIDE EDGE OD18

NT_N.W.1 { @ Width >= 0.34 
  INT NTN < NTN_W_1 ABUT < 90 SINGULAR REGION
}

#IFDEF GS
NT_N.W.2 { @ Channel length of 0.9V/1.1V/1.2V native device for N45LP/N45LPG/N40G >= 0.3 
  (INT NTN_GATE_W < NTN_W_2 ABUT < 90 REGION) NOT INSIDE VTLN18
}
#ELSE
#IFNDEF HALF_NODE
NT_N.W.2 { @ Channel length of 0.9V/1.1V/1.2V native device for N45LP/N45LPG/N40G >= 0.3 
  (INT NTN_GATE_W < NTN_W_2 ABUT < 90 REGION) NOT INSIDE VTLN18
}
#ELSE
NT_N.W.2.1 { @ Channel length of 1.1V native device only for N40LP/N40LPG >= 0.2 
  (INT NTN_GATE_W < NTN_W_2_1 ABUT < 90 REGION) NOT INSIDE VTLN18
}
#ENDIF
#ENDIF


NT_N.W.3 { @ Channel length of 2.5V/3.3V native device (for 2.5V overdrive to 3.3V, please refer to section OD25_33 Layout Rules) >= 1.2 
  INT NTN_2533V_GATE_W < NTN_W_3 ABUT < 90 REGION
}
NT_N.W.4 { @ Channel length of 1.8V native device (for 2.5V underdrive to 1.8V, please refer to section OD25_18 Layout Rules) >= 0.8 
  (INT NTN_18V_GATE_W < NTN_W_4 ABUT < 90 REGION) NOT INSIDE VTLN18
}
NT_N.W.5 { @ Channel width >= 0.5 
  (LENGTH NTN_GATE_W < NTN_W_5) NOT INSIDE EDGE VTLN18
}
NT_N.S.1 { @ Space >= 0.34 
  EXT NTN < NTN_S_1 ABUT < 90 SINGULAR REGION
}

NTN_exc_ind = COPY NTN

NT_N.S.2 { @ Space to [Active outside NT_N] >= 0.38 
  A = DACT OUTSIDE NTN
  EXT NTN_exc_ind A < NTN_S_2 ABUT < 90 SINGULAR REGION
}

NT_N.S.3 { @ Space to NW >= 1 
  EXT NTN NWi < NTN_S_3 ABUT < 90 SINGULAR REGION

}
NT_N.EN.1 { @ Enclosure range of N+OD = 0.26 
  A = NTN_exc_ind INTERACT NPOD
  B = NPOD INTERACT NTN_exc_ind
  (ENC B A < NTN_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE VTLN18
  (B CUT A) NOT INSIDE VTLN18
  (A NOT (SIZE B BY NTN_EN_1)) NOT INSIDE VTLN18

}
NT_N.EX.1 { @ PO extension on {OD inside NT_N} (PO endcap) >= 0.35 
  A = DACT INSIDE NTN
  ENC A POLY < NTN_EX_1 ABUT < 90 SINGULAR REGION
}
NT_N.A.1 { @ Area >= ^NTN_A_1 um2
  (AREA NTNs < NTN_A_1) NOT INSIDE SRAM_EXCLUDE
}
NT_N.A.2 { @ Enclosed area >= ^NTN_A_2 um2
  A = HOLES NTN INNER
  B = A NOT NTN
  AREA B < NTN_A_2
}


NT_N.R.1 { @ Overlap of {NW OR DNW} is not allowed   
  NTN AND DNW
  NTN AND NWEL
}
NT_N.R.3 { @ Only one OD region is allowed in NT_N 1 Except NMOS capacitor with the same potential, pickup and MOMDMY (155;21) region. 2 You have to draw a NCap_NTN layer to cover the NMOS capacitors. The NCap_NTN enclosure of OD have to be >= 0 um. All the source and drain must be connected together. 3 DRC also flags NCap_NTN and OD, which is outside of the NCap_NTN in the same NT_N   
  A = NTN_exc_ind CUT DACT > 1
  A NOT INTERACT (NCapNTN OR MOMDMY)
  B = A INTERACT NCapNTN
  C = OD INTERACT B
  C NOT NCapNTN  // Mixture of NMOS cap and normal device is not allowed
  NCapNTN NOT NTN // NCapNTN must be fully inside NTN 
  A INTERACT NSDc > 1 BY NET // all source and drain of all Nmos caps in the same NT_N must be connected together
}



NT_N.R.2 { @ P+ ACTIVE region is not allowed in NT_N but PW STRAP is allowed. DRC only can check P+ Gate is not allowed in NT_N   
  GATE_PP AND NTN 
}




//DNW CHECKS
//==========
DNW.W.1 { @ Width >= 3 
  (INT DNW < DNW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.1 { @ Space >= 3.5 
  (EXT DNW < DNW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.2 { @ Space to NW with different potential DRC only checks when NW does not exist in the same DNW >= ^DNW_S_2
  NW_CHK = NWEL NOT TCDDMY  
  (EXT DNW NW_CHK < DNW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.3 { @ Space to {N+ ACTIVE outside DNW} >= 1.65 
  A = NACT OUTSIDE DNW
  EXT DNW A < DNW_S_3 ABUT < 90 SINGULAR REGION
}
RW   = PWEL INSIDE DNW
RW1V = RW OUTSIDE OD2
RW2V = RW NOT OUTSIDE OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi
PWELx = PWEL NOT INSIDE DNW
PWEL_NODAL = STAMP PWELx BY PWELi
DNW.S.4 { @ RW space to {RW OR PW} with different potential >= 0.8 
  (EXT RW1V_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW1V_NODAL PWEL_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.5 { @ {RW OR PW} space to {RW INTERACT OD2} with different potential >= 1 
  (EXT RW2V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL RW1V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL PWEL_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.EN.3 { @ Enclosure of N+ ACTIVE >= 0.48 
  (ENC NACT DNW < DNW_EN_3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.O.1 { @ Overlap of NW >= 0.4 
  (INT DNW NWEL < DNW_O_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}


DNW.R.5 { @ N+ACTIVE cut DNW is not allow
   NACT CUT DNW
}




//OD CHECKS
//=========
OD.W.1 { @ Width >= ^OD_W_1
  (INT OD < OD_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
ODW2_NOTCHECK = SRAM_REGION OR RAM1TDMY

OD.W.2 { @ Channel width of core device >= 0.12 
  LV_GATE_W_C = LV_GATE_W NOT INSIDE EDGE ODW2_NOTCHECK
	LENGTH LV_GATE_W_C < OD_W_2
}

#IFDEF GS
ODW21_NOTCHECK = (((LOGO OR VAR) OR NTN) OR TCDDMY) OR SRESD  
ODW21_LV_GATE_W_C =  (LV_GATE_W NOT INSIDE EDGE ODW21_NOTCHECK) INSIDE EDGE NP
#ELSE
ODW21_NOTCHECK = ((LOGO OR VAR) OR NTN) OR TCDDMY
ODW21_LV_GATE_W_C =  ((LV_GATE_W NOT INSIDE EDGE ODW21_NOTCHECK) INSIDE EDGE NP) INSIDE EDGE DCO
#ENDIF
// OD.W.2.1GS is checked by OD.W.2.1
OD.W.2.1 { @ Maximum channel width of core NMOS device for GS and LPG G device <= 10 (This rule doesn't include the NT_N, SR_ESD,LOGO, TCDDMY, and VAR)
  LENGTH ODW21_LV_GATE_W_C > OD_W_2_1
}
#IFDEF GS
// OD.W.2.2GS is checked by OD.W.2.2
ODW22_NOTCHECK = ((LOGO OR VAR) OR NTN) OR TCDDMY
OD.W.2.2 { @ Maximum channel width for core PMOS device for GS <= 1.5 (This rule doesn't include the NT_N, LOGO, TCDDMY, and VAR)
  LV_GATE_W_C = (LV_GATE_W NOT INSIDE EDGE (ODW22_NOTCHECK OR ICOVL)) INSIDE EDGE PP
  LENGTH LV_GATE_W_C > OD_W_2_2
}
#ENDIF

OD.W.3 { @ Channel width of MOS [for I/O device] >= ^OD_W_3
  LENGTH HV_GATE_W < OD_W_3
}

OD_EDGE_45 = OD ANGLE == 45

OD.W.4 { @ Min. width of 45 degree bent OD ^OD_W_4 um
  INT OD_EDGE_45 < OD_W_4 ABUT < 90 REGION
}

OD.S.1 { @ Space >= ^OD_S_1
  (EXT OD < OD_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
HV_OD_E = OD INSIDE EDGE OD2
OD.S.2 { @ Space (inside OD2) >= ^OD_S_2 um	
  EXT HV_OD_E < OD_S_2 ABUT < 90 REGION
}

Wide_OD_0.12 = OD WITH WIDTH > OD_S_3_W 

OD.S.3 { @ Space to OD [width > 0.12 um] if the parallel run length >= 0.14 um (P) >= 0.1 
  OD_SPACE = (EXT Wide_OD_0.12 OD < OD_S_3 OPPOSITE REGION MEASURE ALL) NOT WITH EDGE GATE_L
  (ENCLOSE RECTANGLE OD_SPACE OD_S_1 OD_S_3_L) NOT INSIDE SRAM_REGION    
} 
OD.S.3.1 { @ Space to OD [width > 0.12 um] if the parallel run length >= 0.14 um (P1) in PO gate direction >= 0.11 
  OD_SPACE = (EXT Wide_OD_0.12 OD < OD_S_3_1 OPPOSITE REGION MEASURE ALL) WITH EDGE GATE_L
  (ENCLOSE RECTANGLE OD_SPACE OD_S_1 OD_S_3_1_L) NOT INSIDE SRAM_REGION   
}

OD.S.4 { @ Space to 45-degree bent OD >= 0.17 
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY OD_S_4
  X AND OD
}  
OD.S.5 { @ Space between 2 segments of a U-shape or an O-shape OD (notch only) >= 0.15 
  CONVEX EDGE OD ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < OD_S_5
}
OD.A.1 { @ Area (This check doesn't include the patterns filling 0.06 um x 0.26 um rectangular tiles) >= 0.035 
  A = AREA ((ODs NOT INSIDE SRAM_REGION) NOT OD_DMY) < OD_A_1
  NOT ENCLOSE RECTANGLE A OD_A_1_W OD_A_1_L ORTHOGONAL ONLY
}
OD.A.2 { @ Area [with all of edge lengths < 0.21 um] >= 0.055 
  A = AREA (ODs NOT INSIDE SRAM_REGION) < OD_A_2
  B = LENGTH A >= OD_A_2_L
  A NOT WITH EDGE B
}
OD.A.3 { @ Enclosed area >= 0.04 
  A = HOLES ODs INNER
  B = A NOT ODi
  (AREA B < OD_A_3) NOT INSIDE SRAM_EXCLUDE
}
OD.A.4 { @ Enclosed area [with all of inner edge lengths < 0.21 um] >= 0.077 
  A = HOLES ODs INNER
  B = A NOT ODi
  C = LENGTH B >= OD_A_4_L
  D = B NOT WITH EDGE C
  (AREA D < OD_A_4) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF GS
CORE_PACT = PACTi NOT OD2
ODRX = (SIZE ((SIZE GATEi BY OD_A_5_S1-OD_A_5_S2) AND CORE_PACT) BY OD_A_5_S2) AND CORE_PACT
CONNECT ODRX
// OD.A.5.GS is checked by OD.A.5
OD.A.5 { @ Maximum ACTIVE area sum of ((checking Area INTERACT PO) NOT (PO OR SR_DPO)) in same checking Area <= 300. Checking area is defined by size 0.22um in S/D direction and 0.08um in endcap direction from gate
   A = (ODRX INTERACT POi) NOT (POi OR SRDPO) 
   Ac = STAMP A BY ODRX    
   NET AREA RATIO ODRX Ac > OD_A_5 [AREA(Ac)] RDB OD.A.5.rep
}
#ENDIF

OD.L.1 { @ Maximum length of {ACTIVE (source) [width < 0.12 um] interacts with butted_STRAP} if no CO in M region <= 0.4 
  BUTTED_EDGE = LENGTH NP_PP_BTE < OD_L_1_W
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD_pre = INT (CHECK_SD COIN INSIDE EDGE OD) < OD_L_1_W ABUT < 90 OPPOSITE REGION
  NARROW_SD = NARROW_SD_pre NOT ENCLOSE CO
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > OD_L_1
} 
// OD.L.1.S is checked by OD.L.1
OD.L.2 { @ Max. OD length between 2 CO or CO to OD line end when OD width <= ^OD_L_2_W um  ^OD_L_2 um
  OD_CHECK = (INOD NOT RFIP) NOT (SIZE MOMDMY BY 1.2)
  LONGP = AREA OD_CHECK > OD_W_1 * OD_L_2	
  X = LONGP INTERACT COOD
  CHECK_COOD = COOD INTERACT X
  A = SIZE CHECK_COOD BY OD_L_2 / 2 INSIDE OF X STEP OD_S_1*0.7
  LINEN = X INTERACT A == 1
  P2P = X INTERACT A > 1
  B = A INTERACT LINEN
  C = SIZE B BY OD_L_2 / 2 INSIDE OF LINEN STEP OD_S_1*0.7
  BAD = (LINEN NOT C) OR (P2P NOT A)
  BAD_EDGE = BAD COIN INSIDE EDGE OD
  ERR = INT BAD_EDGE < OD_L_2_W ABUT < 90 REGION
  X INTERACT ERR
}
// OD.L.2.S is checked by OD.L.2

OD.R.1 { @ OD must be fully covered by {NP OR PP} except for {(DOD OR SR_DOD) OR NWDMY}   
  ((OD NOT INTERACT NWRES) NOT LOGO) NOT IMP
}









//DUMMY OD RULE
//================

DOD.W.1 { @ Width >= 0.5 
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space >= 0.4 
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD (Overlap is not allowed) >= 0.34 
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.3 { @ Space to PO (Overlap is not allowed) >= 0.3 
  EXT POi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.5 { @ Space to NW >= 0.3 
  EXT NWi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION 
}
DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= 0.6 
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD
}
DOD.EN.1 { @ Enclosure by NW (Cut is not allowed) >= 0.3 
  ENC DOD NWi < DOD_EN_1 ABUT < 90 SINGULAR REGION
  DOD CUT NWi
}

#IFDEF FULL_CHIP 

DOD.R.1 { @ DOD is must. DOD must be an individual CAD layer (datatype 1 as default, like 6;1)
  CHIPx NOT INTERACT DOD
}
#ENDIF

// DOD.R.2 is checked by CSR.R.1:DOD

DOD.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed   
  NOT RECTANGLE DOD ORTHOGONAL ONLY
}

// OD.DN.0 is checked by [OD.DN.2, OD.DN.2.1, OD.DN.2.2, OD.DN.3, OD.DN.3.1, and OD.DN.3.2]

#IFDEF FULL_CHIP
OD.DN.1 { @ {OD OR DOD} density across full chip >= 25%
  DENSITY ALL_OD CHIP < OD_DN_1 INSIDE OF LAYER CHIPx [ AREA(ALL_OD)/AREA(CHIP) ] PRINT OD.DN.1.density
}
OD.DN.1.1 { @ {OD OR DOD} density across full chip <= 75%
  DENSITY ALL_OD CHIP > OD_DN_1_1 INSIDE OF LAYER CHIPx [ AREA(ALL_OD)/AREA(CHIP) ] PRINT OD.DN.1.1.density
}
#ENDIF

OD_EXC = NWDMY OR DEN_EXC_LOW
ODx = ALL_OD NOT OD_EXC
CHIP_NOT_ODEXC = CHIP NOT OD_EXC

#IFDEF CHECK_LOW_DENSITY
OD.DN.2 { @ Min. OD density over window 150 step 75 >= 20% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2_E
  DENSITY F ODx CHIP_NOT_ODEXC < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.density
          [ !AREA(F)+AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}
#ENDIF

OD.DN.2.2 { @ Max. OD density over window 150 step 75 <= 90% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_2_2 WINDOW OD_DN_2_2_W STEP OD_DN_2_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2_2_E
  DENSITY F ODx CHIP_NOT_ODEXC > OD_DN_2_2 WINDOW OD_DN_2_2_W STEP OD_DN_2_2_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.2.density
  [ !!AREA(F)*AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}

ODx_MAX_CORE = ODx NOT OD2
CHIP_MAX_CORE = CHIP_NOT_ODEXC NOT OD2

OD.DN.2.1 { @ Max. OD density over window 150 step 75 <= 80% in core 
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE ALL_OD CHIP > OD_DN_2_1 WINDOW OD_DN_2_1_W STEP OD_DN_2_1_S INSIDE OF LAYER CHIPx BACKUP
           [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE)*!~(AREA(ALL_OD)/AREA(CHIP)-OD_DN_2_1) ]
  F = WITH WIDTH ((ERR_WIN NOT OD2) NOT OD_EXC) >= OD_DN_2_1_E 
  DENSITY F ODx_MAX_CORE CHIP_MAX_CORE ALL_OD CHIP > OD_DN_2_1 WINDOW OD_DN_2_1_W STEP OD_DN_2_1_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.1.density
  [!!AREA(F)*AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE)*!~(AREA(ALL_OD)/AREA(CHIP)-OD_DN_2_1) ]
}

CHIP_ODBLK = CHIP_NOT_ODEXC AND ODBLK
OD_ODBLK = ODx AND ODBLK
CHIP_ODBLKx = COPY CHIP_ODBLK
OD.DN.3 { @ Min. OD density over window 150 step 75 >= 20% (within ODBLK)
    ERR_WIN1 = DENSITY OD_ODBLK CHIP_ODBLK < OD_DN_3 WINDOW OD_DN_3_W STEP OD_DN_3_S INSIDE OF LAYER CHIP_ODBLKx BACKUP PRINT OD.DN.3.density [AREA(OD_ODBLK)/AREA(CHIP_ODBLK)]

    ERR_WIN2 = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_3 WINDOW OD_DN_3_W STEP OD_DN_3_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
    ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
    ((ERR_WIN AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_E

}

OD.DN.3.2 { @ Max. OD density over window 150 step 75 <= 90% (within ODBLK)
   ERR_WIN1 = DENSITY OD_ODBLK CHIP_ODBLK > OD_DN_3_2 WINDOW OD_DN_3_2_W STEP OD_DN_3_2_S INSIDE OF LAYER CHIP_ODBLKx BACKUP PRINT OD.DN.3.2.density [AREA(OD_ODBLK)/AREA(CHIP_ODBLK)]
   ERR_WIN2 = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_3_2 WINDOW OD_DN_3_2_W STEP OD_DN_3_2_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
   ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
   ((ERR_WIN AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_2_E
}

ODx_MAX_CORE_ODBLK = OD_ODBLK NOT OD2
CHIP_MAX_CORE_ODBLK = CHIP_ODBLK NOT OD2
OD.DN.3.1 { @ Max. OD density over window 150 step 75 <= 80% in core (within ODBLK)
   ERR_WIN1 = DENSITY ODx_MAX_CORE_ODBLK > OD_DN_3_1 WINDOW OD_DN_3_1_W STEP OD_DN_3_1_S INSIDE OF LAYER CHIP_MAX_CORE_ODBLK BACKUP PRINT OD.DN.3.1.density
   ERR_WIN2 = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_3_1 WINDOW OD_DN_3_1_W STEP OD_DN_3_1_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
   ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
	(((ERR_WIN NOT OD2) AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_1_E
}



//SR_DOD CHECKS
//=============

SR_DOD.W.1 { @ Width >= 0.1 
  INT SRDOD < SRDOD_W_1 ABUT < 90 SINGULAR REGION
}
SR_DOD.W.2 { @ Maximum width 0.5  
  A = INT SRDOD <= SRDOD_W_2 ABUT < 90 REGION
  SRDOD NOT A
}
SR_DOD.S.1 { @ Space >= 0.12 
  EXT SRDOD < SRDOD_S_1 ABUT < 90 SINGULAR REGION
}
SR_DOD.S.1.1 { @ Space to OD, DOD (Overlap is not allowed) >= 0.12 
  EXT SRDOD ODi < SRDOD_S_1_1 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDOD DOD < SRDOD_S_1_1 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.2 { @ Space to PO (Overlap is not allowed) >= 0.05 
  EXT SRDOD POi < SRDOD_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.3 { @ Space to DPO, SR_DPO (Overlap is not allowed) >= 0.03 
  EXT SRDOD DPO < SRDOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDOD SRDPO < SRDOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.4 { @ Space to 45-degree bent OD >= 0.17 
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY SRDOD_S_4
  X AND SRDOD
}
SR_DOD.S.7 { @ Space to NW (for both core and I/O) >= 0.08 
  EXT SRDOD NWi < SRDOD_S_7 ABUT < 90 SINGULAR REGION
}
SR_DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= 0.6 
  EXT SRDOD NWDMY < SRDOD_S_8 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.9 { @ Space to LOGO (Overlap is not allowed) >= 0 
  SRDOD AND LOGO
}
SR_DOD.S.11 { @ Space to NT_N (Overlap is not allowed) >= 0.14 
  EXT SRDOD NTNi < SRDOD_S_11 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.EN.1 { @ NW enclosure of SR_DOD (for both core and I/O) >= 0.08 
  ENC SRDOD NWi < SRDOD_EN_1 ABUT < 90 SINGULAR REGION
  SRDOD CUT NWi
}

SR_DOD.A.1 { @ Area >= 0.05 
  AREA SRDOD < SRDOD_A_1
}    

SR_DOD.L.1 { @ Length >= 0.5 
  NOT ENCLOSE RECTANGLE SRDOD SRDOD_L_1 GRID ORTHOGONAL ONLY
}
SR_DOD.L.2 { @ Maximum length <= 10 
  ENCLOSE RECTANGLE SRDOD SRDOD_L_2+GRID GRID ORTHOGONAL ONLY
}

SR_DOD.R.1 { @ 45-degree bent SR_DOD is not allowed   
  SRDOD ANGLE == 45
}
SR_DOD.R.2 { @ Overlap of CO is not allowed   
  SRDOD AND CO
}
SR_DOD.R.3 { @ Only rectangle is allowed   
  NOT RECTANGLE SRDOD
}
// SR_DOD.R.4gU can not be checked by DRC


//THICK OXIDE CHECKS
//==================
OD2.W.1 { @ Width >= 0.34 
  INT OD18 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD25 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD33 < OD2_W_1 ABUT < 90 SINGULAR REGION
} 
OD2.W.2 { @ Width of {OD2 OR {NW OR NT_N}} >= 0.34 
  Y = OD2i OR NTNi
  X = NWi OR Y
  A = (INT X < OD2_W_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
  (A OUTSIDE SRAM_REGION) INTERACT Y 
  B = A CUT SRAM_REGION
  C = (X INTERACT B) NOT SRAM_REGION
  D = INT C < OD2_W_2 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT Y 
}

OD2.W.3 { @ Width of {OD2 NOT {NW OR NT_N}}, except {{OD2 NOT {NW OR NT_N}} [width < 0.34 um] NOT INTERACT OD} and LOGO regions >= 0.34 
  X = OD2i NOT (NWi OR NTNi)
  Y = SIZE X BY OD2_W_3/2-0.002 UNDEROVER
  Z = (X NOT Y) INTERACT ODi
  Z NOT LOGO
}

OD2.S.1 { @ Space >= 0.34 
  EXT OD2 < OD2_S_1 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ OD2 space to {ACTIVE OR GATE} >= ^OD2_S_2 um, OD / ACTIVE cut OD2 is not allowed 
  DACTG = DACT OR GATE  
  EXT OD2 DACTG < OD2_S_2 ABUT < 90 SINGULAR REGION
  DACTG CUT OD2
}
OD2.S.3 { @ Space to 0.9V/1.2V GATE in S/D direction >= 0.25 
  A = OD2 INSIDE EDGE OD  
  EXT A GATE_W < OD2_S_3 ABUT < 90 REGION
  GATE CUT OD2
  B = LV_GATE_W INSIDE EDGE VAR
  EXT B OD2 < OD2_S_3 ABUT < 90 OPPOSITE REGION
}
OD2.S.4 { @ Space to NW. Space = 0 um is allowed >= 0.34 
  EXT OD18 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD25 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD33 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
}
OD2.S.5 { @ Space of {NW NOT OD2} >= 0.34 
  X = NWi NOT OD2i
  (EXT X < OD2_S_5 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.6 { @ Space of {NW AND OD2} >= 0.34 
  X = NWi AND OD2i
  (EXT X < OD2_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.7 { @ Space of {OD2 NOT {NW OR NT_N}} >= 0.34 
  X = OD2i NOT (NWi OR NTNi)	
  (EXT X < OD2_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.8 { @ Space of {OD2 OR {NW OR NT_N}}, except {{OD2 OR {NW OR NT_N}} [space < 0.34 um] NOT INTERACT OD} and LOGO regions >= 0.34 
  X = OD2i OR (NWi OR NTNi)
  Y = SIZE X BY OD2_S_8/2-0.002 OVERUNDER
  Z = (Y NOT X) INTERACT ODi
  (Z NOT INSIDE SRAM_REGION) NOT LOGO
}
OD2.EN.1 { @ Enclosure of 1.8V/2.5V/3.3V Gate in S/D direction >= 0.25 
  ENC GATE_W OD18 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  ENC GATE_W OD25 < OD2_EN_1 ABUT < 90 OPPOSITE REGION    
  ENC GATE_W OD33 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
}
OD2.EX.1 { @ NW extension on OD2. Extension = 0 um is allowed >= 0.34 
  ENC OD18 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD25 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD33 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.2 { @ Extension on NW. Extension = 0 um is allowed >= 0.34 
  ENC NWEL OD18 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD25 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD33 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on {ACTIVE OR GATE} >= 0.2 
   DACTG = DACT OR GATE  
   CHECK_EDGE = ENC [DACTG] OD2 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE NOT COIN OUTSIDE EDGE DSTP
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 um is allowed >= 0.34 
  X = OD18 AND NWEL
  INT X < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Y = OD25 AND NWEL
  INT Y < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Z = OD33 AND NWEL
  INT Z < OD2_O_1 ABUT < 89.5 SINGULAR REGION
}

OD2.R.1 { @ OD_18, OD_25, and OD_33 can't be used on the same die   
  X = CHIP INTERACT OD25
  X INTERACT OD18
  X INTERACT OD33
  Y = CHIP INTERACT OD33
  Y INTERACT OD18
}




//DCO CHECKS
//==========

DCO.W.1 { @ Width >= 0.34 
  (INT DCOs < DCO_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.W.2 { @ Width of {DCO OR NW}, except SRAMDMY >= 0.34 
  X = NWEL OR DCOs
  A = (INT X < DCO_W_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
  (A OUTSIDE SRAM_REGION) INTERACT DCOs
  B = A CUT SRAM_REGION
  C = (X INTERACT B) NOT SRAM_REGION
  D = INT C < DCO_W_2 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT DCOs
}
DCO.S.1 { @ Space >= 0.34 
  (EXT DCOs < DCO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.S.2 { @ Space to ACTIVE >= 0.05 
  EXT DCO DACT < DCO_S_2 ABUT < 90 SINGULAR REGION
}
DCO.S.3__DCO.S.4 { @ Space to LP(core 1.1V) gate in S/D direction >= ^DCO_S_3 
            @ Space to LP(core 1.1V) gate in end-cap direction >= ^DCO_S_4             
  A = GATE NOT INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_S_3 - DCO_S_4 )) OR A
  C = SIZE B BY DCO_S_4
  C AND DCO
}
DCO.S.5 { @ Space to NW. Space = 0 is allowed >= 0.34 
  EXT DCO NWEL < DCO_S_5 ABUT < 90 > 0 SINGULAR REGION
}
DCO.S.6 { @ Space to OD2. Space = 0 is allowed >= 0.34 
  EXT DCO OD2 < DCO_S_6 ABUT < 90 > 0 SINGULAR REGION
}
DCO.S.8 { @ Space of {DCO NOT NW} >= 0.34 
  (EXT (DCOs NOT NWEL) < DCO_S_8 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
DCO.S.9 { @ Space of {DCO AND NW} >= 0.34 
  (EXT (DCOs AND NWEL) < DCO_S_9 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.S.10 { @ Space of {NW NOT DCO} >= 0.34 
  (EXT (NWEL NOT DCOs) < DCO_S_10 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.EN.1__DCO.EN.2 { @ Enclosure of G(core 0.9V) gate in S/D direction >= ^DCO_EN_1 
             @ Enclosure of G(core 0.9V) gate in end-cap direction >= ^DCO_EN_2  
  A = GATE INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_EN_1 - DCO_EN_2 )) OR A
  C = SIZE B BY DCO_EN_2
  C NOT DCO
}
DCO.EX.1 { @ NW extension on DCO. Extension = 0 is allowed >= 0.34 
  ENC DCO NWEL < DCO_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.2 { @ Extension on NW. Extension = 0 is allowed >= 0.34 
  ENC NWEL DCO < DCO_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.3 { @ Extension on ACTIVE [Cut is not allowed if without Gate] >= 0.05 
  ENC DACT DCO < DCO_EX_3 ABUT < 90 SINGULAR REGION
  (DACT NOT INTERACT GATE) CUT DCO
}
DCO.A.1 { @ Area >= 0.7 
  (AREA DCOs < DCO_A_1) NOT INSIDE SRAM_EXCLUDE
}
DCO.A.2 { @ Enclosed area >= 0.7 
  A = HOLES DCOs INNER
  B = A NOT DCOs
  (AREA B < DCO_A_2) NOT INSIDE SRAM_EXCLUDE
}
DCO.O.1 { @ Overlap of NW. Overlap = 0 is allowed >= 0.34 
  X = DCOs AND NWEL
  (INT X < DCO_O_1 ABUT < 89.5 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
DCO.R.2 { @ Overlap of OD2 is not allowed   
  DCO AND OD2
}
DCO.R.3 { @ RH cut DCO is no allowed.
   RH CUT DCO
}


//OD2 CHECKS
//============
OD2.R.2.LPP { @ Only OD_25 is allowed for N40LP+
	A = CHIP INTERACT DCO_LPP
	A INTERACT OD18i
	A INTERACT OD33i
}


//DCO_LPP CHECKS
//==========

DCO_LPP_R = DCO_LPPs AND DCODMY_SC

// waive one track overlap 	  
DCO_LPP_A1 = INT DCO_LPPs < DCO_LPP_W_1 ABUT < 90 REGION PROJ==0
DCO_LPP_B1 = DCO_LPP_R NOT (EXPAND EDGE DCO_LPP_R INSIDE BY DCO_LPP_R_5/2)
DCO_LPP_B1_1 = DCO_LPP_R NOT (EXPAND EDGE DCO_LPP_R INSIDE BY DCO_LPP_R_5)
DCO_LPP_B1_2 = DCO_LPP_R NOT (EXPAND EDGE DCO_LPP_R INSIDE BY DCO_LPP_R_5_2/2)

DCO_LPP_C1 = EXT DCO_LPP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
DCO_LPP_C1_1 = EXT DCO_LPP_B1_1 < GRID SINGULAR INTERSECTING ONLY REGION
DCO_LPP_C1_2 = EXT DCO_LPP_B1_2 < GRID SINGULAR INTERSECTING ONLY REGION

DCO_LPP_D1 = DCO_LPP_A1 ENCLOSE DCO_LPP_C1
DCO_LPP_D1_1 = DCO_LPP_A1 ENCLOSE DCO_LPP_C1_1
DCO_LPP_D1_2 = DCO_LPP_A1 ENCLOSE DCO_LPP_C1_2

DCO_LPP_E1 = (DCO_LPP_D1 OR DCO_LPP_D1_1) OR DCO_LPP_D1_2
// waive one track space
DCO_LPP_A2 = EXT DCO_LPPs < DCO_LPP_S_1 ABUT < 90 REGION PROJ==0
DCO_LPP_B2 = DCO_LPP_R OR (EXPAND EDGE DCO_LPP_R OUTSIDE BY DCO_LPP_R_5/2)
DCO_LPP_B2_1 = DCO_LPP_R OR (EXPAND EDGE DCO_LPP_R OUTSIDE BY DCO_LPP_R_5)
DCO_LPP_B2_2 = DCO_LPP_R OR (EXPAND EDGE DCO_LPP_R OUTSIDE BY DCO_LPP_R_5_2/2)

DCO_LPP_C2 = EXT DCO_LPP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
DCO_LPP_C2_1 = EXT DCO_LPP_B2_1 < GRID SINGULAR INTERSECTING ONLY REGION
DCO_LPP_C2_2 = EXT DCO_LPP_B2_2 < GRID SINGULAR INTERSECTING ONLY REGION

DCO_LPP_D2  = DCO_LPP_A2 ENCLOSE DCO_LPP_C2
DCO_LPP_D2_1  = DCO_LPP_A2 ENCLOSE DCO_LPP_C2_1
DCO_LPP_D2_2  = DCO_LPP_A2 ENCLOSE DCO_LPP_C2_2

DCO_LPP_E2 = (DCO_LPP_D2 OR DCO_LPP_D2_1) OR DCO_LPP_D2_2
// waive point touch
DCO_LPP_P = EXT DCO_LPP_R < DCO_LPP_S_1 SINGULAR INTERSECTING ONLY REGION



DCO_LPP.W.1 { @ Width >= ^DCO_LPP_W_1. One-track(^DCO_LPP_R_5) overlap is allowed
  X = INT DCO_LPPs < DCO_LPP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT DCO_LPP_E1)) NOT INSIDE SRAM_EXCLUDE
}
DCO_LPP.S.1 { @ Space >= ^DCO_LPP_S_1. Point touch of corners is allowed. One-track(^DCO_LPP_R_5) space is allowed.
  X = EXT DCO_LPPs < DCO_LPP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (DCO_LPP_E2 OR DCO_LPP_P))) NOT INSIDE SRAM_EXCLUDE
}
DCO_LPP.S.2 { @ Space to ACTIVE >= ^DCO_LPP_S_2
  EXT DCO_LPP DACT < DCO_LPP_S_2 ABUT < 90 SINGULAR REGION
}
DCO_LPP.S.3__DCO_LPP.S.4 { @ Space to {Gate NOT INTERACT (OD2 OR DCO_LPP)} in S/D direction >= ^DCO_LPP_S_3 
            @ Space to {Gate NOT INTERACT (OD2 OR DCO_LPP)} in end-cap direction >= ^DCO_LPP_S_4             
  A = GATE NOT INTERACT (DCO_LPP OR OD2)
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_LPP_S_3 - DCO_LPP_S_4 )) OR A
  C = SIZE B BY DCO_LPP_S_4
  C AND DCO_LPP
}
DCO_LPP.S.6 { @ Space to OD2 (Space = 0 is allowed) >= ^DCO_LPP_S_6 
  EXT DCO_LPP OD2 < DCO_LPP_S_6 ABUT < 90 > 0 SINGULAR REGION
}
DCO_LPP.EN.1__DCO_LPP.EN.2 { @ Enclosure of 1.1V gate in S/D direction >= ^DCO_LPP_EN_1 
             @ Enclosure of 1.1V gate in end-cap direction >= ^DCO_LPP_EN_2  
  A = GATE INTERACT DCO_LPP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_LPP_EN_1 - DCO_LPP_EN_2 )) OR A
  C = SIZE B BY DCO_LPP_EN_2
  C NOT DCO_LPP
}
DCO_LPP.EX.3 { @ Extension on Active >= ^DCO_LPP_EX_3, [Cut is not allowed if without gate]
               @ Cut ACTIVE of TSMC N40LP+ standard cell(90;2, DCODMY_SC) is allowed.
  ENC DACT DCO_LPP < DCO_LPP_EX_3 ABUT < 90 SINGULAR REGION
  A = (DACT NOT INTERACT GATE) CUT DCO_LPP
	A NOT INTERACT DCODMY_SC
}
DCO_LPP.A.1 { @ Area >= ^DCO_LPP_A_1, except DCO_LPP.A.1.1
  ((AREA DCO_LPPs < DCO_LPP_A_1) NOT (AREA DCO_LPP_R < DCO_LPP_A_1)) NOT INSIDE SRAM_EXCLUDE
}
DCO_LPP.A.1.1 { @ Area[Width >= 0.42um] >= ^DCO_LPP_A_1_1 for only TSMC N40LP+ standard cell(90;2, DCODMY_SC)
  A = DCO_LPP_R NOT (DCO_LPP_R WITH WIDTH >= 0.42)
  AREA A < DCO_LPP_A_1
  AREA DCO_LPP_R < DCO_LPP_A_1_1 
}
DCO_LPP.A.2 { @ Enclosed Area >= ^DCO_LPP_A_2, except DCO_LPP.A.1.2
  A = HOLES DCO_LPPs INNER
  B = A NOT DCO_LPPs
  C = HOLES DCO_LPP_R INNER
  D = C NOT DCO_LPP_R
  ((AREA B < DCO_LPP_A_2) NOT (AREA D < DCO_LPP_A_2)) NOT INSIDE (SRAM_EXCLUDE OR DCODMY_SC)
}
DCO_LPP.A.2.1 { @ Enclosed Area[Width >= 0.42um] >= ^DCO_LPP_A_1_1 for only N40LP+ standard cell(90;2), DCODMY_SC
  A = HOLES DCO_LPPs INNER
  B = A NOT DCO_LPPs
  C = HOLES DCO_LPP_R INNER
  D = C NOT DCO_LPP_R
  E = D NOT (D WITH WIDTH >= 0.42)
  AREA E < DCO_LPP_A_2
  AREA D < DCO_LPP_A_2_1
}
DCO_LPP.R.1 { @ Overlap of VAR, VTL_N, VTL_P, VTH_N, VTH_P, NT_N, TCDDMY, SRM, ROM, or OD2 is not allowed   

  DCO_LPP AND VAR
  DCO_LPP AND VTLN
  DCO_LPP AND VTLP
  DCO_LPP AND VTHN
  DCO_LPP AND VTHP
  DCO_LPP AND NTN
  DCO_LPP AND TCDDMY
  DCO_LPP AND SRM
  DCO_LPP AND ROM
  DCO_LPP AND OD2
}
DCO_LPP.R.2 { @ DCO_LPP cut RH is no allowed.
  RH CUT DCO_LPP
}
DCO_LPP.R.3 { @ (Gate AND DCO_LPP) must be covered by (ULVT_N OR ULVT_P)
  (GATE AND DCO_LPP) NOT (ULVT_N OR ULVT_P)
}

DCO_LPP.R.6 { @ If DCODMY_SC exists, DCODMY must be identical to DCO_LPP. DCODMY_SC can't exist without DCO_LPP. DCO_LPP can exist without DCODMY_SC
  (DCO_LPPs INTERACT DCODMY_SC) XOR (DCODMY_SC INTERACT DCO_LPPs)
  DCODMY_SC NOT INTERACT DCO_LPPs
}

// DCO_LPP.R.4 is checked by DCO_LPP.W.1 and DCO_LPP.S.1
// DCO_LPP.R.5 is checked by DCO_LPP.W.1 and DCO_LPP.S.1

//ULVT_N CHECKS
//============
ULVT_N_R = COPY ULVT_Ns
// waive one track overlap 	  
ULVT_N_A1 = INT ULVT_Ns < ULVT_N_W_1 ABUT < 90 REGION PROJ==0
ULVT_N_B1 = ULVT_N_R NOT (EXPAND EDGE ULVT_N_R INSIDE BY ULVT_N_R_3/2)	
ULVT_N_C1 = EXT ULVT_N_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_N_D1 = ULVT_N_A1 ENCLOSE ULVT_N_C1
// waive one track space
ULVT_N_A2 = EXT ULVT_Ns < ULVT_N_S_1 ABUT < 90 REGION PROJ==0
ULVT_N_B2 = ULVT_N_R OR (EXPAND EDGE ULVT_N_R OUTSIDE BY ULVT_N_R_3/2)
ULVT_N_C2 = EXT ULVT_N_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_N_D2  = ULVT_N_A2 ENCLOSE ULVT_N_C2
// waive point touch
ULVT_N_P = EXT ULVT_N_R < ULVT_N_S_1 SINGULAR INTERSECTING ONLY REGION

ULVT_N.W.1 { @ Width >= ^ULVT_N_W_1. One-track(^ULVT_N_R_3) overlap is allowed
  X = INT ULVT_Ns < ULVT_N_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ULVT_N_D1)) NOT INSIDE SRAM_EXCLUDE
}
ULVT_N.S.1 { @ Space >= ^ULVT_N_S_1. Point touch of corners is allowed. One-track(^ULVT_N_R_3) space is allowed.
  X = EXT ULVT_Ns < ULVT_N_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ULVT_N_D2 OR ULVT_N_P))) NOT INSIDE SRAM_EXCLUDE
}
ULVT_N.S.2__ULVT_N.S.2.1 { @ Space to gate in PO endcap direction >= ^ULVT_N_S_2 & in S/D direction >= ^ULVT_N_S_2_1
  A = GATE NOT INTERACT ULVT_N
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ULVT_N_S_2_1 - ULVT_N_S_2)) OR A
  C = SIZE B BY ULVT_N_S_2
  ULVT_N AND C
}

// ULVT_N.S.2 and ULVT_N.S.2.1 are checked by ULVT_N.S.2__ULVT_N.S.2.1
ULVT_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^ULVT_N_S_3
  EXT ULVT_N ODPO_RES_RPO < ULVT_N_S_3 ABUT < 90 SINGULAR
  AND ULVT_N ODPO_RES_RPO    
}  
ULVT_N.EN.1__ULVT_N.EN.2 { @ Enclosure of gate in S/D direction >= ^ULVT_N_EN_1 & in PO endcap direction >= ^ULVT_N_EN_2 
  A = GATE INTERACT ULVT_N
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ULVT_N_EN_1 - ULVT_N_EN_2)) OR A
  C = SIZE B BY ULVT_N_EN_2
  C NOT ULVT_N
}
// ULVT_N.EN.1 and ULVT_N.EN.2 are checked by ULVT_N.EN.1__ULVT_N.EN.2
ULVT_N.A.1 { @ Area >= ^ULVT_N_A_1
  (AREA ULVT_Ns < ULVT_N_A_1) NOT INSIDE SRAM_EXCLUDE
}
ULVT_N.A.2 { @ Enclosed area >= ^ULVT_N_A_2
  A = HOLES ULVT_N INNER
  B = A NOT ULVT_N
  AREA B < ULVT_N_A_2
}
ULVT_N.R.1 { @ Overlap of P+ACTIVE, VAR, VTL_N, VTH_N, NT_N, TCDDMY, {OD AND NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, or OD2 is not allowed   
  ULVT_N AND OD2
  ULVT_N AND NTN
  ULVT_N AND PACT
  ULVT_N AND VTHN
}
// ULVT_N.R.2 and ULVT_N.R.3 are checked by ULVT_N.W.1 and ULVT_N.S.1
ULVT_N.L.1 { @ 45-degree edge length >= ^ULVT_N_L_1 um
  ULVT_N_45ANGLE = ULVT_N ANGLE == 45
  (LENGTH ULVT_N_45ANGLE < ULVT_N_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

ULVT_N.R.1:b { @ Overlap of VAR, VTL_N, TCDDMY, {OD AND NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE is not allowed.
  ULVT_N AND VAR
  ULVT_N AND VTLN
  ULVT_N AND TCDDMY
  ULVT_N AND (OD AND NWDMY)
  ULVT_N AND SRM
  ULVT_N AND ROM
  ULVT_N AND BJTDMY
  ULVT_N AND RH
  ULVT_N AND POFUSE
}

ULVT_N.R.4 { @ {Gate AND ULVT_N} must be covered by DCO_LPP
  (GATE AND ULVT_N) NOT DCO_LPP
}

//VTL_P CHECKS
//============
ULVT_P_R = COPY ULVT_Ps
// waive one track overlap 	  
ULVT_P_A1 = INT ULVT_Ps < ULVT_P_W_1 ABUT < 90 REGION PROJ==0
ULVT_P_B1 = ULVT_P_R NOT (EXPAND EDGE ULVT_P_R INSIDE BY ULVT_P_R_3/2)	
ULVT_P_C1 = EXT ULVT_P_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_P_D1 = ULVT_P_A1 ENCLOSE ULVT_P_C1
// waive one track space
ULVT_P_A2 = EXT ULVT_Ps < ULVT_P_S_1 ABUT < 90 REGION PROJ==0
ULVT_P_B2 = ULVT_P_R OR (EXPAND EDGE ULVT_P_R OUTSIDE BY ULVT_P_R_3/2)
ULVT_P_C2 = EXT ULVT_P_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_P_D2  = ULVT_P_A2 ENCLOSE ULVT_P_C2
// waive point touch
ULVT_P_P = EXT ULVT_P_R < ULVT_P_S_1 SINGULAR INTERSECTING ONLY REGION

ULVT_P.W.1 { @ Width >= ^ULVT_P_W_1. One-track(^ULVT_P_R_3) overlap is allowed
  X = INT ULVT_Ps < ULVT_P_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ULVT_P_D1)) NOT INSIDE SRAM_EXCLUDE
}
ULVT_P.S.1 { @ Space >= ^ULVT_P_S_1. Point touch of corners is allowed. One-track(^ULVT_P_R_3) space is allowed.
  X = EXT ULVT_Ps < ULVT_P_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ULVT_P_D2 OR ULVT_P_P))) NOT INSIDE SRAM_EXCLUDE
}
ULVT_P.S.2__ULVT_P.S.2.1 { @ Space to gate in PO endcap direction >= ^ULVT_P_S_2 & in S/D direction >= ^ULVT_P_S_2_1
  A = GATE NOT INTERACT ULVT_P
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ULVT_P_S_2_1 - ULVT_P_S_2)) OR A
  C = SIZE B BY ULVT_P_S_2
  ULVT_P AND C
}

// ULVT_P.S.2 and ULVT_P.S.2.1 are checked by ULVT_P.S.2__ULVT_P.S.2.1
ULVT_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^ULVT_P_S_3
  EXT ULVT_P ODPO_RES_RPO < ULVT_P_S_3 ABUT < 90 SINGULAR
  AND ULVT_P ODPO_RES_RPO    
}  
ULVT_P.EN.1__ULVT_P.EN.2 { @ Enclosure of gate in S/D direction >= ^ULVT_P_EN_1 & in PO endcap direction >= ^ULVT_P_EN_2 
  A = GATE INTERACT ULVT_P
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ULVT_P_EN_1 - ULVT_P_EN_2)) OR A
  C = SIZE B BY ULVT_P_EN_2
  C NOT ULVT_P
}
// ULVT_P.EN.1 and ULVT_P.EN.2 are checked by ULVT_P.EN.1__ULVT_P.EN.2
ULVT_P.A.1 { @ Area >= ^ULVT_P_A_1
  (AREA ULVT_Ps < ULVT_P_A_1) NOT INSIDE SRAM_EXCLUDE
}
ULVT_P.A.2 { @ Enclosed area >= ^ULVT_P_A_2
  A = HOLES ULVT_P INNER
  B = A NOT ULVT_P
  AREA B < ULVT_P_A_2
}
ULVT_P.R.1 { @ Overlap of N+ACTIVE, VAR, VTL_P, VTH_P, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, or OD2 is not allowed   
  ULVT_P AND OD2
  ULVT_P AND NTN
  ULVT_P AND NACT
  ULVT_P AND VTHP
}
// ULVT_P.R.2 and ULVT_P.R.3 are checked by ULVT_P.W.1 and ULVT_P.S.1
ULVT_P.L.1 { @ 45-degree edge length >= ^ULVT_P_L_1 um
  ULVT_P_45ANGLE = ULVT_P ANGLE == 45
  (LENGTH ULVT_P_45ANGLE < ULVT_P_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

ULVT_P.R.1:b { @ Overlap of VAR, VTL_P, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE is not allowed.
  ULVT_P AND VAR
  ULVT_P AND VTLP
  ULVT_P AND TCDDMY
  ULVT_P AND (OD AND NWDMY)
	ULVT_P AND (NP INTERACT NWDMY)
  ULVT_P AND SRM
  ULVT_P AND ROM
  ULVT_P AND BJTDMY
  ULVT_P AND RH
  ULVT_P AND POFUSE
}

ULVT_P.R.4 { @ {Gate AND ULVT_P} must be covered by DCO_LPP
  (GATE AND ULVT_P) NOT DCO_LPP
}


// waive one/two tracks overlap
OD12_OA1 = INT OD12s < OD12_W_1 ABUT < 90 REGION PROJ==0
OD12_OB1 = OD12s NOT (EXPAND EDGE OD12s INSIDE BY OD12_R_4/2)
OD12_OB2 = OD12s NOT (EXPAND EDGE OD12s INSIDE BY OD12_R_4)
OD12_OC1 = EXT OD12_OB1 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_OC2 = EXT OD12_OB2 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_O = OD12_OA1 ENCLOSE (OD12_OC1 OR OD12_OC2)
// waive one/two tracks space
OD12_SA1 = EXT OD12s < OD12_S_1 ABUT < 90 REGION PROJ==0
OD12_SB1 = OD12s OR (EXPAND EDGE OD12s OUTSIDE BY OD12_R_4/2)
OD12_SB2 = OD12s OR (EXPAND EDGE OD12s OUTSIDE BY OD12_R_4)
OD12_SC1 = EXT OD12_SB1 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_SC2 = EXT OD12_SB2 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_S = OD12_SA1 ENCLOSE (OD12_SC1 OR OD12_SC2)
// waive point touch
OD12_P = EXT OD12s < OD12_S_1 SINGULAR INTERSECTING ONLY REGION

OD_12.W.1 { @ Width >= 0.34 
  A = INT OD12s < OD12_W_1 ABUT < 90 REGION
  (A INTERACT (A NOT OD12_O)) NOT INSIDE SRAM_EXCLUDE
}
OD_12.W.3 { @ Channel length >= 0.07 
  OD12_GATE_W = GATE_W INSIDE EDGE OD12s
  (INT OD12_GATE_W < OD12_W_3 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE
}
OD_12.S.1 { @ Space >= 0.34 
  A = EXT OD12s < OD12_S_1 ABUT < 90 SINGULAR REGION
  (A INTERACT (A NOT (OD12_S OR OD12_P))) NOT INSIDE SRAM_EXCLUDE
}
OD_12.S.2 { @ Space to {ACTIVE OR GATE} >= 0.05 
  DACTG = DACT OR GATE
  EXT OD12 DACTG < OD12_S_2 ABUT < 90 SINGULAR REGION
}
OD_12.S.3__OD_12.S.4 { @ Space to core 0.9V gate in S/D direction >= ^OD12_S_3
              @ Space to core 0.9V gate in end-cap direction >= ^OD12_S_4
  A = GATE NOT INTERACT OD12
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (OD12_S_3 - OD12_S_4 )) OR A
  C = SIZE B BY OD12_S_4
  C AND OD12
}
// OD_12.S.3 is checked by OD_12.S.3__OD_12.S.4
// OD_12.S.4 is checked by OD_12.S.3__OD_12.S.4

OD_12.S.6 { @ Space to OD2. Space = 0 um is allowed >= 0.18 
  EXT OD12 OD2 < OD12_S_6 ABUT < 90 > 0 SINGULAR REGION
}
OD_12.EN.1__OD_12.EN.2 { @ Enclosure of core 1.2V gate in S/D direction >= ^OD12_EN_1
               @ Enclosure of core 1.2V gate in end-cap direction >= ^OD12_EN_2
  A = GATE INTERACT OD12
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (OD12_EN_1 - OD12_EN_2 )) OR A
  C = SIZE B BY OD12_EN_2
  C NOT OD12
}
// OD_12.EN.1 is checked by OD_12.EN.1__OD_12.EN.2 
// OD_12.EN.2 is checked by OD_12.EN.1__OD_12.EN.2 

OD_12.EX.3 { @ Extension on ACTIVE [Cut is not allowed if without Gate] >= 0.05 
  ENC DACT OD12 < OD12_EX_3 ABUT < 90 SINGULAR REGION
  (DACT NOT INTERACT GATE) CUT OD12
}
OD_12.A.1 { @ Area >= ^OD12_A_1
  (AREA OD12s < OD12_A_1) NOT INSIDE SRAM_EXCLUDE
}
OD_12.A.2 { @ Enclosed Area >= ^OD12_A_2
  A = HOLES OD12s INNER
  B = A NOT OD12s
  (AREA B < OD12_A_2) NOT INSIDE SRAM_EXCLUDE
}
OD_12.R.2 { @ Overlap of VTH_N, VTH_P, VTL_N, VTL_P, RPO, RH, NWDMY, BJTDMY, OD2 is not allowed   
  OD12 AND VTHN
  OD12 AND VTHP
  OD12 AND VTLN
  OD12 AND VTLP
  OD12 AND RPO
  OD12 AND RH
  OD12 AND NWDMY
  OD12 AND BJTDMY
  OD12 AND OD2
}
OD_12.R.3 { @ OD_12 cut {ACTIVE OR GATE} is not allowed (Except OD shared by core and OD_12 is at same potential, DRC can't exclude this exception.)   
  DACTG = DACT OR GATE  
  (DACTG CUT OD12s) NOT INSIDE SRAM_EXCLUDE
}
// OD_12.R.4 is checked by OD_12.W.1 and OD_12.S.1



//OD18_15 CHECKS
//==============
18_15V_GATE_W = 18V_GATE_W INSIDE EDGE OD1815

OD18_15.W.1 { @ Channel length of 1.8V MOS underdriven to 1.5V (Gate AND OD18_15) >= ^OD18_15_W_1 um
  INT 18_15V_GATE_W < OD18_15_W_1 ABUT < 90 REGION
}
// OD18_15.W.1.GS is checked by OD18_15.W.1
// OD18_15.W.1.LP is checked by OD18_15.W.1

OD18_15.R.1 { @ {GATE AND OD18_15} can't overlap OD_25, OD_33, OD25_18, or OD25_33. {Gate AND OD18_15} must be covered by OD_18. OD18_15 can't cut GATE.
  18_15V_GATE = GATE AND OD1815
  18_15V_GATE AND OD25
  18_15V_GATE AND OD33
  18_15V_GATE AND OD2518
  18_15V_GATE AND OD2533
  18_15V_GATE NOT OD18
  GATE CUT OD1815
}
OD18_15.R.2 { @ 1.8V and 1.5V can not share same NW
  A = GATE INTERACT OD18
  B = A INTERACT OD1815    
  C = A NOT INTERACT OD1815
  (NWEL INTERACT B) INTERACT C
}


//OD25_33 CHECKS
//==============
25_33V_GATE_W = 25V_GATE_W INSIDE EDGE OD2533

OD25_33.W.1 { @ Channel length of 2.5V NMOS overdrive to 3.3V (NMOS Gate AND OD25_33). >= ^OD25_33_W_1 um
  25_33V_GATE_W_NP = 25_33V_GATE_W INSIDE EDGE NP
  INT 25_33V_GATE_W_NP < OD25_33_W_1 ABUT < 90 REGION
}
// OD25_33.W.1.LP is checked by OD25_33.W.1
// OD25_33.W.1.GS is checked by OD25_33.W.1
// OD25_33.W.1.LP.S is checked by OD25_33.W.1

OD25_33.W.2 { @ Channel length of 2.5V PMOS overdriven to 3.3V (PMOS Gate AND OD25_33) >= ^OD25_33_W_2 um
  25_33V_GATE_W_PP = 25_33V_GATE_W INSIDE EDGE PP
  INT 25_33V_GATE_W_PP < OD25_33_W_2 ABUT < 90 REGION
}
// OD25_33.W.2.LP is checked by OD25_33.W.2
// OD25_33.W.2.GS is checked by OD25_33.W.2
// OD25_33.W.2.LP.S is checked by OD25_33.W.2

OD25_33.W.3 { @ Channel length of 2.5V native NMOS overdrive to 3.3V. ((Gate AND NT_N) AND OD25_33) >= 1.2 
  25_33V_GATE_W_NP_NTN = (25_33V_GATE_W INSIDE EDGE NP) INSIDE EDGE NTN
  INT 25_33V_GATE_W_NP_NTN < OD25_33_W_3 ABUT < 90 REGION
}

OD25_33.R.1 { @ {GATE AND OD25_33} can't overlap OD_18,OD_33,or OD25_18. {Gate AND OD25_33} must be covered by OD_25. GATE can't cut OD25_33
  25_33V_GATE = GATE AND OD2533
  25_33V_GATE AND OD18
  25_33V_GATE AND OD33
  25_33V_GATE AND OD2518
  25_33V_GATE NOT OD25
  GATE CUT OD2533
}

//OD25_18 CHECKS
//==============
25_18V_GATE_W = 25V_GATE_W INSIDE EDGE OD2518

OD25_18.W.1 { @ Channel length of 2.5V MOS underdriven to 1.8V (Gate AND OD25_18) >= ^OD25_18_W_1 um
  INT 25_18V_GATE_W < OD25_18_W_1 ABUT < 90 REGION
}

#IFDEF GS
OD25_18.W.1.GS { @ Channel length of 2.5V PMOS underdriven to 1.8V (Gate AND OD25_18) >= ^OD25_18_W_1GS um
   A = 25_18V_GATE_W INSIDE EDGE PP
   INT A < OD25_18_W_1GS ABUT < 90 REGION
}
#ENDIF

OD25_18.W.2 { @ Channel length of 2.5V native NMOS underdriven to 1.8V ((Gate AND NT_N) AND OD25_18) >= ^OD25_18_W_2 um
  25_18V_GATE_W_NP_NTN = (25_18V_GATE_W INSIDE EDGE NP) INSIDE EDGE NTN
  INT 25_18V_GATE_W_NP_NTN < OD25_18_W_2 ABUT < 90 REGION
}
OD25_18.R.1 { @ {GATE AND OD25_18} can't overlap OD_18 or OD_33 or OD25_33. {Gate AND OD25_18} must be covered by OD_25. GATE can't cut D25_18
  25_18V_GATE = GATE AND OD2518
  25_18V_GATE AND OD18
  25_18V_GATE AND OD33
  25_18V_GATE AND OD2533
  25_18V_GATE NOT OD25
  GATE CUT OD2518
}




//PO CHECKS
//=========
PO.W.1 { @ Width >= 0.04 
  (INT POLY < PO_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE RAM1TDMY
}

PO.W.2 { @ Channel length of 2.5V MOS (for 2.5V overdrive to 3.3V, please refer to section OD25_33 Layout Rules) >= 0.27 
  25V_GATE_W_NORMAL = 25V_GATE_W NOT INSIDE EDGE (OD2518 OR OD2533)
  INT 25V_GATE_W_NORMAL < PO_W_2 ABUT < 90 REGION
}
PO.W.3 { @ Channel length of 3.3V MOS >= ^PO_W_3 um
  INT 33V_GATE_W < PO_W_3 ABUT < 90 REGION
}
// PO.W.3.LP is checked by PO.W.3

PO.W.4 { @ Channel length of 1.8 V MOS (For 2.5V underdrive to 1.8V, please refer to section OD25_18 Layout Rules. For 1.8V underdrive to 1.5V, please refer to section OD18_15 Layout Rules.) >= 0.15 
  18V_GATE_W_NORMAL = 18V_GATE_W NOT INSIDE EDGE OD1815
  INT 18V_GATE_W_NORMAL < PO_W_4 ABUT < 90 REGION
}

#IFDEF GS
PO.W.6.GS { @ Channel length of core device for GS (This check doesn't include CDUDMY region and the regions covered by layers of NT_N, SDI, and VAR.) = 0.04 / 0.045 / 0.05 / 0.06 / 0.07 / 0.08~10 
  EXCLUDE_REGION = ((((LOGO OR NTNi) OR SDI) OR VAR) OR SRAM_REGION) OR (CSRDMY OR CDUDMY)
  LV_GATE_L_C = LV_GATE_L NOT INSIDE EDGE EXCLUDE_REGION
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6A)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6B > PO_W_6A)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6C > PO_W_6B)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6D > PO_W_6C)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6E > PO_W_6D)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6F > PO_W_6E)
  GATE WITH EDGE (LENGTH LV_GATE_L_C > PO_W_6G)
}
#ENDIF

PO_EDGE_45 = POLY ANGLE == 45

PO.W.7 { @ Width of 45-degree FIELD PO (except PO fuse element, POFUSE, 156;0). (Please make sure the vertex of 45-degree pattern is on 5nm grid (refer to the rule, G.6U, in section XXX)) >= 0.17 
  INT (PO_EDGE_45 NOT INSIDE EDGE POFUSE) < PO_W_7 ABUT < 90 REGION
}

#IFNDEF GS
PO.W.8 { @ Maximum channel length of NMOS [for LPG G device] <= 10
  LV_GATE_L_C = (LV_GATE_L INSIDE EDGE NP) INSIDE EDGE DCO
  GATE WITH EDGE (LENGTH LV_GATE_L_C > PO_W_8)
}
#ENDIF
PO.S.1 { @ Space >= 0.1 
  (EXT POi < PO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}

PO.S.3 { @ {GATE inside OD2} space in the same OD >= 0.22 
  EXT HV_GATE_W < PO_S_3 ABUT < 90 REGION
}

PO.S.4 { @ FIELD PO space to OD (except CSRDMY (166;0) region) >= 0.03 
  POLY_CHECK = POLY NOT CSRDMY
  WAIVE_REGION = SRAM_REGION OR RAM1TDMY
  (EXT POLY_CHECK OD < PO_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE WAIVE_REGION
}




PO.S.4.1 { @ Gate space [L-shape OD and L-shape PO enclosed area < 0.0121 um2] >= 0.11 
  X = RECTANGLE (HOLES (POLY OR OD) INNER EMPTY < PO_S_4_1_A)
  (EXT GATE < PO_S_4_1 ABUT < 90 REGION CORNER TO CORNER) INTERACT X
}
PO.S.6 { @ L-shape PO space to OD when PO and OD are in the same MOS [L-shape PO length (R1) <= 0.06 um] >= 0.04 
  A = ((EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_L) NOT GATE) TOUCH EDGE OD
  B = EXT A [FPO1] < PO_S_6_1 ABUT < 90 OPPOSITE
  (EXT B OD < PO_S_6 ABUT < 90 OPPOSITE REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}
PO.S.6.1 { @ L-shape PO space to OD when PO and OD are in the same MOS [L-shape PO length > 0.06 um (R1) and L-shape PO length <= 0.1 um (R1)] >= 0.05 
  L_GATE_L1 = EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_1_L2
  L_GATE_L2 = EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_1_L1+0.001
  L_GATE_L = L_GATE_L1 NOT L_GATE_L2
  L_GATE_L1E = (L_GATE_L1 TOUCH EDGE GATE_L) TOUCH EDGE OD
  L_GATE_LE = L_GATE_L COIN EDGE L_GATE_L1E
  B = EXT L_GATE_LE [FPO1] <= PO_S_6_1 ABUT < 90 OPPOSITE
  (EXT B OD < PO_S_6_1 ABUT < 90 OPPOSITE REGION) NOT INSIDE RAM1TDMY
  U_PO = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH > PO_S_6_1_L1 <= PO_S_6_1_L1*2
  X = EXT U_PO OD < PO_S_6_1 OPPOSITE REGION
  ((SIZE X BY 0.001) INTERACT GATE == 2) NOT INSIDE RAM1TDMY
}
PO.S.7 { @ Space if at least one {PO OR SR_DPO} width > 0.12 um, and the {PO OR SR_DPO} parallel run length > 0.14 um (individual projection) >= 0.16 
  Wide_POLY = SR_POLY WITH WIDTH > PO_S_7_W
  X = EXT Wide_POLY SR_POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X PO_S_1 - GRID PO_S_7_L + GRID
  WideEdge = Wide_POLY COIN OUTSIDE EDGE Y
  A = PATH LENGTH WideEdge > PO_S_7_L
  B = EXPAND EDGE A BY 0.001
  C = EXTENTS B
  D = ENCLOSE RECTANGLE C 0.001 PO_S_7_L + GRID ORTHOGONAL ONLY
  E = A INSIDE EDGE D
  EXT E SR_POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
}
PO.S.9 { @ Space [in same RPO] >= 0.18 
  A = POLY INSIDE EDGE RPO
  EXT A < PO_S_9 ABUT < 90 REGION
}
PO.S.10 { @ Space at {PO OR SR_DPO} line-end (W < 0.07 um (Q1)) in a dense-line-end configuration: If {PO OR SR_DPO} has parallel run length with opposite {PO OR SR_DPO} (measured with T1 = 0.035 um extension) along 2 adjacent edges of {PO OR SR_DPO} [any one edge < Q1 distance from the corner of the 2 edges], then one of the spaces (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.04 um (R)) >= 0.11 
  A = CONVEX EDGE SR_POLY ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < PO_S_10_Q
  B = EXT [A] SR_POLY < PO_S_10 ABUT < 90 OPPOSITE EXTENDED PO_S_10_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [SR_POLY] < PO_S_10_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= PO_S_10_L
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY PO_S_10_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  EXT O SR_POLY < PO_S_10 ABUT < 90 OPPOSITE REGION

}
PO.S.15 { @ Large PO to gate [channel length <= 0.08 um] space. The large PO is defined as PO area >= 630 um2 and interacts with regions of density > 70% in window 30 um x 30 um, stepping 15 um. DPO will be excluded from density check >= 1 
  PO_EXC = POi NOT DEN_EXC_LOW
  A = AREA PO_EXC >= PO_S_15_A
  B = EXTENTS A
  C = SIZE B BY PO_S_15_S
  D = DENSITY PO_EXC > PO_S_15_D INSIDE OF LAYER C WINDOW PO_S_15_W2 STEP PO_S_15_S BACKUP PRINT PO.S.15.density
  E = A INTERACT D
  GATE_W_S80 = INT [GATE_W] <= PO_S_15_W1
  GATE_S80 = GATE WITH EDGE GATE_W_S80
  EXT E GATE_S80 < PO_S_15 ABUT<90 REGION
}
PO.S.16 { @ Space to 45-degree bent {PO OR SR_DPO} >= 0.17 
  A = SR_POLY ANGLE == 45
  X = EXPAND EDGE A OUTSIDE BY PO_S_16
  X AND POLY
}


PO.EX.1 { @ Extension on OD (end-cap) >= 0.09 
  WAIVE_REGION = (SRAM_REGION OR LOGO) OR RAM1TDMY
  A = OD NOT INSIDE WAIVE_REGION
ENC A POLY < PO_EX_1 ABUT < 90 OPPOSITE SINGULAR REGION
}
PO.EX.2 { @ OD extension on PO >= 0.09 
  WAIVE_REGION = LOGO OR SRAM_REGION
  ENC (POLY NOT WAIVE_REGION) OD < PO_EX_2 ABUT < 90 SINGULAR REGION
}
PO.EX.3 { @ Extension on OD (end-cap) when the PO to L-shape OD (in the same MOS) space < 0.1 um. (This check doesn't include ACTIVE jog <= 0.02 um.) >= 0.11 
  A = GATE_W NOT INSIDE EDGE (SRAM_REGION OR LOGO)
  B = EXPAND EDGE A INSIDE BY GRID EXTEND BY OD_S_1
  C = EXPAND EDGE A INSIDE BY GRID EXTEND BY PO_EX_3_J
  D = B NOT C
  E = (B TOUCH EDGE A) TOUCH EDGE POLY
  F = D COIN EDGE E
  G = EXT F OD < PO_EX_3_S ABUT < 90 OPPOSITE REGION
  H = FPO1 TOUCH OUTSIDE EDGE G
  I = EXPAND EDGE H INSIDE BY GRID
  J = GATE_L TOUCH OUTSIDE EDGE I
  K = EXPAND EDGE J OUTSIDE BY PO_EX_3
  L = K INTERACT G
  L NOT POLY
}
PO.L.1 { @ Max poly length between two contacts, as well as the length between one contact and the end of the poly-gate, when the poly width < 0.08um, <= 18
  ILP2 = (ILP1 NOT SDI) NOT RAM1TDMY
  LONGP = AREA ILP2 > PO_W_1 * PO_L_1
  X = LONGP INTERACT COPO
  CHECK_COPO = COPO INTERACT X
  A = SIZE CHECK_COPO BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  P2P = X INTERACT A > 1
  BAD = P2P NOT A
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERR = INT BAD_EDGE < PO_L_1_W ABUT < 90 REGION
  X1 = (X INTERACT ERR) NOT GATE
  CHECK_COPO1 = CHECK_COPO INTERACT X1
  A1 = SIZE CHECK_COPO1 BY PO_L_1 / 2 INSIDE OF X1 STEP PO_S_1*0.7
  P2P1 = X1 INTERACT A1 > 1
  BAD1 = (P2P1 NOT A1) INTERACT A1 > 1
  BAD_EDGE1 = BAD1 COIN INSIDE EDGE POLY
  ERR1 = INT BAD_EDGE1 < PO_L_1_W ABUT < 90 REGION
  X1 INTERACT ERR1

  NARROW_GATE = (GATE WITH EDGE (LENGTH GATE_L < PO_L_1_W)) AND X
  B = SIZE A BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  NARROW_GATE NOT B

}
// PO.L.1.S is checked by PO.L.1
PO.A.1 { @ Area (This check doesn't include the pattern filling 0.04 um x 0.3 um rectangular tile) >= 0.022 
  A = AREA POLYs < PO_A_1
  NOT ENCLOSE RECTANGLE A PO_W_1 PO_A_1_L ORTHOGONAL ONLY
}
PO.A.2 { @ Area [with all of edge length < 0.21 um] >= 0.055 
  A = AREA POLYs < PO_A_2
  B = LENGTH A >= PO_A_2_L
  (A NOT WITH EDGE B) NOT INSIDE SRAM_EXCLUDE
}
PO.A.3 { @ Enclosed area >= 0.04 
  A = HOLES POLYs INNER
  B = A NOT POi
  (AREA B < PO_A_3) NOT INSIDE SRAM_EXCLUDE
}
PO.A.4 { @ Enclosed area [with all of inner edge length < 0.21 um] >= 0.077 
  A = HOLES POLYs INNER
  B = A NOT POi
  C = LENGTH B >= PO_A_4_L
  D = B NOT WITH EDGE C
  (AREA D < PO_A_4) NOT INSIDE SRAM_EXCLUDE
}
#IFDEF FULL_CHIP
PO.DN.1 { @ Min. POLY density across full chip 14%
  DENSITY ALL_POLY CHIP < PO_DN_1 INSIDE OF LAYER CHIPx [ AREA(ALL_POLY)/AREA(CHIP) ] PRINT PO.DN.1.density
}
PO.DN.1.1 { @ Max. poly density across full chip 40%
  DENSITY ALL_POLY CHIP > PO_DN_1_1 INSIDE OF LAYER CHIPx [ AREA(ALL_POLY)/AREA(CHIP) ] PRINT PO.DN.1.1.density
}
#ENDIF

ALL_POD = ALL_OD OR ALL_POLY
PODEXC  = ((ODBLK OR POBLK) OR NWDMY) OR DEN_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
PO.DN.2 { @ {OD OR DOD OR PO OR DPO } local density (minimun) over window 20um x 20um stepping 10um >= 0.1%
  ERR_WIN = DENSITY ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ALL_POD)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT PODEXC) >= PO_DN_2_E
  DENSITY F ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT PO.DN.2.density
          [ !AREA(F)+AREA(ALL_POD)/AREA(CHIP) ]
}
#ENDIF

PODN3_POBLK = ((((POBLK NOT RFIP) NOT TCDDMY) NOT ICOVL) NOT MOMDMY) NOT DEN_EXC_LOW


CHIP_POBLK = CHIP AND PODN3_POBLK
PO_POBLK = ALL_POLY AND PODN3_POBLK

PO.DN.3 { @ PO density within POBLK. (except {RFDMY AND RFIP_DMY}, MOMDMY (155;21), and TCDDMY) >= 14% 
  A = DENSITY PO_POBLK CHIP_POBLK < PO_DN_3 INSIDE OF LAYER CHIPx PRINT PO.DN.3.density
      [ AREA(PO_POBLK)/AREA(CHIP_POBLK) ]
  A AND PODN3_POBLK
}

PO.R.1 { @ GATE must be a rectangle orthogonal to grid. (Both bent GATE and gate with jog are not allowed). (Except CSRDMY region)   
  (NOT RECTANGLE GATE ORTHOGONAL ONLY) NOT INSIDE ((LOGO OR CSRDMY) OR ICOVL)
}

PO.R.4 { @ PO intersecting OD must form 2 or more diffusions. (Except CSRDMY region)   
  WAIVE_REGION = (LOGO OR (RODMY AND SRAMDMY)) OR CSRDMY

  FOD = EXPAND EDGE (GATE INSIDE EDGE OD) BY GRID
  (GATE NOT INSIDE WAIVE_REGION) NOT INTERACT FOD >= 2
}


POR7_REGION = (SRM OR SRAMDMY) NOT RAM1TDMY
POR7_GATE = (GATEi NOT OUTSIDE POR7_REGION) OUTSIDE RODMY // not check RODMY
POR7_GATE_W = POi COIN INSIDE EDGE POR7_GATE
POR7_GATE_W_V = EXPAND EDGE (ANGLE POR7_GATE_W == 90) INSIDE BY GRID
POR7_GATE_W_H = EXPAND EDGE (ANGLE POR7_GATE_W == 0) INSIDE BY GRID
POR7_BAD = (CHIP INTERACT POR7_GATE_W_V) INTERACT POR7_GATE_W_H
PO.R.7:V { @ Poly gates of all SRAM cells (50;0 OR 186;0) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
  POR7_GATE_W_V AND POR7_BAD
}
PO.R.7:H { @ Poly gates of all SRAM cells (50;0 OR 186;0) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
  POR7_GATE_W_H AND POR7_BAD
}
// PO.R.7 is checked by PO.R.7:V and PO.R.7:H
//H-GATE CHECK
//============

PO.R.6 { @ H-gate that fulfills the following conditions at the same time is not allowed. [inner space < 0.43 um (U), channel length < 0.1 um (V), interconnect PO width < 0.25 um (W), and interconnect PO length > 0.065 um (X)]   
  A1 = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270
  A = LENGTH A1 >= PO_S_1 < PO_R_6_S
  B = A INSIDE EDGE OD
  C = POLY TOUCH INSIDE EDGE B
  D = INTERNAL [POLY] < PO_R_6_W1 OPPOSITE
  E = POLY TOUCH INSIDE EDGE D
  F = C COIN INSIDE EDGE E
  G = INT [POLY] < PO_R_6_W2 OPPOSITE
  H = LENGTH G > PO_R_6_L
  I = H NOT COIN INSIDE EDGE F
  J = EXT [F] I < GRID ABUT == 90 INTERSECTING ONLY
  K = EXPAND EDGE F INSIDE BY GRID
  L = K WITH EDGE J == 2
  GATE INTERACT L == 2
}

//FLOATING GATE CHECK
//===================
GATEu  = STAMP GATEi BY POu
NSDu_g = NSDu INTERACT POu
PSDu_g = PSDu INTERACT POu

Float_GATE = NET AREA RATIO GATEu PSTPu NSTPu PSDu_g NSDu_g PADu COu > 0 
  [!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PSDu_g)*!AREA(NSDu_g)*!AREA(PADu)+!AREA(COu)]
Float_NSD = NET AREA RATIO NSDu_g PSDu_g GATEu PSTPu NSTPu PADu > 0
  [~(COUNT(NSDu_g)-1)*!AREA(PSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PADu)]
Float_PSD = NET AREA RATIO PSDu_g NSDu_g GATEu PSTPu NSTPu PADu > 0
  [~(COUNT(PSDu_g)-1)*!AREA(NSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PADu)]


effective_NSD = NSDu_g NOT Float_NSD
effective_PSD = PSDu_g NOT Float_PSD
Float_NSD_a = Float_NSD NOT ((Float_NSD OR GATE) INTERACT effective_NSD > 1 BY NET)
Float_PSD_a = Float_PSD NOT ((Float_PSD OR GATE) INTERACT effective_PSD > 1 BY NET)

#IFDEF CHECK_FLOATING_GATE_BY_PRIMARY_TEXT

IP_PIN_M1u_BY_TEXT = M1u WITH TEXT IP_PIN_TEXT M1_PIN_TEXT PRIMARY ONLY
IP_PIN_M2u_BY_TEXT = M2u WITH TEXT IP_PIN_TEXT M2_PIN_TEXT PRIMARY ONLY
IP_PIN_M3u_BY_TEXT = M3u WITH TEXT IP_PIN_TEXT M3_PIN_TEXT PRIMARY ONLY
IP_PIN_M4u_BY_TEXT = M4u WITH TEXT IP_PIN_TEXT M4_PIN_TEXT PRIMARY ONLY
IP_PIN_M5u_BY_TEXT = M5u WITH TEXT IP_PIN_TEXT M5_PIN_TEXT PRIMARY ONLY
IP_PIN_M6u_BY_TEXT = M6u WITH TEXT IP_PIN_TEXT M6_PIN_TEXT PRIMARY ONLY
IP_PIN_APu_BY_TEXT = APu WITH TEXT IP_PIN_TEXT AP_PIN_TEXT PRIMARY ONLY


IP_PIN_WAIVE = NET AREA RATIO GATEu OVER IP_PIN_M6u_BY_TEXT IP_PIN_M5u_BY_TEXT IP_PIN_M4u_BY_TEXT IP_PIN_M3u_BY_TEXT IP_PIN_M2u_BY_TEXT IP_PIN_M1u_BY_TEXT IP_PIN_APu_BY_TEXT > 0

Float_GATE_check = (Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)) NOT INTERACT IP_PIN_WAIVE

#ELSE
#IFDEF CHECK_FLOATING_GATE_BY_TEXT

IP_PIN_M1u_BY_TEXT = M1u WITH TEXT IP_PIN_TEXT M1_PIN_TEXT
IP_PIN_M2u_BY_TEXT = M2u WITH TEXT IP_PIN_TEXT M2_PIN_TEXT
IP_PIN_M3u_BY_TEXT = M3u WITH TEXT IP_PIN_TEXT M3_PIN_TEXT
IP_PIN_M4u_BY_TEXT = M4u WITH TEXT IP_PIN_TEXT M4_PIN_TEXT
IP_PIN_M5u_BY_TEXT = M5u WITH TEXT IP_PIN_TEXT M5_PIN_TEXT
IP_PIN_M6u_BY_TEXT = M6u WITH TEXT IP_PIN_TEXT M6_PIN_TEXT
IP_PIN_APu_BY_TEXT = APu WITH TEXT IP_PIN_TEXT AP_PIN_TEXT


IP_PIN_WAIVE = NET AREA RATIO GATEu OVER IP_PIN_M6u_BY_TEXT IP_PIN_M5u_BY_TEXT IP_PIN_M4u_BY_TEXT IP_PIN_M3u_BY_TEXT IP_PIN_M2u_BY_TEXT IP_PIN_M1u_BY_TEXT IP_PIN_APu_BY_TEXT > 0

Float_GATE_check = (Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)) NOT INTERACT IP_PIN_WAIVE
#ELSE
Float_GATE_check = Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)
#ENDIF
#ENDIF


#IFDEF CHECK_FLOATING_GATE_BY_PRIMARY_TEXT
#DEFINE CHECK_POR8
#ENDIF
#IFDEF CHECK_FLOATING_GATE_BY_TEXT
#DEFINE CHECK_POR8
#ENDIF
#IFDEF FULL_CHIP
#DEFINE CHECK_POR8
#ENDIF

#IFDEF CHECK_POR8

Float_GATE_fail_n = Float_GATE_check INTERACT NSDu > 1 BY NET
Float_GATE_fail_p = Float_GATE_check INTERACT PSDu > 1 BY NET
PO.R.8 { @ It is prohibited for Floating Gate if the effective source/drain is not connected together
  Float_GATE_fail_n NOT INSIDE SRAM_REGION
  Float_GATE_fail_p NOT INSIDE SRAM_REGION
}
PO.R.8:SRAM { @ It is prohibited for Floating Gate if the effective source/drain is not connected together
  Float_GATE_fail_n INSIDE SRAM_REGION
  Float_GATE_fail_p INSIDE SRAM_REGION
}
// PO.R.8 is checked by PO.R.8 and PO.R.8:SRAM
#ENDIF

POR9_GATE = GATEi NOT OUTSIDE RAM1TDMY
POR9_GATE_W = POi COIN INSIDE EDGE POR9_GATE
POR9_GATE_W_V = EXPAND EDGE (ANGLE POR9_GATE_W == 90) INSIDE BY GRID
POR9_GATE_W_H = EXPAND EDGE (ANGLE POR9_GATE_W == 0) INSIDE BY GRID
POR9_BAD = (CHIP INTERACT POR9_GATE_W_V) INTERACT POR9_GATE_W_H
PO.R.9:V { @ Poly gates of Pass gate (PG) of all eDRAM cells (RAM1TDMY, 160;0) must be uni-directional in a chip   
  POR9_GATE_W_V AND POR9_BAD
}
PO.R.9:H { @ Poly gates of Pass gate (PG) of all eDRAM cells (RAM1TDMY, 160;0) must be uni-directional in a chip   
  POR9_GATE_W_H AND POR9_BAD
}
// PO.R.9 is checked by PO.R.9:V and PO.R.9:H

//PO GATE SPACE CHECK
//===================
#IFDEF GS
WLD_POS2_WAIVE = COPY SRAMDMY_PERI_G
#ELSE
WLD_POS2_WAIVE = COPY EMPTYi
#ENDIF

POS2_GATEW = GATE_W NOT INSIDE EDGE WLD_POS2_WAIVE  // exclude (186;5)
POS2_CHECK = (INT [POS2_GATEW] < PO_S_2_W OPPOSITE) NOT INSIDE EDGE SRAM_REGION
#IFDEF GS
POS2_GOOD1 = TDDRC [ALL_POLY] SPACE == PO_S_2A EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD2 = TDDRC [ALL_POLY] SPACE == PO_S_2B EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD3 = TDDRC [ALL_POLY] SPACE == PO_S_2C EXCLUDE SHIELDED 4 OPPOSITE
POS2_BAD   = ((POS2_CHECK NOT COIN INSIDE EDGE POS2_GOOD1) NOT COIN INSIDE EDGE POS2_GOOD2) NOT COIN INSIDE EDGE POS2_GOOD3
#ELSE
POS2_GOOD1 = TDDRC [ALL_POLY] SPACE >= PO_S_2A <= PO_S_2B EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD2 = TDDRC [ALL_POLY] SPACE == PO_S_2C EXCLUDE SHIELDED 4 OPPOSITE
POS2_BAD   = (POS2_CHECK NOT COIN INSIDE EDGE POS2_GOOD1) NOT COIN INSIDE EDGE POS2_GOOD2
#ENDIF
GATE_EXP   = EXPAND EDGE ( GATE_W TOUCH INSIDE EDGE POS2_BAD ) INSIDE BY GRID
CONNECT GATE_EXP

#IFDEF GS
PO.S.2 { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.08 um], and allow a violation with a length ratio < 30% on one side and one segment. The length ratio = violation length / device width. This rule is for poly gate CDU control. (This check doesn't include the regions covered by layer SRAMDMY;5) (Except SRAMDMY;0 (186;0) region) = 0.14 / 0.16 / 0.2 
  GATE_ERR_EXP = (EXPAND EDGE POS2_BAD INSIDE BY GRID) NOT CDUDMY
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD > 1
  (POS2_BAD COIN INSIDE EDGE BAD_GATE) NOT INSIDE EDGE CDUDMY
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ELSE
PO.S.2 { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.06 um]. This allows a violation with a length ratio < 30% on one side and one segment. The length ratio = violation length / device width. The 0.12 ~ 0.125 are not shrinkable. This rule is for poly gate CDU control (Except SRAMDMY;0 (186;0) region) = 0.12 ~ 0.22 or 0.32 
  GATE_ERR_EXP = (EXPAND EDGE POS2_BAD INSIDE BY GRID) NOT CDUDMY
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD > 1
  (POS2_BAD COIN INSIDE EDGE BAD_GATE) NOT INSIDE EDGE CDUDMY
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ENDIF
// PO.S.2.LP.S is checked by PO.S.2
#IFNDEF FULL_CHIP
#IFDEF SKIP_POS2_BOUNDARY
DRC UNSELECT CHECK PO.S.2
#IFDEF GS
PO.S.2:SkipBoundary { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.08 um], and allow a violation with a length ratio < 30% on one side and one segment. The length ratio = violation length / device width. This rule is for poly gate CDU control. (This check doesn't include the regions covered by layer SRAMDMY;5) (Except SRAMDMY;0 (186;0) region) = 0.14 / 0.16 / 0.2 
  POOD_BOUNDARY = EXTENT (ALL_OD OR ALL_POLY) // od/po boundary
  POOD_BOUNDARYs = (POOD_BOUNDARY NOT TOUCH EDGE ALL_POLY) TOUCH EDGE SD
  A = ENC [POS2_BAD] POOD_BOUNDARYs <= PO_S_2A OPPOSITE
  POS2_BAD2 = POS2_BAD NOT COIN INSIDE EDGE A
  GATE_ERR_EXP = EXPAND EDGE POS2_BAD2 INSIDE BY GRID
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD2 > 1
  POS2_BAD COIN INSIDE EDGE BAD_GATE
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ELSE
PO.S.2:SkipBoundary { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.06 um]. This allows a violation with a length ratio < 30% on one side and one segment. The length ratio = violation length / device width. The 0.12 ~ 0.125 are not shrinkable. This rule is for poly gate CDU control (Except SRAMDMY;0 (186;0) region) = 0.12 ~ 0.22 or 0.32 
  POOD_BOUNDARY = EXTENT (ALL_OD OR ALL_POLY) // od/po boundary
  POOD_BOUNDARYs = (POOD_BOUNDARY NOT TOUCH EDGE ALL_POLY) TOUCH EDGE SD
  A = ENC [POS2_BAD] POOD_BOUNDARYs <= PO_S_2A OPPOSITE
  POS2_BAD2 = POS2_BAD NOT COIN INSIDE EDGE A
  GATE_ERR_EXP = EXPAND EDGE POS2_BAD2 INSIDE BY GRID
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD2 > 1
  POS2_BAD COIN INSIDE EDGE BAD_GATE
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ENDIF
// <PO.S.2> is checked by PO.S.2:SkipBoundary
#ENDIF
#ENDIF
// PO.S.2.LP is checked by PO.S.2 and PO.S.2:SkipBoundary
// PO.S.2.GS is checked by PO.S.2 and PO.S.2:SkipBoundary

PO.S.2.1 { @ Gate space [either one channel length >= ^PO_S_2_1_W ] >= ^PO_S_2_1
  GATE_LL = LENGTH GATE_L >= PO_S_2_1_W
  GATE_F = GATE WITH EDGE GATE_LL
  GATE_WW = POLY COIN INSIDE EDGE GATE_F
  (EXT GATE_W GATE_WW < PO_S_2_1 ABUT < 90 REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}
// PO.S.2.1LP is checked by PO.S.2.1
// PO.S.2.1GS is checked by PO.S.2.1
#IFDEF GS
PO.S.2.1.1__PO.EX.2.1 { @ Maximum OD extension on the edge gate [channel length>= ^PO_S_2_1_1_W ] and gate space [either one channel length >= ^PO_S_2_1_1_W ] in core device regions <= ^PO_S_2_1_1 . This check doesn't include the regions covered by SR_ESD.
 GATE_LL = LENGTH GATE_L >= PO_S_2_1_1_W
 GATE_WW = (POLY COIN INSIDE EDGE ((LV_GATE NOT (RODMY AND SRAMDMY)) WITH EDGE GATE_LL)) NOT INSIDE EDGE (SRESD OR LOGO)
 POS211g = EXT [GATE_WW] SR_POLY <= PO_S_2_1_1 OPPOSITE // good edge of PO.S.2.1.1
 POEX21a = GATE_WW NOT COIN INSIDE EDGE POS211g
 POEX21g = ENC [POEX21a] ODi <= PO_S_2_1_1 ABUT < 90 OPPOSITE // good edge of od extension
 POEX21a NOT COIN EDGE POEX21g
}
// PO.S.2.1.1GS is checked by PO.S.2.1.1__PO.EX.2.1
// PO.EX.2.1GS is checked by PO.S.2.1.1__PO.EX.2.1
#ENDIF


//SR_DPO CHECKS
//=============
SRDPO_EDGE_45 = SRDPO ANGLE == 45

SR_DPO.W.1 { @ Width >= 0.04 
  INT SRDPO < SRDPO_W_1 ABUT < 90 SINGULAR REGION
}
SR_DPO.W.2 { @ Width in OD2 >= 0.1 
  HV_SRDPO = SRDPO NOT OUTSIDE OD2
  (INT HV_SRDPO < SRDPO_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE OD2
}
SR_DPO.W.6 { @ Width of 45-degree dummy PO. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the rule, G.6U, in section XXX)) >= 0.17 
  INT SRDPO_EDGE_45 < SRDPO_W_6 ABUT < 90 REGION
}
SR_DPO.S.1 { @ Space to {PO OR SR_DPO} (SR_DPO overlap with PO is not allowed) >= 0.1 
  EXT SRDPO < SRDPO_S_1 ABUT < 90 SINGULAR REGION
  EXT SRDPO POLY < SRDPO_S_1 ABUT < 90 SINGULAR REGION
  SRDPO AND POLY
}
SR_DPO.S.2 { @ The SR_DPO (17;7) gate space to other gate (17;0 OR 17;7), SR_DPO (17;7) only can be used for dummy patterns >= 0.14 
  EXT SR_GATE_W < SRDPO_S_2 ABUT < 90 REGION
  EXT SR_GATE_W GATE_W < SRDPO_S_2 ABUT < 90 REGION
}
HV_DACT = DACT AND OD2
CONNECT HV_DACT
SR_DPO.S.3 { @ {((PO OR SR_DPO) AND OD) inside OD2} space in the same OD >= 0.22 
  HV_GATE_C = STAMP HV_GATE BY HV_DACT
  SR_HV_GATE_C = STAMP SR_HV_GATE BY HV_DACT
  EXT SR_HV_GATE_C < SRDPO_S_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT SR_HV_GATE_C HV_GATE_C < SRDPO_S_3 ABUT < 90 SINGULAR REGION CONNECTED
}
SR_DPO.S.4 { @ Space to OD >= 0.03 
  EXT SRDPO OD < SRDPO_S_4 ABUT < 90 SINGULAR REGION
}
SR_DPO.S.9 { @ Space of {(PO OR SR_DPO) AND RPO} >= 0.18 
  SR_PO_RPO = SR_POLY AND RPO
  EXT SR_PO_RPO < SRDPO_S_9 ABUT < 90 SINGULAR REGION
}  
SR_DPO.S.16 { @ Space to 45-degree bent {PO OR SR_DPO} >= 0.17 
  A = SR_POLY ANGLE == 45
  X = EXPAND EDGE A OUTSIDE BY SRDPO_S_16
  X AND SRDPO
} 
SR_DPO.S.17 { @ {CO inside SR_DPO} space to OD >= 0.05 
  EXT SR_COPO OD < SRDPO_S_17 ABUT < 90 SINGULAR REGION
}
SR_DPO.S.18 { @ {SR_DPO AND OD} space to RPO (overlap is not allowed.) >= 0.38 
  EXT SR_GATE RPO < SRDPO_S_18 ABUT < 90 SINGULAR REGION
  SR_GATE AND RPO
}
SR_DPO.S.19 { @ {SR_DPO AND OD} space to CO (overlap is not allowed.) >= 0.04 
  EXT SR_GATE COOD < SRDPO_S_19 ABUT < 90 SINGULAR REGION
  SR_GATE AND CO
}
SR_DPO.S.20 { @ {CO inside OD} space to 1.8V, 2.5V, 3.3V {SR_DPO AND OD} >= 0.08 
  EXT SR_HV_GATE COOD < SRDPO_S_20 ABUT < 90 SINGULAR REGION
}
SR_DPO.EN.1 { @ Enclosure of CO >= 0.01 
  ENC SR_COPO SRDPO < SRDPO_EN_1 ABUT < 90 SINGULAR REGION
}
SR_DPO.EN.2 { @ Enclosure of CO [at least 2 opposite sides] >= 0.02 
  X = RECTANGLE ENCLOSURE SR_COPO SRDPO ABUT < 90 SINGULAR GOOD 0 SRDPO_EN_2 OPPOSITE 0 SRDPO_EN_2 OPPOSITE
  Y = ENC [X] SRDPO < SRDPO_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
SR_DPO.EX.1 { @ Extension on OD (end-cap) >= 0.09 
  ENC OD SRDPO < SRDPO_EX_1 ABUT < 90 OPPOSITE SINGULAR REGION
}
SR_DPO.EX.2 { @ OD extension on SR_DPO >= 0.03 
  ENC SRDPO OD < SRDPO_EX_2 ABUT < 90 SINGULAR REGION
}
SR_DPO.L.2 { @ Length of 45-degree bent SR_DPO (minimum edge length) >= 0.26 
  LENGTH SRDPO_EDGE_45 < SRDPO_L_2
}
SR_DPO.A.1 { @ Area (This check doesn't include rectangle area with length >= 0.3 um) >= 0.022 
  A = AREA SRDPO < SRDPO_A_1
  B = RECTANGLE A
  C = ENCLOSE RECTANGLE B GRID SRDPO_A_1_L ORTHOGONAL ONLY
  A NOT C
}
SR_DPO.A.2 { @ Area [with all of edge length < 0.21 um] >= 0.055 
  A = LENGTH SRDPO >= SRDPO_A_2_L
  B = SRDPO NOT WITH EDGE A
  AREA B < SRDPO_A_2
}
SR_DPO.A.3 { @ Enclosed area >= 0.04 
  A = HOLES SRDPO INNER
  B = A NOT SRDPO
  AREA B < SRDPO_A_3
}
SR_DPO.A.4 { @ Enclosed area [with all of inner edge length < 0.21 um] >= 0.077 
  A = HOLES SRDPO INNER
  B = A NOT SRDPO
  C = LENGTH B >= SRDPO_A_4_L
  D = B NOT WITH EDGE C
  AREA D < SRDPO_A_4
}
SR_DPO.R.1 { @ {SR_DPO AND OD} must be a rectangle orthogonal to grid. (Both bent GATE and GATE with jogs are not allowed)   
  NOT RECTANGLE SR_GATE ORTHOGONAL ONLY
}
SR_DPO.R.4 { @ SR_DPO intersecting OD must form 2 or more diffusions. (except MOMDMY (155;21) region)   
  SR_GATEW = SR_GATE INSIDE EDGE OD
  X = SR_GATE NOT WITH EDGE SR_GATEW == 2
  Y = INT SR_GATEW < GRID ABUT == 90 INTERSECTING ONLY REGION
  (X OR (SR_GATE INTERACT Y)) NOT MOMDMY
} 
SR_DPO.R.5 { @ Overlap of SRAM is not allowed   
  SRDPO AND SRM
  SRDPO AND SRAMDMY
}
SR_DPO.R.6 { @ SR_DPO (17;7) can't form device, SR_DPO must be placed beside OD edge. (except MOMDMY (155;21) region)   
    OD_EDGE_pre1 = (OD NOT SR_POLY) INTERACT GATE == 1
    OD_EDGE_pre2 = (OD NOT POLY) INTERACT GATE == 1
    OD_EDGE = (OD_EDGE_pre2 NOT OD_EDGE_pre1) NOT INTERACT CO
    OD_dummy = (OD NOT INTERACT POLY) NOT INTERACT CO 
    ((SR_GATE NOT INTERACT OD_EDGE) NOT INTERACT OD_dummy) NOT MOMDMY
}


//DPO CHECKS
//================

DPO.W.1 { @ Width >= 0.4 
  A = DPO NOT INTERACT DEHVD_N
	INT A < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= 0.3 
  A = DPO NOT INTERACT DEHVD_N
  EXT A < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD (Overlap is not allowed) >= 0.2 
  A = DPO NOT INTERACT DEHVD_N
  EXT ODi A < DPO_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DPO.S.3 { @ Space to (PO OR SR_DPO) (Overlap is not allowed) >= 0.5 
  A = DPO NOT INTERACT DEHVD_N
  EXT POi A < DPO_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDPO A < DPO_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}

#IFDEF FULL_CHIP
DPO.R.1 { @ DPO is must. DPO must be an individual CAD layer (datatype 1 as default, like 17;1)
  CHIPx NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1:DPO

DPO.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed   
  NOT RECTANGLE DPO ORTHOGONAL ONLY
}



VARIABLE POS1_W_1  0.04 // user value
VARIABLE POS1_S_1  0.06 // user value
VARIABLE POS1_EN_1 0.04 // user value
VARIABLE POS1_EX_1 0.04 // user value

// POS1 CHECKS
//============
POS1.W.1 { @  Channel length in POS1 = ^POS1_W_1
  A = GATE_W INSIDE EDGE POS1   
  INT A < POS1_W_1 ABUT < 90 REGION
  B = INT A == POS1_W_1 ABUT < 90 REGION
  (GATE INTERACT POS1) NOT B
}
POS1.S.1 { @ Space to POS1, POS2 [butted is allowed, overlap is not allowed]>= ^POS1_S_1 um
  EXT POS1 < POS1_S_1 ABUT > 0 < 90 SINGULAR REGION
  EXT POS1 POS2 < POS1_S_1 ABUT > 0 < 90 SINGULAR REGION INSIDE ALSO
}
POS1.EN.1 { @ POS1 enclosure of GATE (cut is not allowed) >= ^POS1_EN_1 um
  POS1_GATE = GATE INTERACT POS1
  ENC POS1_GATE POS1 < POS1_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
POS1.EX.1 { @ PO extension on POS1 (recommended to put the PO endcap fully inside POS1) >= ^POS1_EX_1 um
  ENC POS1 POLY < POS1_EX_1 ABUT < 90 SINGULAR REGION
}


POS1.R.2 { @ POS1 without any GATE inside is not allowed.
  POS1 NOT ENCLOSE GATE
}
POS1.R.3 { @ POS1 overlap of NT_N or OD2 is not allowed.
  POS1 AND NTN
  POS1 AND OD2
}

VARIABLE POS2_W_1  0.04 // user value
VARIABLE POS2_S_1  0.06 // user value
VARIABLE POS2_EN_1 0.04 // user value
VARIABLE POS2_EX_1 0.04 // user value

// POS2 CHECKS
//============
POS2.W.1 { @  Channel length in POS2 = ^POS2_W_1
  A = GATE_W INSIDE EDGE POS2   
  INT A < POS2_W_1 ABUT < 90 REGION
  B = INT A == POS2_W_1 ABUT < 90 REGION
  (GATE INTERACT POS2) NOT B
}
POS2.S.1 { @ Space to POS1, POS2 [butted is allowed, overlap is not allowed]>= ^POS2_S_1 um
  EXT POS2 < POS2_S_1 ABUT > 0 < 90 SINGULAR REGION
  EXT POS2 POS1 < POS2_S_1 ABUT > 0 < 90 SINGULAR REGION INSIDE ALSO
}
POS2.EN.1 { @ POS2 enclosure of GATE (cut is not allowed) >= ^POS2_EN_1 um
  POS2_GATE = GATE INTERACT POS2
  ENC POS2_GATE POS2 < POS2_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
POS2.EX.1 { @ PO extension on POS2 (recommended to put the PO endcap fully inside POS2) >= ^POS2_EX_1 um
  ENC POS2 POLY < POS2_EX_1 ABUT < 90 SINGULAR REGION
}


POS2.R.2 { @ POS2 without any GATE inside is not allowed.
  POS2 NOT ENCLOSE GATE
}
POS2.R.3 { @ POS2 overlap of NT_N or OD2 is not allowed.
  POS2 AND NTN
  POS2 AND OD2
}



POSx:WARNING1 { @ illegal POSx layers (X>2) 
  COPY POS_OTHERS 
}


//DTCD CHECKS
//============
PO_TCD = POi AND TCDDMY
OD_TCD = ODi AND TCDDMY
GATE_TCD = (PO_TCD AND OD_TCD) AND TCDDMY
GATE_L_TCD = GATE_L INSIDE EDGE TCDDMY
OLD_TCD = (TCDDMY NOT TCDDMY_H) NOT TCDDMY_V
NEW_TCD = TCDDMY_H OR TCDDMY_V
GATE_W_OLD_TCD = GATE_W INSIDE EDGE OLD_TCD
GATE_W_NEW_TCD = GATE_W INSIDE EDGE NEW_TCD

DTCD.W.1 { @ Width of {(TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} = 12, 24, 9.245 
  A = NOT RECTANGLE OLD_TCD == DTCD_W_1A BY == DTCD_W_1A ORTHOGONAL ONLY
  B = NOT RECTANGLE A == DTCD_W_1A BY == DTCD_W_1A*2 ORTHOGONAL ONLY
  NOT RECTANGLE B == DTCD_W_1B BY == DTCD_W_1B ORTHOGONAL ONLY
}
DTCD.W.2 { @ Channel width of gate inside {(TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} = 5, 4, 0.43 
  LENGTH GATE_W_OLD_TCD < DTCD_W_2A
  LENGTH GATE_W_OLD_TCD > DTCD_W_2A < DTCD_W_2B
  LENGTH GATE_W_OLD_TCD > DTCD_W_2B < DTCD_W_2C
  LENGTH GATE_W_OLD_TCD > DTCD_W_2C
}
DTCD.W.3 { @ Channel length of gate inside TCDDMY = 0.04 
  LENGTH GATE_L_TCD < DTCD_W_3
  LENGTH GATE_L_TCD > DTCD_W_3
}
DTCD.S.1 { @ Space of poly gate in the same OD inside {(TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} = 0.14 
  A = (OD_TCD NOT PO_TCD) INTERACT GATE_TCD > 1
  B = GATE_W_OLD_TCD COIN OUTSIDE EDGE A
  C = EXT [B] == DTCD_S_1 OPPOSITE
  B NOT COIN INSIDE EDGE C
}
#IFDEF FULL_CHIP
DTCD.DN.2 { @ Density of Dummy TCD (2mmx2mm is one unit) >= 50 %
  ALL_WIN = DENSITY CHIP == DTCD_DN_2_WR*DTCD_DN_2_WR WINDOW DTCD_DN_2_WR STEP DTCD_DN_2_WR INSIDE OF LAYER CHIPx [AREA(CHIP)]
  BAD_WIN = DENSITY TCDDMY == 0 WINDOW DTCD_DN_2_WR STEP DTCD_DN_2_WR INSIDE OF LAYER ALL_WIN PRINT DTCD.DN.2.NO_TCDDMY
  GOOD_WIN = ALL_WIN NOT BAD_WIN
  ERR = DENSITY GOOD_WIN INSIDE OF LAYER ALL_WIN < DTCD_DN_2_R PRINT DTCD.DN.2.density
  ERR AND BAD_WIN
}
#ENDIF
DTCD.R.1 { @ TCDDMY should contain OD/PO/PP/NP/POBLK/ODBLK layer   
  TCDDMY OUTSIDE ODi
  TCDDMY OUTSIDE POi
  TCDDMY OUTSIDE PPi
  TCDDMY OUTSIDE NPi
  TCDDMY XOR (POBLK AND TCDDMY)
  TCDDMY XOR (ODBLK AND TCDDMY)
}
DTCD.R.2 { @ TCDDMY overlap of DOD, SR_DOD, DPO, SR_DPO, OD2, DCO, OD_12, NT_N, POFUSE, RPO, RH, VAR, VTH_P, VTH_N, VTL_P, VTL_N, HVD_N, HVD_P, SRM, SRAMDMY, INDDMY, BJTDMY, or MOMDMY is not allowed   
  TCDDMY AND DOD
  TCDDMY AND DPO
  TCDDMY AND SRDOD
  TCDDMY AND SRDPO
  TCDDMY AND OD2i
  TCDDMY AND OD12i
  TCDDMY AND DCOi
  TCDDMY AND NTNi
  TCDDMY AND POFUSE
  TCDDMY AND RPOi
  TCDDMY AND RH
  TCDDMY AND VARi
  TCDDMY AND VTHPi
  TCDDMY AND VTHNi
  TCDDMY AND VTLPi
  TCDDMY AND VTLNi
  TCDDMY AND HVD_N
  TCDDMY AND HVD_P
  TCDDMY AND SRM
  TCDDMY AND SRAMDMY
  TCDDMY AND INDDMY
  TCDDMY AND MOMDMY
  TCDDMY AND BJTDMY
}

// DTCD.R.3 is checked by [PO.DN.3, OD.W.2.1, OD.W.2.2, OD.W.1.R, DNW.S.2, RR:AR:POEX2, RR:RE:D:ODS1, RR:RE:D:POS1, RR:AR:POS6, RR:RE:POS18, RR:RE:SP:POEX1, and RR:GL:NWR1]


DTCD.W.1.1 { @ Dimension of TCDDMY_H = 5.71 X 3.57
  NOT RECTANGLE TCDDMY_H == DTCD_W_1_1A BY == DTCD_W_1_1B ORTHOGONAL ONLY
}
DTCD.W.1.2 { @ Dimension of TCDDMY_V = 3.6 X 6.33
  NOT RECTANGLE TCDDMY_V == DTCD_W_1_2A BY == DTCD_W_1_2B ORTHOGONAL ONLY
}
DTCD.W.2.1 { @ Channel width of gate inside TCDDMY_H or TCDDMY_V = 2.4, 0.41, 0.31
  LENGTH GATE_W_NEW_TCD < DTCD_W_2_1A
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1A < DTCD_W_2_1B
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1B < DTCD_W_2_1C
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1C
}
DTCD.S.1.1 { @ Gate space to neighboring poly inside TCDDMY_H or TCDDMY_V [channel width < 2.0um]  = 0.14 or 0.2
  X = LENGTH GATE_W_NEW_TCD < DTCD_S_1_1W
  A = EXT [X] POLY == DTCD_S_1_1A EXCLUDE SHIELDED 4 OPPOSITE
  B = EXT [X] POLY == DTCD_S_1_1B EXCLUDE SHIELDED 4 OPPOSITE
  (X NOT COIN INSIDE EDGE A) NOT COIN INSIDE EDGE B
}
DTCD.S.1.2 { @ Gate space to neighboring poly inside TCDDMY_H or TCDDMY_V [channel width >= 2.0um] = 0.14
  X = LENGTH GATE_W_NEW_TCD >= DTCD_S_1_2W
  A = EXT [X] POLY == DTCD_S_1_2 EXCLUDE SHIELDED 4 OPPOSITE
  X NOT COIN INSIDE EDGE A
}
DTCD.R.4 { @ TCDDMY_H/ TCDDMY_V must keep same block orientation and no rotation no mirror in X, Y direction. DRC will check relative coordinates of three aligment marks with square PO (0.5um x 0.5um) in the TCDDMY_H/ TCDDMY_V.
  SQUARE_PO = RECTANGLE PO_TCD == DTCD_R_4 BY == DTCD_R_4 ORTHOGONAL ONLY
#IFDEF  VERTICAL_TCD_PATTERN
  H_SQUARE_PO = SQUARE_PO AND TCDDMY_H
  H_PO_MARK1 = SHRINK TCDDMY_H LEFT BY 5.08 BOTTOM BY 0.83 RIGHT BY (DTCD_W_1_1A-5.58) TOP BY (DTCD_W_1_1B-1.33)
  H_PO_MARK2 = SHRINK TCDDMY_H LEFT BY 4.38 BOTTOM BY 0.13 RIGHT BY (DTCD_W_1_1A-4.88) TOP BY (DTCD_W_1_1B-0.63)
  H_PO_MARK3 = SHRINK TCDDMY_H LEFT BY 5.08 BOTTOM BY 0.13 RIGHT BY (DTCD_W_1_1A-5.58) TOP BY (DTCD_W_1_1B-0.63)
  H_PO_MARK = (H_PO_MARK1 OR H_PO_MARK2) OR H_PO_MARK3
  TCDDMY_H INTERACT (H_SQUARE_PO XOR H_PO_MARK)

  V_SQUARE_PO = SQUARE_PO AND TCDDMY_V
  V_PO_MARK1 = SHRINK TCDDMY_V LEFT BY 2.97 BOTTOM BY 3.59 RIGHT BY (DTCD_W_1_2A-3.47) TOP BY (DTCD_W_1_2B-4.09)
  V_PO_MARK2 = SHRINK TCDDMY_V LEFT BY 2.27 BOTTOM BY 2.89 RIGHT BY (DTCD_W_1_2A-2.77) TOP BY (DTCD_W_1_2B-3.39)
  V_PO_MARK3 = SHRINK TCDDMY_V LEFT BY 2.97 BOTTOM BY 2.89 RIGHT BY (DTCD_W_1_2A-3.47) TOP BY (DTCD_W_1_2B-3.39)
  V_PO_MARK = (V_PO_MARK1 OR V_PO_MARK2) OR V_PO_MARK3
  TCDDMY_V INTERACT (V_SQUARE_PO XOR V_PO_MARK)
#ELSE
  H_SQUARE_PO = SQUARE_PO AND TCDDMY_H
  H_PO_MARK1 = SHRINK TCDDMY_H LEFT BY 0.83 BOTTOM BY (DTCD_W_1_1A-5.58) RIGHT BY (DTCD_W_1_1B-1.33) TOP BY 5.08
  H_PO_MARK2 = SHRINK TCDDMY_H LEFT BY 0.13 BOTTOM BY (DTCD_W_1_1A-4.88) RIGHT BY (DTCD_W_1_1B-0.63) TOP BY 4.38
  H_PO_MARK3 = SHRINK TCDDMY_H LEFT BY 0.13 BOTTOM BY (DTCD_W_1_1A-5.58) RIGHT BY (DTCD_W_1_1B-0.63) TOP BY 5.08
  H_PO_MARK = (H_PO_MARK1 OR H_PO_MARK2) OR H_PO_MARK3
  TCDDMY_H INTERACT (H_SQUARE_PO XOR H_PO_MARK)

  V_SQUARE_PO = SQUARE_PO AND TCDDMY_V
  V_PO_MARK1 = SHRINK TCDDMY_V LEFT BY 3.59 BOTTOM BY (DTCD_W_1_2A-3.47) RIGHT BY (DTCD_W_1_2B-4.09) TOP BY 2.97
  V_PO_MARK2 = SHRINK TCDDMY_V LEFT BY 2.89 BOTTOM BY (DTCD_W_1_2A-2.77) RIGHT BY (DTCD_W_1_2B-3.39) TOP BY 2.27
  V_PO_MARK3 = SHRINK TCDDMY_V LEFT BY 2.89 BOTTOM BY (DTCD_W_1_2A-3.47) RIGHT BY (DTCD_W_1_2B-3.39) TOP BY 2.97
  V_PO_MARK = (V_PO_MARK1 OR V_PO_MARK2) OR V_PO_MARK3
  TCDDMY_V INTERACT (V_SQUARE_PO XOR V_PO_MARK)
#ENDIF
}

NEW_DTCD_GATE_W_V = EXPAND EDGE (ANGLE GATE_W_NEW_TCD == 90) INSIDE BY 0.005
NEW_DTCD_GATE_W_H = EXPAND EDGE (ANGLE GATE_W_NEW_TCD == 0) INSIDE BY 0.005
NEW_DTCD_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_V) INTERACT NEW_DTCD_GATE_W_H

#IFDEF CYBER_SHUTTLE
DTCD.R.5 { @ Gate direction on the TCDDMY_H/TCDDMY_V must be same as gate on the SRAM for cyber shuttle
  DTCD_V_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_V) INTERACT POR7_GATE_W_H
  DTCD_H_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_H) INTERACT POR7_GATE_W_V
  NEW_DTCD_GATE_W_V AND DTCD_V_BAD
  NEW_DTCD_GATE_W_H AND DTCD_H_BAD
}
#ENDIF


DTCD.R.6:V { @ Poly Gates in TCDDMY_H/TCDDMY_V are uni-directional in a whole chip level
  NEW_DTCD_GATE_W_V AND NEW_DTCD_BAD
}

DTCD.R.6:H { @ Poly Gates in TCDDMY_H/TCDDMY_V are uni-directional in a whole chip level
  NEW_DTCD_GATE_W_H AND NEW_DTCD_BAD
}
// DTCD.R.6 is checked by DTCD.R.6:V and DTCD.R.6:H


//VTH_N CHECKS
//============

VTHN_R = COPY VTHNs
// waive one track overlap 	  
VTHN_A1 = INT VTHNs < VTHN_W_1 ABUT < 90 REGION PROJ==0
VTHN_B1 = VTHN_R NOT (EXPAND EDGE VTHN_R INSIDE BY VTHN_R_3/2)	
VTHN_C1 = EXT VTHN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D1 = VTHN_A1 ENCLOSE VTHN_C1
// waive one track space
VTHN_A2 = EXT VTHNs < VTHN_S_1 ABUT < 90 REGION PROJ==0
VTHN_B2 = VTHN_R OR (EXPAND EDGE VTHN_R OUTSIDE BY VTHN_R_3/2)
VTHN_C2 = EXT VTHN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D2  = VTHN_A2 ENCLOSE VTHN_C2
// waive point touch
VTHN_P = EXT VTHN_R < VTHN_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_N.W.1 { @ Width >= ^VTHN_W_1. One-track(^VTHN_R_3) overlap is allowed
  X = INT VTHNs < VTHN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.1 { @ Space >= ^VTHN_S_1. Point touch of corners is allowed. One-track(^VTHN_R_3) space is allowed.
  X = EXT VTHNs < VTHN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHN_D2 OR VTHN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.2__VTH_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTHN_S_2 & in S/D direction >= ^VTHN_S_2_1
  A = GATE NOT INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHN_S_2_1 - VTHN_S_2)) OR A
  C = SIZE B BY VTHN_S_2
  VTHN AND C
}

// VTH_N.S.2 and VTH_N.S.2.1 are checked by VTH_N.S.2__VTH_N.S.2.1
VTH_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTHN_S_3
  EXT VTHN ODPO_RES_RPO < VTHN_S_3 ABUT < 90 SINGULAR
  AND VTHN ODPO_RES_RPO    
}  
VTH_N.EN.1__VTH_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTHN_EN_1 & in PO endcap direction >= ^VTHN_EN_2 
  A = GATE INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHN_EN_1 - VTHN_EN_2)) OR A
  C = SIZE B BY VTHN_EN_2
  C NOT VTHN
}
// VTH_N.EN.1 and VTH_N.EN.2 are checked by VTH_N.EN.1__VTH_N.EN.2
VTH_N.A.1 { @ Area >= ^VTHN_A_1
  (AREA VTHNs < VTHN_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.A.2 { @ Enclosed area >= ^VTHN_A_2
  A = HOLES VTHN INNER
  B = A NOT VTHN
  AREA B < VTHN_A_2
}
VTH_N.R.1 { @ Overlap of P+ ACTIVE, VAR, VTL_N, NT_N, or OD2 is not allowed   
  VTHN AND VAR
  VTHN AND OD2
  VTHN AND NTN
  VTHN AND PACT
  VTHN AND VTLN
}
// VTH_N.R.2 and VTH_N.R.3 are checked by VTH_N.W.1 and VTH_N.S.1
VTH_N.L.1 { @ 45-degree edge length >= ^VTHN_L_1 um
  VTHN_45ANGLE = VTHN ANGLE == 45
  (LENGTH VTHN_45ANGLE < VTHN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}


//VTH_P CHECKS
//============

VTHP_R = COPY VTHPs
// waive one track overlap 	  
VTHP_A1 = INT VTHPs < VTHP_W_1 ABUT < 90 REGION PROJ==0
VTHP_B1 = VTHP_R NOT (EXPAND EDGE VTHP_R INSIDE BY VTHP_R_3/2)	
VTHP_C1 = EXT VTHP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D1 = VTHP_A1 ENCLOSE VTHP_C1
// waive one track space
VTHP_A2 = EXT VTHPs < VTHP_S_1 ABUT < 90 REGION PROJ==0
VTHP_B2 = VTHP_R OR (EXPAND EDGE VTHP_R OUTSIDE BY VTHP_R_3/2)
VTHP_C2 = EXT VTHP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D2  = VTHP_A2 ENCLOSE VTHP_C2
// waive point touch
VTHP_P = EXT VTHP_R < VTHP_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_P.W.1 { @ Width >= ^VTHP_W_1. One-track(^VTHP_R_3) overlap is allowed
  X = INT VTHPs < VTHP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.1 { @ Space >= ^VTHP_S_1. Point touch of corners is allowed. One-track(^VTHP_R_3) space is allowed.
  X = EXT VTHPs < VTHP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHP_D2 OR VTHP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.2__VTH_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTHP_S_2 & in S/D direction >= ^VTHP_S_2_1
  A = GATE NOT INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHP_S_2_1 - VTHP_S_2)) OR A
  C = SIZE B BY VTHP_S_2
  VTHP AND C
}

// VTH_P.S.2 and VTH_P.S.2.1 are checked by VTH_P.S.2__VTH_P.S.2.1
VTH_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTHP_S_3
  EXT VTHP ODPO_RES_RPO < VTHP_S_3 ABUT < 90 SINGULAR
  AND VTHP ODPO_RES_RPO    
}  
VTH_P.EN.1__VTH_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTHP_EN_1 & in PO endcap direction >= ^VTHP_EN_2 
  A = GATE INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHP_EN_1 - VTHP_EN_2)) OR A
  C = SIZE B BY VTHP_EN_2
  C NOT VTHP
}
// VTH_P.EN.1 and VTH_P.EN.2 are checked by VTH_P.EN.1__VTH_P.EN.2
VTH_P.A.1 { @ Area >= ^VTHP_A_1
  (AREA VTHPs < VTHP_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.A.2 { @ Enclosed area >= ^VTHP_A_2
  A = HOLES VTHP INNER
  B = A NOT VTHP
  AREA B < VTHP_A_2
}
VTH_P.R.1 { @ Overlap of N+ ACTIVE, VAR, VTL_P, NT_N, or OD2 is not allowed   
  VTHP AND VAR
  VTHP AND OD2
  VTHP AND NTN
  VTHP AND NACT
  VTHP AND VTLP
}
// VTH_P.R.2 and VTH_P.R.3 are checked by VTH_P.W.1 and VTH_P.S.1
VTH_P.L.1 { @ 45-degree edge length >= ^VTHP_L_1 um
  VTHP_45ANGLE = VTHP ANGLE == 45
  (LENGTH VTHP_45ANGLE < VTHP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}



//VTL_N CHECKS
//============

VTLN_R = COPY VTLNs
// waive one track overlap 	  
VTLN_A1 = INT VTLNs < VTLN_W_1 ABUT < 90 REGION PROJ==0
VTLN_B1 = VTLN_R NOT (EXPAND EDGE VTLN_R INSIDE BY VTLN_R_3/2)	
VTLN_C1 = EXT VTLN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D1 = VTLN_A1 ENCLOSE VTLN_C1
// waive one track space
VTLN_A2 = EXT VTLNs < VTLN_S_1 ABUT < 90 REGION PROJ==0
VTLN_B2 = VTLN_R OR (EXPAND EDGE VTLN_R OUTSIDE BY VTLN_R_3/2)
VTLN_C2 = EXT VTLN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D2  = VTLN_A2 ENCLOSE VTLN_C2
// waive point touch
VTLN_P = EXT VTLN_R < VTLN_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_N.W.1 { @ Width >= ^VTLN_W_1. One-track(^VTLN_R_3) overlap is allowed
  X = INT VTLNs < VTLN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.1 { @ Space >= ^VTLN_S_1. Point touch of corners is allowed. One-track(^VTLN_R_3) space is allowed.
  X = EXT VTLNs < VTLN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLN_D2 OR VTLN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.2__VTL_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTLN_S_2 & in S/D direction >= ^VTLN_S_2_1
  A = GATE NOT INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLN_S_2_1 - VTLN_S_2)) OR A
  C = SIZE B BY VTLN_S_2
  VTLN AND C
}

// VTL_N.S.2 and VTL_N.S.2.1 are checked by VTL_N.S.2__VTL_N.S.2.1
VTL_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTLN_S_3
  EXT VTLN ODPO_RES_RPO < VTLN_S_3 ABUT < 90 SINGULAR
  AND VTLN ODPO_RES_RPO    
}  
VTL_N.EN.1__VTL_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTLN_EN_1 & in PO endcap direction >= ^VTLN_EN_2 
  A = GATE INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLN_EN_1 - VTLN_EN_2)) OR A
  C = SIZE B BY VTLN_EN_2
  C NOT VTLN
}
// VTL_N.EN.1 and VTL_N.EN.2 are checked by VTL_N.EN.1__VTL_N.EN.2
VTL_N.A.1 { @ Area >= ^VTLN_A_1
  (AREA VTLNs < VTLN_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.A.2 { @ Enclosed area >= ^VTLN_A_2
  A = HOLES VTLN INNER
  B = A NOT VTLN
  AREA B < VTLN_A_2
}
VTL_N.R.1 { @ Overlap of P+ ACTIVE, VAR, VTH_N, NT_N, or OD2 is not allowed   
  VTLN AND VAR
  VTLN AND OD2
  VTLN AND NTN
  VTLN AND PACT
  VTLN AND VTHN
}
// VTL_N.R.2 and VTL_N.R.3 are checked by VTL_N.W.1 and VTL_N.S.1
VTL_N.L.1 { @ 45-degree edge length >= ^VTLN_L_1 um
  VTLN_45ANGLE = VTLN ANGLE == 45
  (LENGTH VTLN_45ANGLE < VTLN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}


//VTL_P CHECKS
//============

VTLP_R = COPY VTLPs
// waive one track overlap 	  
VTLP_A1 = INT VTLPs < VTLP_W_1 ABUT < 90 REGION PROJ==0
VTLP_B1 = VTLP_R NOT (EXPAND EDGE VTLP_R INSIDE BY VTLP_R_3/2)	
VTLP_C1 = EXT VTLP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D1 = VTLP_A1 ENCLOSE VTLP_C1
// waive one track space
VTLP_A2 = EXT VTLPs < VTLP_S_1 ABUT < 90 REGION PROJ==0
VTLP_B2 = VTLP_R OR (EXPAND EDGE VTLP_R OUTSIDE BY VTLP_R_3/2)
VTLP_C2 = EXT VTLP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D2  = VTLP_A2 ENCLOSE VTLP_C2
// waive point touch
VTLP_P = EXT VTLP_R < VTLP_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_P.W.1 { @ Width >= ^VTLP_W_1. One-track(^VTLP_R_3) overlap is allowed
  X = INT VTLPs < VTLP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.1 { @ Space >= ^VTLP_S_1. Point touch of corners is allowed. One-track(^VTLP_R_3) space is allowed.
  X = EXT VTLPs < VTLP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLP_D2 OR VTLP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.2__VTL_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTLP_S_2 & in S/D direction >= ^VTLP_S_2_1
  A = GATE NOT INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLP_S_2_1 - VTLP_S_2)) OR A
  C = SIZE B BY VTLP_S_2
  VTLP AND C
}

// VTL_P.S.2 and VTL_P.S.2.1 are checked by VTL_P.S.2__VTL_P.S.2.1
VTL_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTLP_S_3
  EXT VTLP ODPO_RES_RPO < VTLP_S_3 ABUT < 90 SINGULAR
  AND VTLP ODPO_RES_RPO    
}  
VTL_P.EN.1__VTL_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTLP_EN_1 & in PO endcap direction >= ^VTLP_EN_2 
  A = GATE INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLP_EN_1 - VTLP_EN_2)) OR A
  C = SIZE B BY VTLP_EN_2
  C NOT VTLP
}
// VTL_P.EN.1 and VTL_P.EN.2 are checked by VTL_P.EN.1__VTL_P.EN.2
VTL_P.A.1 { @ Area >= ^VTLP_A_1
  (AREA VTLPs < VTLP_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.A.2 { @ Enclosed area >= ^VTLP_A_2
  A = HOLES VTLP INNER
  B = A NOT VTLP
  AREA B < VTLP_A_2
}
VTL_P.R.1 { @ Overlap of N+ ACTIVE, VAR, VTH_P, NT_N, or OD2 is not allowed   
  VTLP AND VAR
  VTLP AND OD2
  VTLP AND NTN
  VTLP AND NACT
  VTLP AND VTHP
}
// VTL_P.R.2 and VTL_P.R.3 are checked by VTL_P.W.1 and VTL_P.S.1
VTL_P.L.1 { @ 45-degree edge length >= ^VTLP_L_1 um
  VTLP_45ANGLE = VTLP ANGLE == 45
  (LENGTH VTLP_45ANGLE < VTLP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}





// VTL_N_18 CHECK
//===============
VTLN18_OD      = VTLN18 AND OD
VTLN18_PO      = VTLN18 AND POLY
VTLN18_GATE    = VTLN18 AND GATE
VTLN18_SRDPO   = VTLN18 AND SRDPO
VTLN18_GATE_W  = VTLN18_PO INSIDE EDGE VTLN18_OD
VTLN18_GATE_L  = VTLN18_OD INSIDE EDGE VTLN18_PO
VTLN18_DACT    = VTLN18 AND DACT
VTLN18_NTN     = VTLN18 AND NTN

VTL_N_18.W.1 { @ Channel length >= ^VTLN18_W_1 um 
  INT VTLN18_GATE_W < VTLN18_W_1 ABUT < 90 REGION
}
VTL_N_18.W.1.1 { @ Maximum channel length <= ^VTLN18_W_1_1 um
  LENGTH VTLN18_GATE_L > VTLN18_W_1_1
}
VTL_N_18.W.1.2 { @ SR_DPO(17;7) width in VTL_N_18 == ^VTLN18_W_1_2 um 
  VTLN18_SRDPO NOT WITH WIDTH == VTLN18_W_1_2
}
VTL_N_18.W.2 { @ Channel Width >= ^VTLN18_W_2 um 
  LENGTH VTLN18_GATE_W < VTLN18_W_2
}
VTL_N_18.W.3 { @ Channel Width <= ^VTLN18_W_3 um 
  LENGTH VTLN18_GATE_W > VTLN18_W_3
}
VTL_N_18.S.1 { @ Gate Space == ^VTLN18_S_1
  A = EXT [VTLN18_GATE] == VTLN18_S_1 ABUT < 90
  B = EXT [VTLN18_GATE] VTLN18_SRDPO == VTLN18_S_1 ABUT < 90
  VTLN18_GATE_W NOT COIN EDGE ( A OR EDGE B )
}
VTL_N_18.S.2 { @ {SR_DPO on OD} space to {gate OR SR_DPO on field} in S/D direction == ^VTLN18_S_2
  Field_SRDPO = SRDPO NOT INTERACT OD
  FSRDPO_GATE = Field_SRDPO OR VTLN18_GATE
  GOOD_EDGE = EXT [VTLN18_SRDPO] FSRDPO_GATE == VTLN18_S_2 ABUT < 90 OPPOSITE
  SUS_EDGE = VTLN18_SRDPO INSIDE EDGE VTLN18_OD
  SUS_EDGE NOT COIN EDGE GOOD_EDGE
}
VTL_N_18.S.3 { @ VTL_N_18 space to OD >= ^VTLN18_S_3 um 
  EXT VTLN18 OD < VTLN18_S_3 ABUT < 90 SINGULAR REGION
}
VTL_N_18.EN.1 { @ OD enclosure of NT_N == ^VTLN18_EN_1 um 
  VTLN18_OD_S = SIZE VTLN18_OD BY -VTLN18_EN_1
  XOR VTLN18_NTN VTLN18_OD_S
}
VTL_N_18.EN.2 { @ OD enclosure of gate in S/D direction >= ^VTLN18_EN_2 um 
  ENC VTLN18_GATE OD < VTLN18_EN_2 ABUT > 0 < 90 SINGULAR REGION
}
VTL_N_18.EN.3 { @ OD enclosure of SR_DPO in S/D direction == ^VTLN18_EN_3 um
  EDGE_OD = ((VTLN18_OD NOT VTLN18_PO) NOT VTLN18_SRDPO) INTERACT (VTLN18_PO OR VTLN18_SRDPO) == 1
  ENC_OD = INT EDGE_OD == VTLN18_EN_3 ABUT < 90 OPPOSITE REGION
  (VTLN18_SRDPO COIN EDGE EDGE_OD) NOT COIN EDGE ENC_OD
}
VTL_N_18.EN.4 { @ OD_18 enclosure of VTL_N_18 >= ^VTLN18_EN_4 um 
  VTLN18 NOT OD18
}


VTL_N_18.R.1 { @ {OD inside VTL_N_18} must be rectangular.
  NOT RECTANGLE VTLN18_OD
}

VTL_N_18.R.2 { @ VTL_N_18 overlap of VTH_N, VTH_P, VTL_N, VTL_P, PP, VAR, RPO, RH, NWDMY, BJTDMY, OD_25 is not allowed.
  VTLN18 AND VTHN
  VTLN18 AND VTHP
  VTLN18 AND VTLN
  VTLN18 AND VTLP
  VTLN18 AND PP
  VTLN18 AND VAR
  VTLN18 AND RPO
  VTLN18 AND RH
  VTLN18 AND NWDMY
  VTLN18 AND BJTDMY
  VTLN18 AND OD25
}


//PP CHECKS
//=========

ODIMP = OD COINCIDENT INSIDE EDGE IMP
PP_BEDGE = PP INSIDE EDGE OD   

PP.W.1 { @ Width >= 0.18 
  (INT PP < PP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.1 { @ Space >= 0.18 
  (EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
PP.S.2 { @ Space to N+ ACTIVE (non-butted) >= 0.08 
  WAIVE_REGION = COPY SRAM_REGION
  NACT_CHECK = NACT NOT OD_DMY
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 OPPOSITE REGION) NOT INSIDE SRAM_REGION
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 CORNER SINGULAR REGION) NOT INSIDE SRAM_REGION
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 PROJ == 0 REGION) NOT INSIDE SRAM_REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE SRAM_REGION 
}


// PP.S.3 is checked by PP.S.2 and PP.R.2

PP.S.4 { @ Space to NW STRAP (non-butted) >= 0.02 
  EXT PP NSTP < PP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.S.5 { @ {PP edge on OD} space to NMOS GATE >= 0.23 
  EXT GATEN_W PP_BEDGE < PP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEN = EXPAND EDGE GATEN_W OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J

PP.S.6 { @ Butted PW STRAP space to PO in the same OD [the butted N+ ACTIVE extending 0 < J1 < 0.13 um] >= 0.23 
  A = EX_GATEN AND BUTT_PSTP
  B = EX_GATEN AND NACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEN_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J
  C AND F
}

PP.S.7 { @ Space to N-type unsilicided OD/PO resistor >= 0.14 
  EXT PP ODPO_RES_RPO_NP < PP_S_7 ABUT < 90 SINGULAR REGION
}

PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO) >= ^PP_EN_1 
  WAIVE_REGION = COPY SRAM_REGION
  A = POLY NOT INSIDE WAIVE_REGION  
  (ENC A IMP < PP_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE WAIVE_REGION
  (POLY NOT LOGO) NOT IMP
}


PP.EX.1 { @ Extension on P+ ACTIVE >= 0.08 
  PACT_CHECK = (PACT NOT OD_DMY) NOT INSIDE SRAM_REGION  
  ENC PACT_CHECK PP < PP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PACT_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PACT_CHECK
}


PP.EX.2 { @ Extension on PW STRAP (except SEALRING_ALL (162;2)) >= 0.02 
  PSTP_CHECK = (PSTP NOT SEALRING_EXCLUDE) NOT INSIDE SRAM_REGION 
  ENC PSTP_CHECK PP < PP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PSTP_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PSTP_CHECK
}

PP.EX.3 { @ Extension on P-type unsilicided OD/PO resistor >= 0.14 
  ENC ODPO_RES_RPO_PP PP < PP_EX_3 ABUT < 90 SINGULAR
}

PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= 0.23 
  ENC GATEP_W PP_BEDGE < PP_EX_4 ABUT < 90 OPPOSITE REGION
}
PP.O.1 { @ Overlap of OD >= 0.1 
  INT OD PP < PP_O_1 ABUT < 90 > 0 SINGULAR REGION
}
PP.A.1 { @ Area >= 0.11 
  AREA (PP NOT INSIDE SRAM_REGION) < PP_A_1
}
PP.A.2 { @ Enclosed area >= 0.11 
  A = HOLES PP INNER
  B = A NOT PP
  (AREA B < PP_A_2) NOT INSIDE SRAM_EXCLUDE
}
PP.A.3 { @ Area of butted PW STRAP >= 0.021 
  AREA BUTT_PSTP < PP_A_3
}

PP.R.1 { @ PP must fully cover {PMOS GATE SIZING 0.08 um} >= 0.08 
  CHECK_GATE = GATE_PP NOT INSIDE SRAM_REGION
  EXGATE_PP = SIZE CHECK_GATE BY PP_R_1
  EXGATE_PP NOT PP
}

PP.R.2 { @ Overlap of NP is not allowed   
  PP AND NP
}
// PP.R.3 is checked by OD.R.1
// PP.R.4 is checked by PP.EN.1
PP.L.1 { @ 45-degree edge length >= 0.5 
  PP_45ANGLE = PP ANGLE == 45
  (LENGTH PP_45ANGLE < PP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}



//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD  
NP.W.1 { @ Width >= 0.18 
  (INT NP < NP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
NP.S.1 { @ Space >= 0.18 
  (EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.2 { @ Space to P+ ACTIVE (non-butted) >= 0.08 
  PACT_CHECK = PACT NOT OD_DMY  
  (EXT NP PACT_CHECK < NP_S_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE SRAM_REGION
  X = EXT NP [PACT_CHECK] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE SRAM_REGION
}
// NP.S.3 is checked by NP.S.2 and PP.R.2
NP.S.4 { @ Space to PW STRAP (non-butted) >= 0.02 
  WAIVE_REGION = COPY SRAM_REGION
  (EXT NP PSTP < NP_S_4 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE WAIVE_REGION
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE WAIVE_REGION
}
NP.S.5 { @ {NP edge on OD} space to PMOS GATE >= 0.23 
  EXT GATEP_W NP_BEDGE < NP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEP = EXPAND EDGE GATEP_W OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J

NP.S.6 { @ Butted NW STRAP space to PO in the same OD [the butted P+ ACTIVE extending 0 < J1 < 0.13 um] >= 0.23 
  A = EX_GATEP AND BUTT_NSTP
  B = EX_GATEP AND PACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEP_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J
  C AND F
}
NP.S.7 { @ Space to P-type unsilicided OD/PO resistor >= 0.14 
  EXT NP ODPO_RES_RPO_PP < NP_S_7 ABUT < 90 SINGULAR REGION
}

// NP.EN.1 is checked by PP.EN.1
NP.EX.1 { @ Extension on N+ACTIVE >= ^NP_EX_1
  NACT_CHECK = ((NACT NOT ODWR) NOT OD_DMY) NOT INSIDE SRAM_REGION
  ENC NACT_CHECK NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NACT_CHECK] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NACT_CHECK
}
NP.EX.2 { @ Extension on NW STRAP (except NWROD) >= 0.02 
  ENC NSTP NP < NP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NSTP
}
NP.EX.3 { @ Extension on N-type unsilicided OD/PO resistor >= 0.14 
  ENC ODPO_RES_RPO_NP NP < NP_EX_3 ABUT < 90 SINGULAR REGION
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= 0.23 
  ENC GATEN_W NP_BEDGE < NP_EX_4 ABUT < 90 OPPOSITE REGION
}
NP.O.1 { @ Overlap of OD >= 0.1 
  INT OD NP < NP_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NP.A.1 { @ Area >= 0.11 
  AREA (NP NOT INSIDE SRAM_EXCLUDE) < NP_A_1
}
NP.A.2 { @ Enclosed area >= 0.11 
  A = HOLES NP INNER
  B = A NOT NP
  (AREA B < NP_A_2) NOT INSIDE SRAM_REGION
}
NP.A.3 { @ Area of butted NW STRAP >= 0.021 
  AREA BUTT_NSTP < NP_A_3
}  

NP.R.1 { @ NP must fully cover {NMOS GATE SIZING ^NP_R_1 um}
  CHECK_GATE = GATE_NP NOT INSIDE SRAM_REGION
  EXGATE_NP = SIZE CHECK_GATE BY NP_R_1
  EXGATE_NP NOT NP
}

// NP.R.2 is checked by PP.R.2
// NP.R.3 is checked by OD.R.1
// NP.R.4 is checked by PP.EN.1
NP.L.1 { @ 45-degree edge length >= 0.5 
  NP_45ANGLE = NP ANGLE == 45
  (LENGTH NP_45ANGLE < NP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}





//LOGICAL OPERATION RULE
//======================
VARIABLE  NLDDN1V_SU  0.089
VARIABLE  NLDDN1V_SD  0.178
VARIABLE  NLDDN2V_SU  0.089
VARIABLE  NLDDN2V_SD  0.178
VARIABLE  VTLN_SU     0.089
VARIABLE  VTLN_SD     0.178
VARIABLE  PLDDP1V_SU  0.089
VARIABLE  PLDDP1V_SD  0.178
VARIABLE  PLDDP2V_SU  0.089
VARIABLE  PLDDP2V_SD  0.178
VARIABLE  VTLP_SU     0.089
VARIABLE  VTLP_SD     0.178

VTLND = COPY VTLN 
VTLPD = COPY VTLP 


NP_NOT_NW = NP NOT NWEL
NLDDN1 = ((((NP_NOT_NW NOT OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
NLDDN1V = SIZE (SIZE (SIZE NLDDN1 BY NLDDN1V_SU) BY - NLDDN1V_SD) BY NLDDN1V_SU

#IFDEF N45_LP
NLDDN2_18 = (((((NP_NOT_NW AND OD18) OR (((POLY AND OD) AND OD18) NOT NWEL)) NOT RH) NOT VAR) NOT POFUSE) NOT BJTDMY
NLDDN2_25 = ((((((NP_NOT_NW AND OD25) OR (((POLY AND OD) AND OD25) NOT NWEL)) NOT RH) NOT VAR) NOT POFUSE) NOT BJTDMY) NOT NTN
NLDDN2 = NLDDN2_18 OR NLDDN2_25
#ELSE
#IFDEF N40_LP
NLDDN2_18 = (((((((NP_NOT_NW AND OD18) OR ((((POLY AND OD) AND OD18) NOT NWEL) AND NP)) NOT ((PP NOT NWEL) AND OD18)) NOT RH) NOT VAR) NOT POFUSE) NOT BJTDMY) NOT HVD_N
NLDDN2_25 = ((((((((((NP_NOT_NW AND OD25) OR ((((POLY AND OD) AND OD25) NOT NWEL) AND NP)) NOT ((PP NOT NWEL) AND OD25)) NOT RH) NOT VAR) NOT NTN) NOT POFUSE) NOT BJTDMY) NOT HVD_N) NOT DEHVD_N) OR (HVD_P NOT (HVD_P NOT (HVD_P AND POLY)))
NLDDN2 = NLDDN2_18 OR NLDDN2_25
#ELSE
#IFDEF N45_LPG
NLDDN2 = ((((((NP_NOT_NW AND OD18) OR (((POLY AND OD) AND OD18) NOT NWEL)) OR NTN) NOT RH) NOT VAR) NOT POFUSE) NOT BJTDMY
#ELSE
#IFDEF N40_LPG
NLDDN2 = (((((((NP_NOT_NW AND OD33) OR ((((POLY AND OD) AND OD33) NOT NWEL) AND NP)) NOT ((PP NOT NWEL) AND OD33)) NOT RH) NOT VAR) NOT NTN) NOT POFUSE) NOT BJTDMY
#ELSE
#IFDEF N40_G
NLDDN2 = (((((NP_NOT_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT NTN) NOT POFUSE
#ELSE
NLDDN2 = (((((NP_NOT_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT NTN) NOT POFUSE
#ENDIF
#ENDIF
#ENDIF
#ENDIF
#ENDIF

NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY NLDDN2V_SU) BY - NLDDN2V_SD) BY NLDDN2V_SU

VTL_N_LD = SIZE (SIZE (SIZE ((OD2 OR NWEL) OR VTLND) BY VTLN_SU) BY -VTLN_SD) BY VTLN_SU

PP_AND_NW = PP AND NWEL
PLDDP1 = ((((PP_AND_NW NOT OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
PLDDP1V = SIZE (SIZE (SIZE PLDDP1 BY PLDDP1V_SU) BY - PLDDP1V_SD) BY PLDDP1V_SU
PLDDP2 = ((((PP_AND_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY PLDDP2V_SU) BY - PLDDP2V_SD) BY PLDDP2V_SU

VTL_P_LD = SIZE (SIZE (SIZE ((NWEL NOT OD2) NOT VTLPD) BY VTLP_SU) BY -VTLP_SD) BY VTLP_SU

LDN.EX.1 { @ NP extension on NW >= ^LDN_EX_1 um. 
@ LDN.EX.2  NP extension on OD2 >= ^LDN_EX_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_EX_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_EX_1
  A = INT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

LDN.O.1 { @ NP overlap of OD2 >= ^LDN_O_1
@ LDN.EX.1  NP extension on NW  >= ^LDN_O_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_O_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_O_1
  A = INT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDN.EX.1 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.2 is checked by LDN.EX.1
// LDN.EX.3 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.4 is checked by LDN.EX.1 and LDN.O.1

LDP.EX.1 { @ PP extension on OD2 >= ^LDP_EX_1
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_EX_1 
@ LDP.EX.3  PP extension on VAR. >= ^LDP_EX_1
@ LDP.O.1  PP overlap of NW. >= ^LDP_EX_1
  A = INT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}


LDP.O.2 { @ PP overlap of OD2 >= ^LDP_O_2 
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_O_2 
@ LDP.EX.3  PP extension on VAR. >= ^LDP_O_2
@ LDP.O.1  PP overlap of NW. >= ^LDP_O_2
  A = INT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.EX.2 is checked by LDP.EX.1 and LDP.O.2
// LDP.EX.3 is checked by LDP.EX.1 and LDP.O.2
// LDP.O.1 is checked by LDP.EX.1 and LDP.O.2

VT.S.1 { @ VTL_N space to {OD2 OR NW} >= ^VT_S_1 
 A = INT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
 B = EXT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
 (NOT ENCLOSE RECTANGLE A 0.1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (NOT ENCLOSE RECTANGLE B 0.1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (INT VTL_N_LD < VT_S_1 ABUT < 90 CORNER REGION) NOT INSIDE SRAM_EXCLUDE
 D = INT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION
 (D INTERACT (D NOT VTLN_D1)) NOT INSIDE SRAM_EXCLUDE
 E = EXT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION
 (E INTERACT (E NOT VTLN_P)) NOT INSIDE SRAM_EXCLUDE
 F = EXT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION
 (F INTERACT (F NOT VTLN_D2)) NOT INSIDE SRAM_EXCLUDE
}

VT.EX.2 { @ NW extension on {OD2 OR VTL_P} >= ^VT_EX_2 
 A = INT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
 B = EXT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
 (NOT ENCLOSE RECTANGLE A 0.1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (NOT ENCLOSE RECTANGLE B 0.1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 C = INT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER REGION SINGULAR
 (C INTERACT (C NOT VTLP_P)) NOT INSIDE SRAM_EXCLUDE
 D = INT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION
 (D INTERACT (D NOT VTLP_D2)) NOT INSIDE SRAM_EXCLUDE
 (EXT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER REGION) NOT INSIDE SRAM_EXCLUDE 
 F = EXT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION
 (F INTERACT (F NOT VTLP_D1)) NOT INSIDE SRAM_EXCLUDE
}


// ESDIMP CHECKS
//==============

ESDIMP.W.1 { @ Width >= ^ESDIMP_W_1 um
  INT ESDIMP < ESDIMP_W_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.S.1 { @ Space >= ^ESDIMP_S_1 um
  EXT ESDIMP < ESDIMP_S_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.EN.1 { @ (OD NOT PO) enclosure of ESDIMP. ESDIMP must be fully inside (OD NOT PO) >= 0.4 
  OD_NPO = OD NOT POLY
  ENC ESDIMP OD_NPO < ESDIMP_EN_1 ABUT < 90 SINGULAR REGION
  ESDIMP NOT OD_NPO
}
ESDIMP.A.1 { @ Area >= 1 
  AREA ESDIMP < ESDIMP_A_1
}
ESDIMP.A.2 { @ Enclosed area >= 1 
  A = HOLES ESDIMP INNER
  B = A NOT ESDIMP
  AREA B < ESDIMP_A_2
}
ESDIMP.R.1 { @ ESDIMP must be fully inside N+ ACTIVE   
  ESDIMP NOT NACT
}



//RPO CHECKS
//==========

FPO1A      = FPO1 NOT SDI
Wide_RPO   = RPO INTERACT (SIZE RPO BY - RPO_EX_1_1_W /2)

RPO.W.1 { @ Width >= 0.4 
  INT RPO < RPO_W_1 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= 0.4 
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= 0.22 
  EXT RPO OD < RPO_S_2 ABUT < 90 SINGULAR REGION
}
RPO.S.3 { @ Space to CO (overlap of CO is not allowed.) >= 0.22 
  EXT RPO CO < RPO_S_3 ABUT < 90 SINGULAR REGION
  (RPO AND CO) NOT ICOVL
}
RPO.S.4 { @ Min. RPO space to gate ^RPO_S_4 um 
  NOGT = GATE NOT (SDI OR ICOVL)

  EXT RPO NOGT < RPO_S_4 ABUT < 90 SINGULAR REGION
  RPO AND NOGT
}
RPO.S.5 { @ Space to PO >= 0.3 
  EXT RPO FPO1 < RPO_S_5 ABUT < 90 SINGULAR REGION
}

OD_NOSDI = OD NOT SDI
RPO.EX.1 { @ Extension on unsilicided OD/PO (This check doesn't include the regions covered by the layer SDI) >= 0.22 
  ENC OD_NOSDI RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  RPO INSIDE OD_NOSDI
  RPO INSIDE FPO1A  
}
RPO.EX.1.1 { @ Extension on unsilicided OD/PO [RPO width > 10 um] (This check doesn't include the regions covered by the layer SDI) >= 0.3 
  ENC OD_NOSDI Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
}
Wide_RPO2 = RPO INTERACT (WITH WIDTH RPO <= RPO_EX_1_2_W)
RPO.EX.1.2 { @ Extension on unsilicided OD/PO [RPO width <= 0.43 um] (This check doesn't include the regions covered by the layer SDI) >= 0.3 
  ENC OD_NOSDI Wide_RPO2 < RPO_EX_1_2 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO2 < RPO_EX_1_2 ABUT < 90 SINGULAR REGION
}
RPO.EX.2 { @ OD extension on RPO >= 0.22 
  ENC RPO OD < RPO_EX_2 ABUT < 90 SINGULAR REGION
}
RPO.A.1 { @ Area >= 1.0 
  (AREA RPOs < RPO_A_1) NOT INSIDE SRAM_EXCLUDE
}
RPO.A.2 { @ Enclosed area >= 1.0 
  A = HOLES RPO INNER
  B = A NOT RPO
  AREA B < RPO_A_2
}  
RPO.R.1 { @ Butted NP/PP on unsilicided OD/PO is not allowed   
  X = (RPO AND POLY) OR (RPO AND OD)
  NX = X AND NP
  PX = X AND PP    
  Y  = NX INTERACT PX
  X INTERACT Y
}  




//RES CHECKS
//==========


RES.W.1:OD { @ Width of unsilicide OD resistor >= ^RES_W_1
  INT OD_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION
}
RES.W.1:PO { @ Width of unsilicide PO resistor >= ^RES_W_1
  INT PO_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION
}
// RES.W.1 is checked by RES.W.1:OD and RES.W.1:PO

RES.L.1:OD { @ Length of unsilicide OD resistor >= ^RES_L_1
  RES_L = OD_RES_RPO INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_L_1
  CHECK_RES = OD_RES_RPO WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_L_1/2 - GRID*2) INSIDE OF OD_RES_RPO STEP OD_S_1*0.7
  C = CHECK_RES NOT B
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
RES.L.1:PO { @ Length of unsilicide PO resistor >= ^RES_L_1
  RES_L = PO_RES_RPO INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_L_1
  CHECK_RES = PO_RES_RPO WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_L_1/2 - GRID*2) INSIDE OF PO_RES_RPO STEP PO_S_1*0.7
  C = CHECK_RES NOT B
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
// RES.L.1 is checked by RES.L.1:OD and RES.L.1:PO

OD_RES_RPO_L = EXPAND EDGE (OD_RES_RPO NOT INSIDE EDGE OD) BY 0.005
OD_RES_RPO_W = EXPAND EDGE (OD_RES_RPO INSIDE EDGE OD) BY 0.005
CONNECT OD_RES_RPO_L OD_RES_RPO_W

RES.R.1:OD { @ Square number (length/width) of unsilicided OD/PO resistor. (This check doesn't include the region covered by RHDMY1 (117;4) for non-precision usage) >= 1 
  X = NET AREA RATIO OD_RES_RPO_L OD_RES_RPO_W < RES_R_1
  X NOT RHDMY1
}

PO_RES_RPO_L = EXPAND EDGE (PO_RES_RPO NOT INSIDE EDGE POLY) BY 0.005
PO_RES_RPO_W = EXPAND EDGE (PO_RES_RPO INSIDE EDGE POLY) BY 0.005
CONNECT PO_RES_RPO_L PO_RES_RPO_W

RES.R.1:PO { @ Square number (length/width) of unsilicided OD/PO resistor. (This check doesn't include the region covered by RHDMY1 (117;4) for non-precision usage) >= 1 
  X = NET AREA RATIO PO_RES_RPO_L PO_RES_RPO_W < RES_R_1
  X NOT RHDMY1
}
// RES.R.1 is checked by RES.R.1:OD and RES.R.1:PO

RES.S.1 { @ RH space to Gate in source or drain direction for unsilicided OD resistor >= ^RES_S_1
  RH_CHECK = RH INTERACT OD_RES_RPO
  EXT RH_CHECK GATE_W < RES_S_1 ABUT < 90 OPPOSITE REGION
}
RES.S.2 { @ RH space to GATE (overlap is not allowed) >= ^RES_S_2
  EXT RH GATE < RES_S_2 ABUT<90 SINGULAR REGION
  RH AND GATE
}


RES.EN.1 { @ RH enclosure of unsilicided/silicided OD/PO resistor >= ^RES_EN_1
  ENC OD_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION
  ENC PO_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION
}

RES.R.2 { @ RPO intersecting {(PO AND RH) AND RPDMY} must form two or more POs
  A = (POLY INTERACT PO_RES_RPO) NOT PO_RES_RPO
  PO_RES_RPO NOT INTERACT A >=  2
}
RES.R.3 { @ RPO intersecting {(OD AND RH) AND RPDMY} must form two or more ODs
  A = (OD INTERACT OD_RES_RPO) NOT OD_RES_RPO
  OD_RES_RPO NOT INTERACT A >=  2
}
RES.R.4 { @ {RPDMY AND PO} must be fully covered by RH
  (RPDMY AND POLY) NOT RH
}
RES.R.5 { @ {RPDMY AND OD} must be fully covered by RH
  (RPDMY AND OD) NOT RH
}
RES.R.21 { @ NP OD resistor is not allowed interacting with NW
           @ DRC will flag {(((OD AND NP) AND RH) AND RPDMY) INTERACT NW}
  X = (NPOD AND RH) AND RPDMY
  X INTERACT NWEL
}
RES.R.22 { @ PP OD resistor is only allowed inside NW
           @ DRC will flag {(((OD AND PP) AND RH) AND RPDMY) NOT INSIDE NW}
  X = (PPOD AND RH) AND RPDMY
  X NOT INSIDE NWEL
}





//VAR CHECKS
//==========
VAR_GATE     = GATE NOT OUTSIDE VAR
VAR_GATE_W   = VAR_GATE INSIDE EDGE OD
DVAR_GATE = GATE NOT OUTSIDE DVAR
DVAR_GATE_W = DVAR_GATE INSIDE EDGE OD

VAR.W.1 { @ Channel length of {gate AND VAR} >= 0.2 
  INT VAR_GATE_W < VAR_W_1 ABUT < 90 REGION
}

VAR.W.3 { @ Channel length of {(gate AND OD2) AND VAR} >= 0.4 
  VAR_HV_GATE_W = (VAR_GATE_W INSIDE EDGE OD2) OUTSIDE EDGE DVAR
  INT VAR_HV_GATE_W < VAR_W_3 ABUT < 90 REGION
}


VAR.W.4 { @ Channel width of {gate AND VAR} >= 0.32 
  LENGTH VAR_GATE_W < VAR_W_4 
}


VAR.W.5 { @ Channel length of { (gate AND OD2) AND DVAR } >= ^VAR_W_5
  DVAR_HV_GATE_W = DVAR_GATE_W INSIDE EDGE OD2 
  INT DVAR_HV_GATE_W < VAR_W_5 ABUT < 90 REGION    
} 

VAR.S.1 { @ Space to ACTIVE >= 0.13 
  EXT VAR DACT < VAR_S_1 ABUT < 90 SINGULAR REGION
}
VAR.EN.1 { @ Enclosure of OD (Cut is not allowed) >= 0.16 
  ENC OD VAR < VAR_EN_1 ABUT < 90 SINGULAR REGION
  OD CUT VAR
}
VAR.R.1 { @ VAR layer must be drawn to fully cover the varactor devices. DRC only checks VAR fully cover gate   
@ VAR layer must be drawn to fully cover the differential varactor
  DVAR_GATE NOT VAR 
  VAR_GATE NOT VAR
}
VAR.R.2 { @ Overlap of VTL_N, VTL_P, VTH_N, VTH_P, NT_N, or RPO is not allowed   
  VAR AND VTLN
  VAR AND VTLP
  VAR AND VTHN
  VAR AND VTHP
  VAR AND NTN
  VAR AND RPO
}

VAR.R.3 { @ PP overlap of {(gate AND NW) AND VAR} is not allowed   
  (VAR_GATE AND NWEL) AND PP
}

VAR.R.3.1 { @ NP overlap of {(gate AND PW) AND VAR} is not allowed   
  (VAR_GATE AND PWEL) AND NP
}

VAR.R.4 { @ Overlap to {(PO AND ACTIVE) SIZING 0.16 um} is not allowed   
  VAR_E = SIZE VAR BY VAR_W_1 	// For filtering only
  VAR_EXG = (GATE INTERACT VAR_E) OUTSIDE VAR
  VAR_EXGS = SIZE VAR_EXG BY VAR_R_4
  VAR AND VAR_EXGS
}
VAR.R.5 { @ NP must fully cover {(((VAR AND (GATE AND NW)) SIZING 0.19 um) AND OD) SIZING 0.13 um}   
  A = SIZE ((VAR AND GATE) AND NWEL) BY VAR_R_5_X
  B = SIZE (A AND OD) BY VAR_R_5_Y
  B NOT NP
}
VAR.R.5.1 { @ PP must fully cover {(((VAR AND (GATE AND PW)) SIZING 0.19 um) AND OD) SIZING 0.13 um}   
  A = SIZE ((VAR AND GATE) AND PWEL) BY VAR_R_5_1_X
  B = SIZE (A AND OD) BY VAR_R_5_1_Y
  B NOT PP
}

VAR.R.6 { @ DVAR layer must be drawn to fully cover the IO differential MOSVAR
  DVAR_GATE NOT DVAR
}
VAR.R.7 { @ DVAR overlap of {gate NOT OD2} is not allowed 
  DVAR AND LV_GATE
}
VAR.R.8 { @ PP overlap of {gate AND DVAR} is not allowed 
  PP AND DVAR_GATE 
}
#IFDEF GS
VAR.A.1 { @ Maximum core unit varactor gate area for GS process
  AREA ((GATE AND VAR) NOT OD2) > VAR_A_1
}
#ELSE
VAR.A.1 { @ Maximum core unit varactor gate area for LPG G device
  AREA (((GATE AND VAR) NOT OD2) AND DCO) > VAR_A_1
}
#ENDIF


#ENDIF // FRONT_END


//CO CHECKS
//=========

SRAM_CO  = COi INSIDE SRAM_REGION
SRAM_BCO = SRAM_CO NOT COPUSH   // sram butted contact, {CO not 30;11}
SRAM_SCO = SRAM_CO NOT SRAM_BCO // sram square contact

CO.W.1 { @ Width (maximum = minimum) (Except butted CO in SRAMDMY;0 (186;0) region only) = 0.06 
  NOT RECTANGLE (((COi NOT SEALRING_EXCLUDE) NOT ICOVL) NOT SRAM_BCO) == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
}
// CO.W.3 is checked by CO.W.1

CO.S.1 { @ Space (Except SRAMDMY;0 (186;0) region) >= 0.08 
  (EXT CO < CO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO.S.2 { @ Space to 3-neighboring CO (distance < 0.11 um) (Except SRAMDMY;0 (186;0) region) >= 0.1 
  COx = RECTANGLE COs == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  X = WITH NEIGHBOR COx > 2 SPACE < CO_S_2_D
  (EXT X COx < CO_S_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO_NODAL = STAMP CO BY COi

CO.S.2.1 { @ Space [different net] (Except SRAMDMY;0 (186;0) region) >= 0.11 
  (EXT CO_NODAL < CO_S_2_1 ABUT < 90 NOT CONNECTED REGION) NOT INSIDE SRAM_REGION
}

CO.S.3 { @ Space to GATE (Overlap of GATE is not allowed) [space >= 0.035 um is allowed inside SRAM word line driver covered by layer 186;5 or 186;4] (Except SRAMDMY;0 (186;0) region) >= 0.04 
  A = EXT COOD GATE < CO_S_3 ABUT < 90 SINGULAR REGION
  (A NOT INSIDE SRAMDMY_PERI) NOT INSIDE SRAM_REGION
  (CO AND GATE) NOT INSIDE SRAM_REGION
	// Checks for SRAM periphery are implemented by WLD.R.2
}
CO.S.4 { @ {CO inside PO} space to OD (Except SRAMDMY;0 (186;0) region) >= 0.05 
  (EXT COPO OD < CO_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO.S.5 { @ {CO inside OD} space to I/O GATE >= 0.08 
  EXT COOD HV_GATE < CO_S_5 ABUT < 90 SINGULAR REGION
}


CO.S.6 { @ Space to butted PP/NP edge on OD (overlap of NP/PP boundary on OD is not allowed.) >= 0.04 
  EXT NP_PP_BTE COOD < CO_S_6 ABUT < 90 REGION
  ENC COOD NP_PP_BTE < CO_S_6 ABUT < 90 REGION 
  COOD CUT PP
  ENC COOD PP < 0.001 ABUT < 90 SINGULAR REGION
  ENC COOD NP < 0.001 ABUT < 90 SINGULAR REGION
}

// CO.EN.0 is checked by 'CO.EN.1', 'CO.EN.1.1', 'CO.EN.1.3', 'CO.EN.1.2', 'CO.EN.2', 'CO.EN.3', 'CO.EN.5', and 'CO.EN.6'
CO.EN.1 { @ Enclosure by OD (Except SRAMDMY;0 (186;0) region) >= 0.01 
  ENC (COOD NOT INSIDE SRAM_REGION) OD < CO_EN_1 ABUT < 90 SINGULAR REGION
}

PICK_UP = DSTP NOT VAR

COOD_ACT = COOD NOT INSIDE PICK_UP  
COOD_STP = COOD INSIDE PICK_UP

CO.EN.1.1__CO.EN.1.3 { @ Enclosure by OD [at least two opposite sides] >= ^CO_EN_1_1 or [four sides] >= ^CO_EN_1_3, do not check butted contact
  X = RECTANGLE ENCLOSURE (COOD_ACT NOT SRAM_BCO) OD ABUT < 90 SINGULAR GOOD 0 CO_EN_1_1 OPPOSITE 0 CO_EN_1_1 OPPOSITE
  ENC X OD < CO_EN_1_3 ABUT < 90 SINGULAR REGION
}
// CO.EN.1.1 is checked by CO.EN.1.1__CO.EN.1.3
// CO.EN.1.3 is checked by CO.EN.1.1__CO.EN.1.3

CO.EN.1.2 { @ Enclosure by OD for {STRAP NOT VAR} [at least 2 opposite sides] >= 0.02 
  X = RECTANGLE ENCLOSURE COOD_STP OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_2 OPPOSITE CO_EN_1 CO_EN_1_2 OPPOSITE
  Y = ENC [X] OD < CO_EN_1_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

// Enclosure by PO is defined by either {CO.EN.2 and CO.EN.3} or {CO.EN.5 and CO.EN.6} 
// CO.EN.2 and CO.EN.3 are checked by CO.EN.0
// CO.EN.5 and CO.EN.6 are checked by CO.EN.0


CO.EN.0 { @ Enclosure by PO is defined by either {CO.EN.2 and CO.EN.3} or {CO.EN.5 and CO.EN.6}, that is enclosure by poly must meet either 10/20/10/20nm or 5/30/15/30nm
  X = (CO NOT INSIDE SRAM_REGION) NOT SEALRING_EXCLUDE
  LE_10 = X WITH EDGE (ENC [COPO] POLYs < CO_EN_2 ABUT < 90 SINGULAR)
  GE_10 = (COPO AND X) NOT LE_10
  EN3_ERR = RECTANGLE ENCLOSURE GE_10 POLYs ABUT >0 < 90 SINGULAR GOOD CO_EN_2 CO_EN_3 OPPOSITE CO_EN_2 CO_EN_3 OPPOSITE
  LE_5 = X WITH EDGE (ENC [LE_10] POLYs < CO_EN_5A ABUT < 90 SINGULAR)
  GE_5_LE_10 = LE_10 NOT LE_5
  EN6_ERR = RECTANGLE ENCLOSURE GE_5_LE_10 POLYs ABUT >0 < 90 SINGULAR GOOD CO_EN_5A CO_EN_6 OPPOSITE CO_EN_5A CO_EN_6 OPPOSITE
  EN5_SUS = GE_5_LE_10 NOT EN6_ERR
  EN5_ERR = EN5_SUS WITH EDGE (EN5_SUS TOUCH EDGE (ENC [EN5_SUS] POLYs < CO_EN_5B ABUT < 90 SINGULAR OPPOSITE)) > 1
  (COPO AND X) NOT POLY
  Y1 = ENC [EN3_ERR] POLYs < CO_EN_3 ABUT < 90 OPPOSITE
  Z1 = EN3_ERR TOUCH EDGE Y1
  INT Z1 < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION    // CO.EN.3
  ENC LE_5 POLYs < CO_EN_5A ABUT < 90 SINGULAR REGION     // CO.EN.5 (0.005)
  Y2 = ENC [EN6_ERR] POLYs < CO_EN_6 ABUT < 90 OPPOSITE
  Z2 = EN6_ERR TOUCH EDGE Y2
  INT Z2 < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION      // CO.EN.6
  ENC EN5_ERR POLYs < CO_EN_5B ABUT < 90 SINGULAR REGION OPPOSITE // CO.EN.5 (0.015)
}

// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1
// CO.R.4 is checked by M1.EN.1 and CO.EN.0


#IFDEF BACK_END


//M1 CHECKS
//=========
#IFNDEF WIDE_ADJUST
M1Wide_2_0 = M1 WITH WIDTH > M1_S_2_W            // 0.17
M1Wide_2_1 = M1Wide_2_0 WITH WIDTH > M1_S_2_1_W  // 0.24
M1Wide_2_2 = M1Wide_2_1 WITH WIDTH > M1_S_2_2_W  // 0.31
M1Wide_2_3 = M1Wide_2_2 WITH WIDTH > M1_S_2_3_W  // 0.62
M1Wide_3_0 = M1Wide_2_3 WITH WIDTH > M1_S_3_W    // 1.5
#ELSE
M1Wide_2_4 = M1 WITH WIDTH > M1_S_2_4_W          // 0.17
M1Wide_2_0 = M1Wide_2_4 WITH WIDTH > M1_S_2_W    // 0.19
M1Wide_2_5 = M1Wide_2_0 WITH WIDTH > M1_S_2_5_W  // 0.24
M1Wide_2_1 = M1Wide_2_5 WITH WIDTH > M1_S_2_1_W  // 0.265
M1Wide_2_6 = M1Wide_2_1 WITH WIDTH > M1_S_2_6_W  // 0.31
M1Wide_2_2 = M1Wide_2_6 WITH WIDTH > M1_S_2_2_W  // 0.345
M1Wide_2_7 = M1Wide_2_2 WITH WIDTH > M1_S_2_7_W  // 0.62
M1Wide_2_3 = M1Wide_2_7 WITH WIDTH > M1_S_2_3_W  // 0.685
M1Wide_3_0 = M1Wide_2_3 WITH WIDTH > M1_S_3_W    // 1.65
#ENDIF

M1_EDGE_45 = M1 ANGLE == 45

M1.W.1 { @ Width >= 0.07 
  (INT M1s < M1_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE    
}
M1.W.2 { @ Width of 45-degree bent M1. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section XXX)) >= 0.17 
  INT M1_EDGE_45 < M1_W_2 ABUT < 90 REGION
}
M1.W.3 { @ Maximum width (This check doesn't include the SEALRING_ALL (162;2) region) <= 4.5 
  (M1_MAX_WIDTH WITH WIDTH > M1_W_3) NOT INSIDE IND_REGION
}
// M1.W.3.S is checked by M1.W.3
M1.S.1 { @ Space >= 0.07 
  EXT M1 < M1_S_1 ABUT < 90 SINGULAR REGION
}
M1.S.2 { @ Min. Metal space (for W> ^M1_S_2_W um & parallel length > ^M1_S_2_L um) >= ^M1_S_2 um
  X = EXT M1Wide_2_0 M1 < M1_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_L+GRID
}
// M1.S.2.S is checked by M1.S.2
M1.S.2.1 { @ Min. Metal space (for W> ^M1_S_2_1_W um & parallel length > ^M1_S_2_1_L um) >= ^M1_S_2_1 um
  X = EXT M1Wide_2_1 M1 < M1_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_1_L+GRID
}
// M1.S.2.1.S is checked by M1.S.2.1
M1.S.2.2 { @ Min. Metal space (for W> ^M1_S_2_2_W um & parallel length > ^M1_S_2_2_L um) >= ^M1_S_2_2 um
  X = EXT M1Wide_2_2 M1 < M1_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_2_L+GRID
}
// M1.S.2.2.S is checked by M1.S.2.2
M1.S.2.3 { @ Min. Metal space (for W> ^M1_S_2_3_W um & parallel length > ^M1_S_2_3_L um) >= ^M1_S_2_3 um
  X = EXT M1Wide_2_3 M1 < M1_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_3_L+GRID
}
// M1.S.2.3.S is checked by M1.S.2.3
#IFDEF WIDE_ADJUST
M1.S.2.4 { @ Min. Metal space (for W> ^M1_S_2_4_W um & parallel length > ^M1_S_2_4_L um) >= ^M1_S_2_4 um
  X = EXT M1Wide_2_4 M1 < M1_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_4_L+GRID
}
// M1.S.2.4.S is checked by M1.S.2.4
M1.S.2.5 { @ Min. Metal space (for W> ^M1_S_2_5_W um & parallel length > ^M1_S_2_5_L um) >= ^M1_S_2_5 um
  X = EXT M1Wide_2_5 M1 < M1_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_5_L+GRID
}
// M1.S.2.5.S is checked by M1.S.2.5
M1.S.2.6 { @ Min. Metal space (for W> ^M1_S_2_6_W um & parallel length > ^M1_S_2_6_L um) >= ^M1_S_2_6 um
  X = EXT M1Wide_2_6 M1 < M1_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_6_L+GRID
}
// M1.S.2.6.S is checked by M1.S.2.6
M1.S.2.7 { @ Min. Metal space (for W> ^M1_S_2_7_W um & parallel length > ^M1_S_2_7_L um) >= ^M1_S_2_7 um
  X = EXT M1Wide_2_7 M1 < M1_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_7_L+GRID
}
// M1.S.2.7.S is checked by M1.S.2.7
#ENDIF
M1.S.3 { @  Min. Metal space (for W> ^M1_S_3_W um & parallel length > ^M1_S_3_L um) >= ^M1_S_3 um
  X = EXT M1Wide_3_0 M1 < M1_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  (ENCLOSE RECTANGLE Y 0.001 M1_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M1.S.3.S is checked by M1.S.3
M1.S.5 { @ If M1 has parallel run length with opposite M1 along two adjacent edges of M1 [any one edge < ^M1_S_5_W Q = ^M1_S_5_Q um and its opposite extension< ^M1_S_5_T distance from the corner of the two edges of M1], then one of the space (S1 or S2) to opposite M1 must be >= ^M1_S_5 um.  
  A = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M1_S_5_W
  B = EXT [A] M1 < M1_S_5 ABUT < 90 OPPOSITE EXTENDED M1_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M1] < M1_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M1_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M1_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  (EXT O M1 < M1_S_5 ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION 

}
M1.S.6 { @ Space to 45-degree bent M1 >= 0.17 
  X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY M1_S_6
  X AND M1
}

M1.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M1_S_1_1
  I = STAMP M1_5V_ALL BY M1i
  EXT I M1i < M1_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M1.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M1_S_8_2
  I = STAMP M1_5V_ALL BY M1i
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  EXT I VIA1i < M1_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}



M1.S.8 { @ Space to VIA1 [different net, either VIA1 or M1 connects to 1.8V ~ 3.3V net] >= 0.1 
  I = STAMP M1_HV_ALL BY M1i
  J = STAMP (VIA1i AND M1_HV_ALL) BY M1i
  EXT I VIA1i < M1_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

M1.S.9 { @ This rule is to check the Metal (A) space with the neighboring VIA1 [either VIA1 or M1 connects to > 3.3V and <= 5V net]. The DRC methodology to find Metal (A) is as follows: Find an edge (B) of the metal line-end [edge length <= 0.12 um] Run length (C) from edge (B) inside metal >= 0.13 um Jog length (D) <= 0.01 um within 0.13 um run length Extend 0.06 um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied >= 0.15 
  LINE_END_pre   = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M1_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M1_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M1 < M1_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M1_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M1_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M1 < M1_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M1_S_9_A INSIDE BY GRID
  B = STAMP A BY M1i
  I = STAMP (A INTERACT M1_5V_ALL) BY M1i
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  X1 = EXT I VIA1i < M1_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT J B < M1_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = X1 OR X2
  COPY Y
  A INTERACT Y
}



M1.S.8.1 { @ Space to VIA1 [different net, either VIA1 or M1 connects to >= 1.5V and < 1.8V net] >= 0.08 
  I = STAMP M1_MV_ALL BY M1i
  J = STAMP (VIA1i AND M1_MV_ALL) BY M1i
  EXT I VIA1i < M1_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}



// M1.EN.0 is checked by M1.EN.1 and M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2
M1.EN.1 { @ Enclosure of CO >= 0.00, do not check butted contact in SRAM
  ((COs NOT SRAM_BCO) NOT M1s) NOT CSRDMY
}
M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2 { @ Enclosure of CO [at least two opposite sides] >= ^M1_EN_2, or [four sides] >= ^M1_EN_3, or [four sides] >= ^M1_EN_3_1 with [at least two opposite sides] >= ^M1_EN_3_2
  A = RECTANGLE ENCLOSURE (COs NOT INSIDE SRAM_REGION) M1s ABUT > 0 < 90 GOOD 0 M1_EN_2 OPPOSITE 0 M1_EN_2 OPPOSITE
  B = ENC A M1s < M1_EN_3_1 ABUT < 90 SINGULAR REGION
  C = RECTANGLE ENCLOSURE (A NOT TOUCH B) M1s ABUT < 90 GOOD M1_EN_3_1 M1_EN_3_2 OPPOSITE M1_EN_3_1 M1_EN_3_2 OPPOSITE
  (B OR (ENC C M1s < M1_EN_3 ABUT < 90 SINGULAR REGION)) NOT CSRDMY
}
// M1.EN.2 is checked by M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2
// M1.EN.3 is checked by M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2
// M1.EN.3.1 is checked by M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2
// M1.EN.3.2 is checked by M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2


M1Wide_0.7 = M1Wide_2_0 WITH WIDTH > M1_EN_4_W
M1.EN.4 { @ Enclosure of CO [M1 width > 0.7 um] (except CSRDMY (166;0) region) >= 0.03 
   A = (COs INSIDE M1Wide_0.7) NOT CSRDMY
   ENC A M1s < M1_EN_4 ABUT < 90 SINGULAR REGION
}

M1.EN.5 { @ Enclosure of CO [metal width >= 0.11 um, space < 0.08 um and parallel run length > 0.27 um] (This check doesn't include 2 or more COs present in the metal intersection) >= 0.015 
  X = M1s WITH WIDTH >= M1_EN_5_W
  sus_co = COs NOT OUTSIDE X
  sus_M1 = M1i INTERACT sus_co
  sus_M1_OD = (sus_M1 AND (OD NOT POLY)) ENCLOSE COi == 1
  sus_M1_PO = (sus_M1 AND POLY) ENCLOSE COi == 1
  check_co = sus_co AND (sus_M1_OD OR sus_M1_PO)
  G1 = EXT [X] M1s < M1_EN_5_S OPPOSITE MEASURE ALL
  G2 = (EXT X M1s < M1_EN_5_S OPPOSITE REGION MEASURE ALL) NOT M1s
  I = ENCLOSE RECTANGLE G2 GRID M1_EN_5_L+GRID
  check_edge = EXT G1 [I] < M1_EN_5 OPPOSITE ABUT < 90
  (EXT check_co check_edge < M1_EN_5 ABUT < 90 REGION OPPOSITE) NOT INSIDE SRAM_EXCLUDE
}

M1.A.1 { @ Area (Except SRAMDMY;0 (186;0) region) >= 0.0215 
  AREA (M1s NOT INSIDE SRAM_REGION) < M1_A_1
}

M1.A.2 { @ Area [with all of edge length < 0.17 um]. (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (Except SRAMDMY;0 (186;0) region) >= 0.055 
  A = AREA (M1s NOT INSIDE SRAM_REGION) < M1_A_2
  B = LENGTH A >= M1_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M1_A_2_W M1_A_2_L1 ORTHOGONAL ONLY
}

VARIABLE M1_A_3pre ((M1_A_3 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))*((M1_A_3 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))/3.141 // user value

M1.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M1s INNER < M1_A_3pre
  (AREA ( X NOT M1i ) < M1_A_3) NOT INSIDE SRAM_EXCLUDE
}


// M1.DN.0 is checked by M1.DN.1, M1.DN.1.1, M1.DN.4, and DM1.R.1
#IFDEF CHECK_LOW_DENSITY
M1.DN.1 { @ Minimum local density [window ^M1_DN_1_W um x ^M1_DN_1_W um, stepping ^M1_DN_1_S um] >= ^M1_DN_1
  M1_CHECK = M1x NOT M1_EXC_LOW
  CHIP_CHECK = CHIP NOT M1_EXC_LOW

  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK < M1_DN_1 WINDOW M1_DN_1_W STEP M1_DN_1_S INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1_EXC_LOW) >= M1_DN_1_E
  DENSITY F M1_CHECK CHIP_CHECK < M1_DN_1 WINDOW M1_DN_1_W STEP M1_DN_1_S INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.1.density
         [ !AREA(F)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M1.DN.1.1 { @ Maximum local density [window ^M1_DN_1_1_W um x ^M1_DN_1_1_W um, stepping ^M1_DN_1_1_S um] <= ^M1_DN_1_1
  M1_CHECK = M1x NOT M1_EXC_HIGH
  CHIP_CHECK = CHIP NOT M1_EXC_HIGH
  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK > M1_DN_1_1 WINDOW M1_DN_1_1_W STEP M1_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1_EXC_HIGH) >= M1_DN_1_1_E
  DENSITY F M1_CHECK CHIP_CHECK > M1_DN_1_1 WINDOW M1_DN_1_1_W STEP M1_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M1.DN.1.1.density
         [ !!AREA(F)*AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}

M1.DN.4 { @ The metal density difference between any two neighboring checking windows including DM1EXCL [window ^M1_DN_4_W um x ^M1_DN_4_W um, stepping ^M1_DN_4_W um]  <= ^M1_DN_4
  DENSITY M1x CHIP <=1 WINDOW M1_DN_4_W BACKUP GRADIENT > M1_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M1.DN.4.density
  	[ AREA(M1x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M1.DN.6 { @ Metal Desnsity >= ^M1_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M1_DN_6_W_A um x ^M1_DN_6_W_A um, stepping ^M1_DN_6_S_A um] >= ^M1_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M1_DN_6_W_BC um x ^M1_DN_6_W_BC um, stepping ^M1_DN_6_S_BC um < ^M1_DN_6] <= ^M1_DN_6_A_B um2, except merged low density windows width <= ^M1_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M1_DN_6_W_BC um x ^M1_DN_6_W_BC um, stepping ^M1_DN_6_S_BC um < ^M1_DN_6] <= ^M1_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_6_E_A um for condition-A and >= ^M1_DN_6_E_BC um for both condition-B/condition-C 
  M1_CHECK = M1x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_A STEP M1_DN_6_S_A INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M1_DN_6_E_A
  DENSITY F_A M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_A STEP M1_DN_6_S_A INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6_A.density
         [ !AREA(F_A)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_BC STEP M1_DN_6_S_BC INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M1_DN_6_E_BC
  A = DENSITY F_B M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_BC STEP M1_DN_6_S_BC INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6_BC.density
         [ !AREA(F_B)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M1_DN_6_A_B
  C = SIZE B BY M1_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M1_DN_6_A_C
}
#ENDIF



// M1.R.1 can't be checked

M1_CORE = M1x NOT SEALRING_EXCLUDE


M1.R.2 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
    M1_PIN NOT INTERACT M1i == 1
}



//VIA1 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M2Wide_2_0 = M2 WITH WIDTH > M2_S_2_W            // 0.17
M2Wide_2_1 = M2Wide_2_0 WITH WIDTH > M2_S_2_1_W  // 0.24
M2Wide_2_2 = M2Wide_2_1 WITH WIDTH > M2_S_2_2_W  // 0.31
M2Wide_2_3 = M2Wide_2_2 WITH WIDTH > M2_S_2_3_W  // 0.62
M2Wide_3_0 = M2Wide_2_3 WITH WIDTH > M2_S_3_W    // 1.65
#ELSE
M2Wide_2_4 = M2 WITH WIDTH > M2_S_2_4_W          // 0.17
M2Wide_2_0 = M2Wide_2_4 WITH WIDTH > M2_S_2_W    // 0.19
M2Wide_2_5 = M2Wide_2_0 WITH WIDTH > M2_S_2_5_W  // 0.24
M2Wide_2_1 = M2Wide_2_5 WITH WIDTH > M2_S_2_1_W  // 0.265
M2Wide_2_6 = M2Wide_2_1 WITH WIDTH > M2_S_2_6_W  // 0.31
M2Wide_2_2 = M2Wide_2_6 WITH WIDTH > M2_S_2_2_W  // 0.345
M2Wide_2_7 = M2Wide_2_2 WITH WIDTH > M2_S_2_7_W  // 0.62
M2Wide_2_3 = M2Wide_2_7 WITH WIDTH > M2_S_2_3_W  // 0.685
M2Wide_3_0 = M2Wide_2_3 WITH WIDTH > M2_S_3_W    // 1.65
#ENDIF

M1Wide_R2_VIA1 = M1Wide_2_0 WITH WIDTH > VIA1_R_2_W        // 0.21
M1Wide_R4_VIA1 = M1Wide_R2_VIA1 WITH WIDTH > VIA1_R_4_W    // 0.21
M1Wide_R3_VIA1 = M1Wide_R4_VIA1 WITH WIDTH > VIA1_R_3_W    // 0.55
M1Wide_R5_VIA1 = M1Wide_R3_VIA1 WITH WIDTH > VIA1_R_5_W    // 1.4
M1Wide_R6_VIA1 = M1Wide_R5_VIA1 WITH WIDTH > VIA1_R_6_W    // 2.1
M2Wide_R2_VIA1 = M2Wide_2_0 WITH WIDTH > VIA1_R_2_W      // 0.21
M2Wide_R4_VIA1 = M2Wide_R2_VIA1 WITH WIDTH > VIA1_R_4_W  // 0.21
M2Wide_R3_VIA1 = M2Wide_R4_VIA1 WITH WIDTH > VIA1_R_3_W  // 0.55
M2Wide_R5_VIA1 = M2Wide_R3_VIA1 WITH WIDTH > VIA1_R_5_W  // 1.4
M2Wide_R6_VIA1 = M2Wide_R5_VIA1 WITH WIDTH > VIA1_R_6_W  // 2.1

VIA1.W.1 { @ Width (maximum = minimum) (Except SEALRING_ALL (162;2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA1i NOT INSIDE (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
}
VIA1.S.1 { @ Space >= 0.07 
  EXT VIA1i < VIA1_S_1 ABUT < 90 SINGULAR REGION
}

VIA1.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA1_S_1_1
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  EXT J VIA1i < VIA1_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

VIA1.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA1i > 2 SPACE < VIA1_S_2_D
  EXT X VIA1i < VIA1_S_2 ABUT < 90 SINGULAR REGION
}
VIA1.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA1i < VIA1_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA1.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA1i < VIA1_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA1.EN.0 is checked by VIA1.EN.1 and VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1

VIA1.EN.1 { @ Enclosure by Mx or M1 >= 0.0 
  VIA1 NOT M1
}

VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1 { @ Enclosure by M1 [at least two opposite sides] >= ^VIA1_EN_2, or [four sides] >= ^VIA1_EN_4 with [at least two opposite sides] >= ^VIA1_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA1 NOT SEALRING_EXCLUDE) M1s ABUT < 90 SINGULAR GOOD 0 VIA1_EN_2 OPPOSITE 0 VIA1_EN_2 OPPOSITE
  Y = ENC X M1s < VIA1_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M1s ABUT < 90 GOOD VIA1_EN_4 VIA1_EN_4_1 OPPOSITE VIA1_EN_4 VIA1_EN_4_1 OPPOSITE
  (Y OR (ENC Z M1s < VIA1_EN_4_1 ABUT < 90 SINGULAR REGION)) NOT SEALRING_DB
}
// VIA1.EN.2 is checked by VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1
// VIA1.EN.4 is checked by VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1
// VIA1.EN.4.1 is checked by VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1


VIA1.EN.3.1 { @ VIA1 Enclosure by M1 [metal width >= 0.11 um, space < 0.08 um and parallel run length > 0.27 um] (This check doesn't include 2 or more via1 present in the metal intersection) >= 0.015 
  X = M1s WITH WIDTH >= VIA1_EN_3_1_W
  sus_via1 = VIA1s NOT OUTSIDE X
  check_via1 = sus_via1 AND (((M1i INTERACT sus_via1) AND (M2i INTERACT sus_via1)) ENCLOSE VIA1i == 1)
  G1 = EXT [X] M1s < VIA1_EN_3_1_S OPPOSITE MEASURE ALL
  G2 = (EXT X M1s < VIA1_EN_3_1_S OPPOSITE REGION MEASURE ALL) NOT M1s
  I = ENCLOSE RECTANGLE G2 GRID VIA1_EN_3_1_L+GRID
  check_edge = EXT G1 [I] < VIA1_EN_3_1 OPPOSITE ABUT < 90
  (EXT check_via1 check_edge < VIA1_EN_3_1 ABUT < 90 REGION OPPOSITE) NOT INSIDE SRAM_EXCLUDE

}

// VIA1.R.1 is checked by VIA1.W.1
// VIA1.R.2 is checked by VIA1.R.2__VIA1.R.3
// VIA1.R.3 is checked by VIA1.R.2__VIA1.R.3
VIA1.R.2__VIA1.R.3 { @ When M1 or M2 width > ^VIA1_R_2_W um, more than one VIA1 is required.
                    @ 2 vias spacing should be <= ^VIA1_R_2_S1 um or 4 vias spacing should be <= ^VIA1_R_2_S2 um
                    @ When M1 or M2 width > ^VIA1_R_3_W um, more than three VIA1 is required.
                    @ 4 vias spacing should be <= ^VIA1_R_3_S1 um or 9 vias spacing should be <= ^VIA1_R_3_S2 um
                    @ not check SRAM region					
   M2OvpM1_W_ = (M1Wide_R2_VIA1 AND M2) OR (M2Wide_R2_VIA1 AND M1)
   M2OvpM1_B  = (M1Wide_R3_VIA1 AND M2) OR (M2Wide_R3_VIA1 AND M1)
   M2OvpM1_W  = M2OvpM1_W_ NOT M2OvpM1_B 
   Checked_VIA1_W_ = VIA1_EXD NOT OUTSIDE M2OvpM1_W
   Checked_VIA1_B  = VIA1_EXD NOT OUTSIDE M2OvpM1_B
   Checked_VIA1_W  = Checked_VIA1_W_ NOT Checked_VIA1_B
   M1_effect = M1i INTERACT M2OvpM1_W_
   M2_effect = M2i INTERACT M2OvpM1_W_
   effect_M2OvpM1_ = M1_effect AND M2_effect
   effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W_
   effect_VIA = VIA1_EXD INTERACT effect_M2OvpM1

   V1Merged_A = SIZE effect_VIA BY VIA1_R_2_S1/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_B = SIZE V1Merged_A BY (VIA1_R_2_S2 - VIA1_R_2_S1)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_C = SIZE V1Merged_B BY (VIA1_R_3_S2 - VIA1_R_2_S2)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
   V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
   V1Merged_A4R = V1Merged_A2 INTERACT effect_VIA < 4
   V1Merged_A4 = V1Merged_A2 OUTSIDE V1Merged_A4R
   V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
   V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R
   V1Merged_C9R = V1Merged_C INTERACT effect_VIA < 9
   V1Merged_C9 = V1Merged_C OUTSIDE V1Merged_C9R

   GMergeW = V1Merged_A2 OR V1Merged_B4
   GMergeB = V1Merged_A4 OR V1Merged_C9
   GVIA_W = Checked_VIA1_W INTERACT GMergeW
   GVIA_B = Checked_VIA1_B INTERACT GMergeB
   GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
   GOOD_AREA_B = M2OvpM1_B INTERACT GVIA_B
   (Checked_VIA1_W OUTSIDE GOOD_AREA_W) NOT INSIDE SRAM_REGION
   (Checked_VIA1_B OUTSIDE GOOD_AREA_B) NOT INSIDE SRAM_REGION
}
// VIA1.R.2.S is checked by VIA1.R.2__VIA1.R.3
// VIA1.R.3.S is checked by VIA1.R.2__VIA1.R.3

// VIA1.R.4 is checked by VIA1.R.4:M1 and VIA1.R.4:M2
VIA1.R.4:M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W).)   
  Branch1 = ((SIZE M1Wide_R4_VIA1 BY VIA1_R_4_D + GRID) NOT M1Wide_R4_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_R4_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Wide_R4_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  ERR = (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
  ERR NOT INSIDE SRAM_REGION
}

VIA1.R.4:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W)).   
  Branch1 = ((SIZE M2Wide_R4_VIA1 BY VIA1_R_4_D + GRID) NOT M2Wide_R4_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R4_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Wide_R4_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  ERR = (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
  ERR NOT INSIDE SRAM_REGION   
}
// VIA1.R.4.S is checked by VIA1.R.4:M1 and VIA1.R.4:M2

// VIA1.R.5 is checked by VIA1.R.5:M1 and VIA1.R.5:M2
VIA1.R.5:M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W)).
  Branch1 = ((SIZE M1Wide_R5_VIA1 BY VIA1_R_5_D + GRID) NOT M1Wide_R5_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_R5_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Wide_R5_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA1.R.5:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W)).
  Branch1 = ((SIZE M2Wide_R5_VIA1 BY VIA1_R_5_D + GRID) NOT M2Wide_R5_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R5_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Wide_R5_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA1.R.5.S is checked by VIA1.R.5:M1 and VIA1.R.5:M2

// VIA1.R.6 is checked by VIA1.R.6:M1 and VIA1.R.6:M2
M1Big_R6_VIA1 = ENCLOSE RECTANGLE M1Wide_R6_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6:M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M1Big_R6_VIA1 BY VIA1_R_6_D + GRID) NOT M1Big_R6_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Big_R6_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Big_R6_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M2Big_R6_VIA1 = ENCLOSE RECTANGLE M2Wide_R6_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_R6_VIA1 BY VIA1_R_6_D + GRID) NOT M2Big_R6_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_R6_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Big_R6_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA1.R.6.S is checked by VIA1.R.6:M1 and VIA1.R.6:M2

// VIA1.R.7 is checked by VIA1.EN.1
// VIA1.R.9 can't be checked

VIA1.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA1_R_11_L1 um and both two metal hole area <= ^VIA1_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA1_R_11_L2 um and the width of metal bar is <= ^VIA1_R_11_W um.
  W = M2i WITH WIDTH <= VIA1_R_11_W   
  H_HOLE = (HOLES M2i INNER <= VIA1_R_11_A) INTERACT W
  A0 = M2i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA1_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA1_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA1_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA1_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA1_R_11_L2+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA1
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA1_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA1 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M1i INTERACT CHECK_VIA)) INTERACT VIA1i == 1)
}
// VIA1.R.11.S is checked by VIA1.R.11

VIA1.R.12 { @ VIA1 connected to DM1, DM1_O, DM2, DM2_O is not allowed
  VIA1 INTERACT DUM1
  VIA1 INTERACT DUM2
  VIA1 INTERACT DM1_O
  VIA1 INTERACT DM2_O
}  

//M2 CHECKS
//=========


M2_EDGE_45 = M2 ANGLE == 45

M2.W.1 { @ Width >= 0.07 
  INT M2 < M2_W_1 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section XXX)) >= 0.17 
  INT M2_EDGE_45 < M2_W_2 ABUT < 90 REGION
}
M2.W.3 { @ Maximum width <= ^M2_W_3 um, exclude SEALRING_ALL 
  M2_MAX_WIDTH WITH WIDTH > M2_W_3
}
// M2.W.3.S is checked by M2.W.3
M2.S.1 { @ Space >= 0.07 
  EXT M2 < M2_S_1 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Min. Metal space (for W> ^M2_S_2_W um & parallel length > ^M2_S_2_L um) >= ^M2_S_2 um
  X = EXT M2Wide_2_0 M2 < M2_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_L+GRID
}
// M2.S.2.S is checked by M2.S.2
M2.S.2.1 { @ Min. Metal space (for W> ^M2_S_2_1_W um & parallel length > ^M2_S_2_1_L um) >= ^M2_S_2_1 um
  X = EXT M2Wide_2_1 M2 < M2_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_1_L+GRID
}
// M2.S.2.1.S is checked by M2.S.2.1
M2.S.2.2 { @ Min. Metal space (for W> ^M2_S_2_2_W um & parallel length > ^M2_S_2_2_L um) >= ^M2_S_2_2 um
  X = EXT M2Wide_2_2 M2 < M2_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_2_L+GRID
}
// M2.S.2.2.S is checked by M2.S.2.2
M2.S.2.3 { @ Min. Metal space (for W> ^M2_S_2_3_W um & parallel length > ^M2_S_2_3_L um) >= ^M2_S_2_3 um
  X = EXT M2Wide_2_3 M2 < M2_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_3_L+GRID
}
// M2.S.2.3.S is checked by M2.S.2.3
#IFDEF WIDE_ADJUST
M2.S.2.4 { @ Min. Metal space (for W> ^M2_S_2_4_W um & parallel length > ^M2_S_2_4_L um) >= ^M2_S_2_4 um
  X = EXT M2Wide_2_4 M2 < M2_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_4_L+GRID
}
// M2.S.2.4.S is checked by M2.S.2.4
M2.S.2.5 { @ Min. Metal space (for W> ^M2_S_2_5_W um & parallel length > ^M2_S_2_5_L um) >= ^M2_S_2_5 um
  X = EXT M2Wide_2_5 M2 < M2_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_5_L+GRID
}
// M2.S.2.5.S is checked by M2.S.2.5
M2.S.2.6 { @ Min. Metal space (for W> ^M2_S_2_6_W um & parallel length > ^M2_S_2_6_L um) >= ^M2_S_2_6 um
  X = EXT M2Wide_2_6 M2 < M2_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_6_L+GRID
}
// M2.S.2.6.S is checked by M2.S.2.6
M2.S.2.7 { @ Min. Metal space (for W> ^M2_S_2_7_W um & parallel length > ^M2_S_2_7_L um) >= ^M2_S_2_7 um
  X = EXT M2Wide_2_7 M2 < M2_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_7_L+GRID
}
// M2.S.2.7.S is checked by M2.S.2.7
#ENDIF
M2.S.3 { @ Min. Metal space (for W> ^M2_S_3_W um & parallel length > ^M2_S_3_L um) >= ^M2_S_3 um
  X = EXT M2Wide_3_0 M2 < M2_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  (ENCLOSE RECTANGLE Y 0.001 M2_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M2.S.3.S is checked by M2.S.3
M2.S.5 { @ Space at Mx line-end (W < 0.1 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge < Q distance from the corner of the 2 edges], then one of the spaces (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um (R)) (M2.S.5 except SRAMDMY;0 (186;0) region) >= 0.1 
  A = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M2_S_5_W
  B = EXT [A] M2 < M2_S_5 ABUT < 90 OPPOSITE EXTENDED M2_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M2] < M2_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M2_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M2_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  (EXT O M2 < M2_S_5 ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION 

}

M2.S.5.1 { @ Space at Mx line-end (W<Q=^M2_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M2_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M2_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M2_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M2_S_5_1 um.
  A = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M2_S_5_1_W
  V1_EN = ENC [VIA1i] A < M2_S_5_1_E ABUT < 90 OPPOSITE
  M2_EN = ENC V1_EN [A] < M2_S_5_1_E ABUT < 90 OPPOSITE
  M2_SA = EXT A [M2] < M2_S_5_1 ABUT < 90 OPPOSITE EXTENDED M2_S_5_1_T
  M2_SB = EXT [A] M2_SA < M2_S_5_1 ABUT < 90 OPPOSITE EXTENDED M2_S_5_1_T
  M2_END = (A TOUCH INSIDE EDGE M2_EN) TOUCH INSIDE EDGE M2_SB
  EN_B = ENC V1_EN [M2_END] < M2_S_5_1_E2 OPPOSITE
  EN_C = ENC V1_EN [M2_END] < M2_S_5_1_E3 OPPOSITE
  EN_D = ENC V1_EN [M2_END] < M2_S_5_1_E4 OPPOSITE
  S1_B = EXT [M2_END] M2_SA < M2_S_5_1_S2 OPPOSITE EXTENDED M2_S_5_1_T
  S1_C = EXT [M2_END] M2_SA < M2_S_5_1_S3 OPPOSITE EXTENDED M2_S_5_1_T
  S1_D = EXT [M2_END] M2_SA < M2_S_5_1_S4 OPPOSITE EXTENDED M2_S_5_1_T
  PASS_B = (M2_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M2_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M2_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M2_CHECK = ((M2_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M2_CHECK [M2] < M2_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M2_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M2_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE M2_SB
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M2 < M2_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA1i (O TOUCH INSIDE EDGE P) < M2_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA1i INTERACT Q
  VIA_GOOD = VIA1i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M2 AND M1) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M2_CHECK < M2_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M2.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY M2_S_6
  X AND M2
}


M2.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M2_S_1_1
  I = STAMP M2_5V_ALL BY M2i
  EXT I M2i < M2_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M2.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M2_S_8_2
  I = STAMP M2_5V_ALL BY M2i
  J = STAMP (VIA1i AND M2_5V_ALL) BY M2i
  EXT I VIA1i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  EXT I VIA2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}



M2.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] >= 0.1 
  I = STAMP M2_HV_ALL BY M2i
  J = STAMP (VIA1i AND M2_HV_ALL) BY M2i
  EXT I VIA1i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_HV_ALL) BY M2i
  EXT I VIA2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M2.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] >= 0.08 
  I = STAMP M2_MV_ALL BY M2i
  J = STAMP (VIA1i AND M2_MV_ALL) BY M2i
  EXT I VIA1i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_MV_ALL) BY M2i
  EXT I VIA2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M2.S.9 { @ This rule is to check the Metal (A) space with the neighboring VIAx [either VIAx or Mx connects to > 3.3V and <= 5V net]. The DRC methodology to find Metal (A): Find an edge (B) of the metal line-end [edge length <= 0.12 um] Run length (C) from edge (B) inside metal >= 0.13 um Jog length (D) <= 0.01 um within 0.13 um run length Extend 0.06 um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied >= 0.15 
  LINE_END_pre   = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M2_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M2_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M2 < M2_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M2_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M2_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M2 < M2_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M2_S_9_A INSIDE BY GRID
  B = STAMP A BY M2i
  I = STAMP (A INTERACT M2_5V_ALL) BY M2i
  J = STAMP (VIA1i AND M2_5V_ALL) BY M2i
  K = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  X1 = EXT I VIA1i < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA2i  < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}



// M2.EN.0 is checked by M2.EN.1 and M2.EN.2__M2.EN.3__M2.EN.3.1
M2.EN.1 { @ Enclosure of VIAx-1 >= 0.0 
  VIA1 NOT M2
}
M2.EN.2__M2.EN.3__M2.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M2_EN_2, or [four sides] >= ^M2_EN_3 with [at least two opposite sides] >= ^M2_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA1 NOT SEALRING_ALL) M2 ABUT < 90 SINGULAR GOOD 0 M2_EN_2 OPPOSITE 0 M2_EN_2 OPPOSITE
  Y = ENC X M2 < M2_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M2 ABUT < 90 GOOD M2_EN_3 M2_EN_3_1 OPPOSITE M2_EN_3 M2_EN_3_1 OPPOSITE
  Y OR (ENC Z M2 < M2_EN_3_1 ABUT < 90 SINGULAR REGION)
}
// M2.EN.2 is checked by M2.EN.2__M2.EN.3__M2.EN.3.1
// M2.EN.3 is checked by M2.EN.2__M2.EN.3__M2.EN.3.1
// M2.EN.3.1 is checked by M2.EN.2__M2.EN.3__M2.EN.3.1

M2.A.1 { @ Area (except M2 (M2.A.1) in SRAMDMY;0 (186;0) region) >= 0.027 
     AREA (M2 NOT INSIDE SRAM_REGION) < M2_A_1
}
M2.A.2 { @ Area [with all of edge length < 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (except M2 (M2.A.2) in SRAMDMY;0 (186;0) region) >= 0.06 
  A = AREA (M2 NOT INSIDE SRAM_REGION) < M2_A_2
  B = LENGTH A >= M2_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M2_A_2_W M2_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M2_A_3pre ((M2_A_3 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))*((M2_A_3 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))/3.141 // user value

M2.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M2 INNER < M2_A_3pre
  AREA ( X NOT M2 ) < M2_A_3
}

// M2.R.1 can not be checked


// M2.DN.0 is checked by M2.DN.1, M2.DN.1.1, M2.DN.4, and DM2.R.1
#IFDEF CHECK_LOW_DENSITY
M2.DN.1 { @ Minimum local density [window ^M2_DN_1_W um x ^M2_DN_1_W um, stepping ^M2_DN_1_S um] >= ^M2_DN_1
  M2_CHECK = M2x NOT M2_EXC_LOW
  CHIP_CHECK = CHIP NOT M2_EXC_LOW

  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK < M2_DN_1 WINDOW M2_DN_1_W STEP M2_DN_1_S INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2_EXC_LOW) >= M2_DN_1_E
  DENSITY F M2_CHECK CHIP_CHECK < M2_DN_1 WINDOW M2_DN_1_W STEP M2_DN_1_S INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.1.density
         [ !AREA(F)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M2.DN.1.1 { @ Maximum local density [window ^M2_DN_1_1_W um x ^M2_DN_1_1_W um, stepping ^M2_DN_1_1_S um] <= ^M2_DN_1_1
  M2_CHECK = M2x NOT M2_EXC_HIGH
  CHIP_CHECK = CHIP NOT M2_EXC_HIGH
  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK > M2_DN_1_1 WINDOW M2_DN_1_1_W STEP M2_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2_EXC_HIGH) >= M2_DN_1_1_E
  DENSITY F M2_CHECK CHIP_CHECK > M2_DN_1_1 WINDOW M2_DN_1_1_W STEP M2_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M2.DN.1.1.density
         [ !!AREA(F)*AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}

M2.DN.4 { @ The metal density difference between any two neighboring checking windows including DM2EXCL [window ^M2_DN_4_W um x ^M2_DN_4_W um, stepping ^M2_DN_4_W um]  <= ^M2_DN_4
  DENSITY M2x CHIP <=1 WINDOW M2_DN_4_W BACKUP GRADIENT > M2_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M2.DN.4.density
  	[ AREA(M2x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M2.DN.6 { @ Metal Desnsity >= ^M2_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M2_DN_6_W_A um x ^M2_DN_6_W_A um, stepping ^M2_DN_6_S_A um] >= ^M2_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M2_DN_6_W_BC um x ^M2_DN_6_W_BC um, stepping ^M2_DN_6_S_BC um < ^M2_DN_6] <= ^M2_DN_6_A_B um2, except merged low density windows width <= ^M2_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M2_DN_6_W_BC um x ^M2_DN_6_W_BC um, stepping ^M2_DN_6_S_BC um < ^M2_DN_6] <= ^M2_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_6_E_A um for condition-A and >= ^M2_DN_6_E_BC um for both condition-B/condition-C 
  M2_CHECK = M2x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_A STEP M2_DN_6_S_A INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M2_DN_6_E_A
  DENSITY F_A M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_A STEP M2_DN_6_S_A INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6_A.density
         [ !AREA(F_A)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_BC STEP M2_DN_6_S_BC INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M2_DN_6_E_BC
  A = DENSITY F_B M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_BC STEP M2_DN_6_S_BC INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6_BC.density
         [ !AREA(F_B)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M2_DN_6_A_B
  C = SIZE B BY M2_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M2_DN_6_A_C
}
#ENDIF



// Mx.DN.5
//===========
M2_CORE = M2x NOT SEALRING_EXCLUDE



M2.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M2_PIN NOT INTERACT M2i == 1
}


//VIA2 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M3Wide_2_0 = M3 WITH WIDTH > M3_S_2_W            // 0.17
M3Wide_2_1 = M3Wide_2_0 WITH WIDTH > M3_S_2_1_W  // 0.24
M3Wide_2_2 = M3Wide_2_1 WITH WIDTH > M3_S_2_2_W  // 0.31
M3Wide_2_3 = M3Wide_2_2 WITH WIDTH > M3_S_2_3_W  // 0.62
M3Wide_3_0 = M3Wide_2_3 WITH WIDTH > M3_S_3_W    // 1.65
#ELSE
M3Wide_2_4 = M3 WITH WIDTH > M3_S_2_4_W          // 0.17
M3Wide_2_0 = M3Wide_2_4 WITH WIDTH > M3_S_2_W    // 0.19
M3Wide_2_5 = M3Wide_2_0 WITH WIDTH > M3_S_2_5_W  // 0.24
M3Wide_2_1 = M3Wide_2_5 WITH WIDTH > M3_S_2_1_W  // 0.265
M3Wide_2_6 = M3Wide_2_1 WITH WIDTH > M3_S_2_6_W  // 0.31
M3Wide_2_2 = M3Wide_2_6 WITH WIDTH > M3_S_2_2_W  // 0.345
M3Wide_2_7 = M3Wide_2_2 WITH WIDTH > M3_S_2_7_W  // 0.62
M3Wide_2_3 = M3Wide_2_7 WITH WIDTH > M3_S_2_3_W  // 0.685
M3Wide_3_0 = M3Wide_2_3 WITH WIDTH > M3_S_3_W    // 1.65
#ENDIF

M2Wide_R2_VIA2 = M2Wide_2_0 WITH WIDTH > VIA2_R_2_W        // 0.21
M2Wide_R4_VIA2 = M2Wide_R2_VIA2 WITH WIDTH > VIA2_R_4_W    // 0.21
M2Wide_R3_VIA2 = M2Wide_R4_VIA2 WITH WIDTH > VIA2_R_3_W    // 0.55
M2Wide_R5_VIA2 = M2Wide_R3_VIA2 WITH WIDTH > VIA2_R_5_W    // 1.4
M2Wide_R6_VIA2 = M2Wide_R5_VIA2 WITH WIDTH > VIA2_R_6_W    // 2.1
M3Wide_R2_VIA2 = M3Wide_2_0 WITH WIDTH > VIA2_R_2_W      // 0.21
M3Wide_R4_VIA2 = M3Wide_R2_VIA2 WITH WIDTH > VIA2_R_4_W  // 0.21
M3Wide_R3_VIA2 = M3Wide_R4_VIA2 WITH WIDTH > VIA2_R_3_W  // 0.55
M3Wide_R5_VIA2 = M3Wide_R3_VIA2 WITH WIDTH > VIA2_R_5_W  // 1.4
M3Wide_R6_VIA2 = M3Wide_R5_VIA2 WITH WIDTH > VIA2_R_6_W  // 2.1

VIA2.W.1 { @ Width (maximum = minimum) (Except SEALRING_ALL (162;2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA2i NOT INSIDE (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
}
VIA2.S.1 { @ Space >= 0.07 
  EXT VIA2i < VIA2_S_1 ABUT < 90 SINGULAR REGION
}

VIA2.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA2_S_1_1
  J = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  EXT J VIA2i < VIA2_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

VIA2.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA2i > 2 SPACE < VIA2_S_2_D
  EXT X VIA2i < VIA2_S_2 ABUT < 90 SINGULAR REGION
}
VIA2.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA2i < VIA2_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA2.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA2i < VIA2_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA2.EN.0 is checked by VIA2.EN.1 and VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1

VIA2.EN.1 { @ Enclosure by Mx or M1 >= 0.0 
  VIA2 NOT M2
}

VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1 { @ Enclosure by M2 [at least two opposite sides] >= ^VIA2_EN_2, or [four sides] >= ^VIA2_EN_4 with [at least two opposite sides] >= ^VIA2_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA2 NOT SEALRING_EXCLUDE) M2 ABUT < 90 SINGULAR GOOD 0 VIA2_EN_2 OPPOSITE 0 VIA2_EN_2 OPPOSITE
  Y = ENC X M2 < VIA2_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M2 ABUT < 90 GOOD VIA2_EN_4 VIA2_EN_4_1 OPPOSITE VIA2_EN_4 VIA2_EN_4_1 OPPOSITE
  (Y OR (ENC Z M2 < VIA2_EN_4_1 ABUT < 90 SINGULAR REGION)) NOT SRAM_EXCLUDE

}
// VIA2.EN.2 is checked by VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1
// VIA2.EN.4 is checked by VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1
// VIA2.EN.4.1 is checked by VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1


// VIA2.EN.3.1 is not necessary to check

// VIA2.R.1 is checked by VIA2.W.1
// VIA2.R.2 is checked by VIA2.R.2__VIA2.R.3
// VIA2.R.3 is checked by VIA2.R.2__VIA2.R.3
VIA2.R.2__VIA2.R.3 { @ When M2 or M3 width > ^VIA2_R_2_W um, more than one VIA2 is required.
                    @ 2 vias spacing should be <= ^VIA2_R_2_S1 um or 4 vias spacing should be <= ^VIA2_R_2_S2 um
                    @ When M2 or M3 width > ^VIA2_R_3_W um, more than three VIA2 is required.
                    @ 4 vias spacing should be <= ^VIA2_R_3_S1 um or 9 vias spacing should be <= ^VIA2_R_3_S2 um
                    @ not check SRAM region					
   M3OvpM2_W_ = (M2Wide_R2_VIA2 AND M3) OR (M3Wide_R2_VIA2 AND M2)
   M3OvpM2_B  = (M2Wide_R3_VIA2 AND M3) OR (M3Wide_R3_VIA2 AND M2)
   M3OvpM2_W  = M3OvpM2_W_ NOT M3OvpM2_B 
   Checked_VIA2_W_ = VIA2_EXD NOT OUTSIDE M3OvpM2_W
   Checked_VIA2_B  = VIA2_EXD NOT OUTSIDE M3OvpM2_B
   Checked_VIA2_W  = Checked_VIA2_W_ NOT Checked_VIA2_B
   M2_effect = M2i INTERACT M3OvpM2_W_
   M3_effect = M3i INTERACT M3OvpM2_W_
   effect_M3OvpM2_ = M2_effect AND M3_effect
   effect_M3OvpM2 = effect_M3OvpM2_ INTERACT M3OvpM2_W_
   effect_VIA = VIA2_EXD INTERACT effect_M3OvpM2

   V2Merged_A = SIZE effect_VIA BY VIA2_R_2_S1/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_B = SIZE V2Merged_A BY (VIA2_R_2_S2 - VIA2_R_2_S1)/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_C = SIZE V2Merged_B BY (VIA2_R_3_S2 - VIA2_R_2_S2)/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_A2R = V2Merged_A INTERACT effect_VIA < 2
   V2Merged_A2 = V2Merged_A OUTSIDE V2Merged_A2R
   V2Merged_A4R = V2Merged_A2 INTERACT effect_VIA < 4
   V2Merged_A4 = V2Merged_A2 OUTSIDE V2Merged_A4R
   V2Merged_B4R = V2Merged_B INTERACT effect_VIA < 4
   V2Merged_B4 = V2Merged_B OUTSIDE V2Merged_B4R
   V2Merged_C9R = V2Merged_C INTERACT effect_VIA < 9
   V2Merged_C9 = V2Merged_C OUTSIDE V2Merged_C9R

   GMergeW = V2Merged_A2 OR V2Merged_B4
   GMergeB = V2Merged_A4 OR V2Merged_C9
   GVIA_W = Checked_VIA2_W INTERACT GMergeW
   GVIA_B = Checked_VIA2_B INTERACT GMergeB
   GOOD_AREA_W = M3OvpM2_W INTERACT GVIA_W
   GOOD_AREA_B = M3OvpM2_B INTERACT GVIA_B
   Checked_VIA2_W OUTSIDE GOOD_AREA_W
   Checked_VIA2_B OUTSIDE GOOD_AREA_B
}
// VIA2.R.2.S is checked by VIA2.R.2__VIA2.R.3
// VIA2.R.3.S is checked by VIA2.R.2__VIA2.R.3

// VIA2.R.4 is checked by VIA2.R.4:M2 and VIA2.R.4:M3
VIA2.R.4:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W).)   
  Branch1 = ((SIZE M2Wide_R4_VIA2 BY VIA2_R_4_D + GRID) NOT M2Wide_R4_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R4_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Wide_R4_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.4:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W)).   
  Branch1 = ((SIZE M3Wide_R4_VIA2 BY VIA2_R_4_D + GRID) NOT M3Wide_R4_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R4_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Wide_R4_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA2.R.4.S is checked by VIA2.R.4:M2 and VIA2.R.4:M3

// VIA2.R.5 is checked by VIA2.R.5:M2 and VIA2.R.5:M3
VIA2.R.5:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W)).
  Branch1 = ((SIZE M2Wide_R5_VIA2 BY VIA2_R_5_D + GRID) NOT M2Wide_R5_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R5_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Wide_R5_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.5:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W)).
  Branch1 = ((SIZE M3Wide_R5_VIA2 BY VIA2_R_5_D + GRID) NOT M3Wide_R5_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R5_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Wide_R5_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA2.R.5.S is checked by VIA2.R.5:M2 and VIA2.R.5:M3

// VIA2.R.6 is checked by VIA2.R.6:M2 and VIA2.R.6:M3
M2Big_R6_VIA2 = ENCLOSE RECTANGLE M2Wide_R6_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6:M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_R6_VIA2 BY VIA2_R_6_D + GRID) NOT M2Big_R6_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_R6_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Big_R6_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M3Big_R6_VIA2 = ENCLOSE RECTANGLE M3Wide_R6_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_R6_VIA2 BY VIA2_R_6_D + GRID) NOT M3Big_R6_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_R6_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Big_R6_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA2.R.6.S is checked by VIA2.R.6:M2 and VIA2.R.6:M3

// VIA2.R.7 is checked by VIA2.EN.1
// VIA2.R.9 can't be checked

VIA2.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA2_R_11_L1 um and both two metal hole area <= ^VIA2_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA2_R_11_L2 um and the width of metal bar is <= ^VIA2_R_11_W um.
  W = M3i WITH WIDTH <= VIA2_R_11_W   
  H_HOLE = (HOLES M3i INNER <= VIA2_R_11_A) INTERACT W
  A0 = M3i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA2_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA2_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA2_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA2_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA2_R_11_L2+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA2_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA2 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M2i INTERACT CHECK_VIA)) INTERACT VIA2i == 1)
}
// VIA2.R.11.S is checked by VIA2.R.11

VIA2.R.12 { @ VIA2 connected to DM2, DM2_O, DM3, DM3_O is not allowed
  VIA2 INTERACT DUM2
  VIA2 INTERACT DUM3
  VIA2 INTERACT DM2_O
  VIA2 INTERACT DM3_O
}  

//M3 CHECKS
//=========


M3_EDGE_45 = M3 ANGLE == 45

M3.W.1 { @ Width >= 0.07 
  INT M3 < M3_W_1 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section XXX)) >= 0.17 
  INT M3_EDGE_45 < M3_W_2 ABUT < 90 REGION
}
M3.W.3 { @ Maximum width <= ^M3_W_3 um, exclude SEALRING_ALL 
  M3_MAX_WIDTH WITH WIDTH > M3_W_3
}
// M3.W.3.S is checked by M3.W.3
M3.S.1 { @ Space >= 0.07 
  EXT M3 < M3_S_1 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Min. Metal space (for W> ^M3_S_2_W um & parallel length > ^M3_S_2_L um) >= ^M3_S_2 um
  X = EXT M3Wide_2_0 M3 < M3_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_L+GRID
}
// M3.S.2.S is checked by M3.S.2
M3.S.2.1 { @ Min. Metal space (for W> ^M3_S_2_1_W um & parallel length > ^M3_S_2_1_L um) >= ^M3_S_2_1 um
  X = EXT M3Wide_2_1 M3 < M3_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_1_L+GRID
}
// M3.S.2.1.S is checked by M3.S.2.1
M3.S.2.2 { @ Min. Metal space (for W> ^M3_S_2_2_W um & parallel length > ^M3_S_2_2_L um) >= ^M3_S_2_2 um
  X = EXT M3Wide_2_2 M3 < M3_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_2_L+GRID
}
// M3.S.2.2.S is checked by M3.S.2.2
M3.S.2.3 { @ Min. Metal space (for W> ^M3_S_2_3_W um & parallel length > ^M3_S_2_3_L um) >= ^M3_S_2_3 um
  X = EXT M3Wide_2_3 M3 < M3_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_3_L+GRID
}
// M3.S.2.3.S is checked by M3.S.2.3
#IFDEF WIDE_ADJUST
M3.S.2.4 { @ Min. Metal space (for W> ^M3_S_2_4_W um & parallel length > ^M3_S_2_4_L um) >= ^M3_S_2_4 um
  X = EXT M3Wide_2_4 M3 < M3_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_4_L+GRID
}
// M3.S.2.4.S is checked by M3.S.2.4
M3.S.2.5 { @ Min. Metal space (for W> ^M3_S_2_5_W um & parallel length > ^M3_S_2_5_L um) >= ^M3_S_2_5 um
  X = EXT M3Wide_2_5 M3 < M3_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_5_L+GRID
}
// M3.S.2.5.S is checked by M3.S.2.5
M3.S.2.6 { @ Min. Metal space (for W> ^M3_S_2_6_W um & parallel length > ^M3_S_2_6_L um) >= ^M3_S_2_6 um
  X = EXT M3Wide_2_6 M3 < M3_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_6_L+GRID
}
// M3.S.2.6.S is checked by M3.S.2.6
M3.S.2.7 { @ Min. Metal space (for W> ^M3_S_2_7_W um & parallel length > ^M3_S_2_7_L um) >= ^M3_S_2_7 um
  X = EXT M3Wide_2_7 M3 < M3_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_7_L+GRID
}
// M3.S.2.7.S is checked by M3.S.2.7
#ENDIF
M3.S.3 { @ Min. Metal space (for W> ^M3_S_3_W um & parallel length > ^M3_S_3_L um) >= ^M3_S_3 um
  X = EXT M3Wide_3_0 M3 < M3_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  (ENCLOSE RECTANGLE Y 0.001 M3_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M3.S.3.S is checked by M3.S.3
M3.S.5 { @ Space at Mx line-end (W < 0.1 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge < Q distance from the corner of the 2 edges], then one of the spaces (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um (R)) (M2.S.5 except SRAMDMY;0 (186;0) region) >= 0.1 
  A = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M3_S_5_W
  B = EXT [A] M3 < M3_S_5 ABUT < 90 OPPOSITE EXTENDED M3_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M3] < M3_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M3_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M3_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M3 < M3_S_5 ABUT < 90 OPPOSITE REGION

}

M3.S.5.1 { @ Space at Mx line-end (W<Q=^M3_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M3_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M3_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M3_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M3_S_5_1 um.
  A = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M3_S_5_1_W
  V2_EN = ENC [VIA2i] A < M3_S_5_1_E ABUT < 90 OPPOSITE
  M3_EN = ENC V2_EN [A] < M3_S_5_1_E ABUT < 90 OPPOSITE
  M3_SA = EXT A [M3] < M3_S_5_1 ABUT < 90 OPPOSITE EXTENDED M3_S_5_1_T
  M3_SB = EXT [A] M3_SA < M3_S_5_1 ABUT < 90 OPPOSITE EXTENDED M3_S_5_1_T
  M3_END = (A TOUCH INSIDE EDGE M3_EN) TOUCH INSIDE EDGE M3_SB
  EN_B = ENC V2_EN [M3_END] < M3_S_5_1_E2 OPPOSITE
  EN_C = ENC V2_EN [M3_END] < M3_S_5_1_E3 OPPOSITE
  EN_D = ENC V2_EN [M3_END] < M3_S_5_1_E4 OPPOSITE
  S1_B = EXT [M3_END] M3_SA < M3_S_5_1_S2 OPPOSITE EXTENDED M3_S_5_1_T
  S1_C = EXT [M3_END] M3_SA < M3_S_5_1_S3 OPPOSITE EXTENDED M3_S_5_1_T
  S1_D = EXT [M3_END] M3_SA < M3_S_5_1_S4 OPPOSITE EXTENDED M3_S_5_1_T
  PASS_B = (M3_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M3_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M3_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M3_CHECK = ((M3_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M3_CHECK [M3] < M3_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M3_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M3_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE M3_SB
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M3 < M3_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA2i (O TOUCH INSIDE EDGE P) < M3_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA2i INTERACT Q
  VIA_GOOD = VIA2i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M3 AND M2) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M3_CHECK < M3_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M3.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY M3_S_6
  X AND M3
}


M3.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M3_S_1_1
  I = STAMP M3_5V_ALL BY M3i
  EXT I M3i < M3_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M3.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M3_S_8_2
  I = STAMP M3_5V_ALL BY M3i
  J = STAMP (VIA2i AND M3_5V_ALL) BY M3i
  EXT I VIA2i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  EXT I VIA3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}



M3.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] >= 0.1 
  I = STAMP M3_HV_ALL BY M3i
  J = STAMP (VIA2i AND M3_HV_ALL) BY M3i
  EXT I VIA2i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_HV_ALL) BY M3i
  EXT I VIA3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M3.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] >= 0.08 
  I = STAMP M3_MV_ALL BY M3i
  J = STAMP (VIA2i AND M3_MV_ALL) BY M3i
  EXT I VIA2i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_MV_ALL) BY M3i
  EXT I VIA3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M3.S.9 { @ This rule is to check the Metal (A) space with the neighboring VIAx [either VIAx or Mx connects to > 3.3V and <= 5V net]. The DRC methodology to find Metal (A): Find an edge (B) of the metal line-end [edge length <= 0.12 um] Run length (C) from edge (B) inside metal >= 0.13 um Jog length (D) <= 0.01 um within 0.13 um run length Extend 0.06 um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied >= 0.15 
  LINE_END_pre   = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M3_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M3_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M3 < M3_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M3_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M3_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M3 < M3_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M3_S_9_A INSIDE BY GRID
  B = STAMP A BY M3i
  I = STAMP (A INTERACT M3_5V_ALL) BY M3i
  J = STAMP (VIA2i AND M3_5V_ALL) BY M3i
  K = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  X1 = EXT I VIA2i < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA3i  < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}



// M3.EN.0 is checked by M3.EN.1 and M3.EN.2__M3.EN.3__M3.EN.3.1
M3.EN.1 { @ Enclosure of VIAx-1 >= 0.0 
  VIA2 NOT M3
}
M3.EN.2__M3.EN.3__M3.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M3_EN_2, or [four sides] >= ^M3_EN_3 with [at least two opposite sides] >= ^M3_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA2 NOT SEALRING_ALL) M3 ABUT < 90 SINGULAR GOOD 0 M3_EN_2 OPPOSITE 0 M3_EN_2 OPPOSITE
  Y = ENC X M3 < M3_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M3 ABUT < 90 GOOD M3_EN_3 M3_EN_3_1 OPPOSITE M3_EN_3 M3_EN_3_1 OPPOSITE
  (Y OR (ENC Z M3 < M3_EN_3_1 ABUT < 90 SINGULAR REGION)) NOT SRAM_EXCLUDE
}
// M3.EN.2 is checked by M3.EN.2__M3.EN.3__M3.EN.3.1
// M3.EN.3 is checked by M3.EN.2__M3.EN.3__M3.EN.3.1
// M3.EN.3.1 is checked by M3.EN.2__M3.EN.3__M3.EN.3.1

M3.A.1 { @ Area (except M2 (M2.A.1) in SRAMDMY;0 (186;0) region) >= 0.027 
     AREA M3 < M3_A_1
}
M3.A.2 { @ Area [with all of edge length < 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (except M2 (M2.A.2) in SRAMDMY;0 (186;0) region) >= 0.06 
  A = AREA M3 < M3_A_2
  B = LENGTH A >= M3_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M3_A_2_W M3_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M3_A_3pre ((M3_A_3 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))*((M3_A_3 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))/3.141 // user value

M3.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M3 INNER < M3_A_3pre
  AREA ( X NOT M3 ) < M3_A_3
}

// M3.R.1 can not be checked


// M3.DN.0 is checked by M3.DN.1, M3.DN.1.1, M3.DN.4, and DM3.R.1
#IFDEF CHECK_LOW_DENSITY
M3.DN.1 { @ Minimum local density [window ^M3_DN_1_W um x ^M3_DN_1_W um, stepping ^M3_DN_1_S um] >= ^M3_DN_1
  M3_CHECK = M3x NOT M3_EXC_LOW
  CHIP_CHECK = CHIP NOT M3_EXC_LOW

  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK < M3_DN_1 WINDOW M3_DN_1_W STEP M3_DN_1_S INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3_EXC_LOW) >= M3_DN_1_E
  DENSITY F M3_CHECK CHIP_CHECK < M3_DN_1 WINDOW M3_DN_1_W STEP M3_DN_1_S INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.1.density
         [ !AREA(F)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M3.DN.1.1 { @ Maximum local density [window ^M3_DN_1_1_W um x ^M3_DN_1_1_W um, stepping ^M3_DN_1_1_S um] <= ^M3_DN_1_1
  M3_CHECK = M3x NOT M3_EXC_HIGH
  CHIP_CHECK = CHIP NOT M3_EXC_HIGH
  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK > M3_DN_1_1 WINDOW M3_DN_1_1_W STEP M3_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3_EXC_HIGH) >= M3_DN_1_1_E
  DENSITY F M3_CHECK CHIP_CHECK > M3_DN_1_1 WINDOW M3_DN_1_1_W STEP M3_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M3.DN.1.1.density
         [ !!AREA(F)*AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}

M3.DN.4 { @ The metal density difference between any two neighboring checking windows including DM3EXCL [window ^M3_DN_4_W um x ^M3_DN_4_W um, stepping ^M3_DN_4_W um]  <= ^M3_DN_4
  DENSITY M3x CHIP <=1 WINDOW M3_DN_4_W BACKUP GRADIENT > M3_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M3.DN.4.density
  	[ AREA(M3x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M3.DN.6 { @ Metal Desnsity >= ^M3_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M3_DN_6_W_A um x ^M3_DN_6_W_A um, stepping ^M3_DN_6_S_A um] >= ^M3_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M3_DN_6_W_BC um x ^M3_DN_6_W_BC um, stepping ^M3_DN_6_S_BC um < ^M3_DN_6] <= ^M3_DN_6_A_B um2, except merged low density windows width <= ^M3_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M3_DN_6_W_BC um x ^M3_DN_6_W_BC um, stepping ^M3_DN_6_S_BC um < ^M3_DN_6] <= ^M3_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_6_E_A um for condition-A and >= ^M3_DN_6_E_BC um for both condition-B/condition-C 
  M3_CHECK = M3x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_A STEP M3_DN_6_S_A INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M3_DN_6_E_A
  DENSITY F_A M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_A STEP M3_DN_6_S_A INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6_A.density
         [ !AREA(F_A)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_BC STEP M3_DN_6_S_BC INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M3_DN_6_E_BC
  A = DENSITY F_B M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_BC STEP M3_DN_6_S_BC INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6_BC.density
         [ !AREA(F_B)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M3_DN_6_A_B
  C = SIZE B BY M3_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M3_DN_6_A_C
}
#ENDIF



// Mx.DN.5
//===========
M3_CORE = M3x NOT SEALRING_EXCLUDE

Mx.DN.5:M1_M2_M3 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1, and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check doesn't include chip corner stress relief pattern, SEALRING_ALL (162;2) and top 2 metals at the CUP area   
    DENSITY  M1_CORE M2_CORE M3_CORE >0 WINDOW M1_DN_5_W STEP M1_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M1_CORE)/AREA()- M1_DN_5)*!~(AREA(M2_CORE)/AREA()- M1_DN_5)*!~(AREA(M3_CORE)/AREA()- M1_DN_5) ]
 	  RDB Mx.DN.5:M1_M2_M3.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M1_M2_M3 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M1,M2,M3) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M1, M2, or M3 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M1_CHECK = M1x NOT NEW_DEN_EXC
   M2_CHECK = M2x NOT NEW_DEN_EXC
   M3_CHECK = M3x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W STEP M1_DN_7_S BACKUP INSIDE OF LAYER CHIP_M3
   [ !~(M1_DN_7-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M1_DN_7_E
   DENSITY F M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W STEP M1_DN_7_S BACKUP INSIDE OF LAYER CHIP_M3
   [ !!AREA(F)*!~(M1_DN_7-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M1_M2_M3.density
}
#ENDIF


M3.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M3_PIN NOT INTERACT M3i == 1
}


//VIA3 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M4Wide_2_0 = M4 WITH WIDTH > M4_S_2_W            // 0.17
M4Wide_2_1 = M4Wide_2_0 WITH WIDTH > M4_S_2_1_W  // 0.24
M4Wide_2_2 = M4Wide_2_1 WITH WIDTH > M4_S_2_2_W  // 0.31
M4Wide_2_3 = M4Wide_2_2 WITH WIDTH > M4_S_2_3_W  // 0.62
M4Wide_3_0 = M4Wide_2_3 WITH WIDTH > M4_S_3_W    // 1.65
#ELSE
M4Wide_2_4 = M4 WITH WIDTH > M4_S_2_4_W          // 0.17
M4Wide_2_0 = M4Wide_2_4 WITH WIDTH > M4_S_2_W    // 0.19
M4Wide_2_5 = M4Wide_2_0 WITH WIDTH > M4_S_2_5_W  // 0.24
M4Wide_2_1 = M4Wide_2_5 WITH WIDTH > M4_S_2_1_W  // 0.265
M4Wide_2_6 = M4Wide_2_1 WITH WIDTH > M4_S_2_6_W  // 0.31
M4Wide_2_2 = M4Wide_2_6 WITH WIDTH > M4_S_2_2_W  // 0.345
M4Wide_2_7 = M4Wide_2_2 WITH WIDTH > M4_S_2_7_W  // 0.62
M4Wide_2_3 = M4Wide_2_7 WITH WIDTH > M4_S_2_3_W  // 0.685
M4Wide_3_0 = M4Wide_2_3 WITH WIDTH > M4_S_3_W    // 1.65
#ENDIF

M3Wide_R2_VIA3 = M3Wide_2_0 WITH WIDTH > VIA3_R_2_W        // 0.21
M3Wide_R4_VIA3 = M3Wide_R2_VIA3 WITH WIDTH > VIA3_R_4_W    // 0.21
M3Wide_R3_VIA3 = M3Wide_R4_VIA3 WITH WIDTH > VIA3_R_3_W    // 0.55
M3Wide_R5_VIA3 = M3Wide_R3_VIA3 WITH WIDTH > VIA3_R_5_W    // 1.4
M3Wide_R6_VIA3 = M3Wide_R5_VIA3 WITH WIDTH > VIA3_R_6_W    // 2.1
M4Wide_R2_VIA3 = M4Wide_2_0 WITH WIDTH > VIA3_R_2_W      // 0.21
M4Wide_R4_VIA3 = M4Wide_R2_VIA3 WITH WIDTH > VIA3_R_4_W  // 0.21
M4Wide_R3_VIA3 = M4Wide_R4_VIA3 WITH WIDTH > VIA3_R_3_W  // 0.55
M4Wide_R5_VIA3 = M4Wide_R3_VIA3 WITH WIDTH > VIA3_R_5_W  // 1.4
M4Wide_R6_VIA3 = M4Wide_R5_VIA3 WITH WIDTH > VIA3_R_6_W  // 2.1

VIA3.W.1 { @ Width (maximum = minimum) (Except SEALRING_ALL (162;2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA3i NOT INSIDE (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
}
VIA3.S.1 { @ Space >= 0.07 
  EXT VIA3i < VIA3_S_1 ABUT < 90 SINGULAR REGION
}

VIA3.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA3_S_1_1
  J = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  EXT J VIA3i < VIA3_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

VIA3.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA3i > 2 SPACE < VIA3_S_2_D
  EXT X VIA3i < VIA3_S_2 ABUT < 90 SINGULAR REGION
}
VIA3.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA3i < VIA3_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA3.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA3i < VIA3_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA3.EN.0 is checked by VIA3.EN.1 and VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1

VIA3.EN.1 { @ Enclosure by Mx or M1 >= 0.0 
  VIA3 NOT M3
}

VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1 { @ Enclosure by M3 [at least two opposite sides] >= ^VIA3_EN_2, or [four sides] >= ^VIA3_EN_4 with [at least two opposite sides] >= ^VIA3_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA3 NOT SEALRING_EXCLUDE) M3 ABUT < 90 SINGULAR GOOD 0 VIA3_EN_2 OPPOSITE 0 VIA3_EN_2 OPPOSITE
  Y = ENC X M3 < VIA3_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M3 ABUT < 90 GOOD VIA3_EN_4 VIA3_EN_4_1 OPPOSITE VIA3_EN_4 VIA3_EN_4_1 OPPOSITE
  Y OR (ENC Z M3 < VIA3_EN_4_1 ABUT < 90 SINGULAR REGION)

}
// VIA3.EN.2 is checked by VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1
// VIA3.EN.4 is checked by VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1
// VIA3.EN.4.1 is checked by VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1


// VIA3.EN.3.1 is not necessary to check

// VIA3.R.1 is checked by VIA3.W.1
// VIA3.R.2 is checked by VIA3.R.2__VIA3.R.3
// VIA3.R.3 is checked by VIA3.R.2__VIA3.R.3
VIA3.R.2__VIA3.R.3 { @ When M3 or M4 width > ^VIA3_R_2_W um, more than one VIA3 is required.
                    @ 2 vias spacing should be <= ^VIA3_R_2_S1 um or 4 vias spacing should be <= ^VIA3_R_2_S2 um
                    @ When M3 or M4 width > ^VIA3_R_3_W um, more than three VIA3 is required.
                    @ 4 vias spacing should be <= ^VIA3_R_3_S1 um or 9 vias spacing should be <= ^VIA3_R_3_S2 um
                    @ not check SRAM region					
   M4OvpM3_W_ = (M3Wide_R2_VIA3 AND M4) OR (M4Wide_R2_VIA3 AND M3)
   M4OvpM3_B  = (M3Wide_R3_VIA3 AND M4) OR (M4Wide_R3_VIA3 AND M3)
   M4OvpM3_W  = M4OvpM3_W_ NOT M4OvpM3_B 
   Checked_VIA3_W_ = VIA3_EXD NOT OUTSIDE M4OvpM3_W
   Checked_VIA3_B  = VIA3_EXD NOT OUTSIDE M4OvpM3_B
   Checked_VIA3_W  = Checked_VIA3_W_ NOT Checked_VIA3_B
   M3_effect = M3i INTERACT M4OvpM3_W_
   M4_effect = M4i INTERACT M4OvpM3_W_
   effect_M4OvpM3_ = M3_effect AND M4_effect
   effect_M4OvpM3 = effect_M4OvpM3_ INTERACT M4OvpM3_W_
   effect_VIA = VIA3_EXD INTERACT effect_M4OvpM3

   V3Merged_A = SIZE effect_VIA BY VIA3_R_2_S1/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_B = SIZE V3Merged_A BY (VIA3_R_2_S2 - VIA3_R_2_S1)/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_C = SIZE V3Merged_B BY (VIA3_R_3_S2 - VIA3_R_2_S2)/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_A2R = V3Merged_A INTERACT effect_VIA < 2
   V3Merged_A2 = V3Merged_A OUTSIDE V3Merged_A2R
   V3Merged_A4R = V3Merged_A2 INTERACT effect_VIA < 4
   V3Merged_A4 = V3Merged_A2 OUTSIDE V3Merged_A4R
   V3Merged_B4R = V3Merged_B INTERACT effect_VIA < 4
   V3Merged_B4 = V3Merged_B OUTSIDE V3Merged_B4R
   V3Merged_C9R = V3Merged_C INTERACT effect_VIA < 9
   V3Merged_C9 = V3Merged_C OUTSIDE V3Merged_C9R

   GMergeW = V3Merged_A2 OR V3Merged_B4
   GMergeB = V3Merged_A4 OR V3Merged_C9
   GVIA_W = Checked_VIA3_W INTERACT GMergeW
   GVIA_B = Checked_VIA3_B INTERACT GMergeB
   GOOD_AREA_W = M4OvpM3_W INTERACT GVIA_W
   GOOD_AREA_B = M4OvpM3_B INTERACT GVIA_B
   Checked_VIA3_W OUTSIDE GOOD_AREA_W
   Checked_VIA3_B OUTSIDE GOOD_AREA_B
}
// VIA3.R.2.S is checked by VIA3.R.2__VIA3.R.3
// VIA3.R.3.S is checked by VIA3.R.2__VIA3.R.3

// VIA3.R.4 is checked by VIA3.R.4:M3 and VIA3.R.4:M4
VIA3.R.4:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W).)   
  Branch1 = ((SIZE M3Wide_R4_VIA3 BY VIA3_R_4_D + GRID) NOT M3Wide_R4_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R4_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Wide_R4_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.4:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W)).   
  Branch1 = ((SIZE M4Wide_R4_VIA3 BY VIA3_R_4_D + GRID) NOT M4Wide_R4_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R4_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Wide_R4_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA3.R.4.S is checked by VIA3.R.4:M3 and VIA3.R.4:M4

// VIA3.R.5 is checked by VIA3.R.5:M3 and VIA3.R.5:M4
VIA3.R.5:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W)).
  Branch1 = ((SIZE M3Wide_R5_VIA3 BY VIA3_R_5_D + GRID) NOT M3Wide_R5_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R5_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Wide_R5_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.5:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W)).
  Branch1 = ((SIZE M4Wide_R5_VIA3 BY VIA3_R_5_D + GRID) NOT M4Wide_R5_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R5_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Wide_R5_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA3.R.5.S is checked by VIA3.R.5:M3 and VIA3.R.5:M4

// VIA3.R.6 is checked by VIA3.R.6:M3 and VIA3.R.6:M4
M3Big_R6_VIA3 = ENCLOSE RECTANGLE M3Wide_R6_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6:M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_R6_VIA3 BY VIA3_R_6_D + GRID) NOT M3Big_R6_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_R6_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Big_R6_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M4Big_R6_VIA3 = ENCLOSE RECTANGLE M4Wide_R6_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M4Big_R6_VIA3 BY VIA3_R_6_D + GRID) NOT M4Big_R6_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_R6_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Big_R6_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA3.R.6.S is checked by VIA3.R.6:M3 and VIA3.R.6:M4

// VIA3.R.7 is checked by VIA3.EN.1
// VIA3.R.9 can't be checked

VIA3.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA3_R_11_L1 um and both two metal hole area <= ^VIA3_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA3_R_11_L2 um and the width of metal bar is <= ^VIA3_R_11_W um.
  W = M4i WITH WIDTH <= VIA3_R_11_W   
  H_HOLE = (HOLES M4i INNER <= VIA3_R_11_A) INTERACT W
  A0 = M4i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA3_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA3_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA3_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA3_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA3_R_11_L2+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA3
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA3_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA3 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M3i INTERACT CHECK_VIA)) INTERACT VIA3i == 1)
}
// VIA3.R.11.S is checked by VIA3.R.11

VIA3.R.12 { @ VIA3 connected to DM3, DM3_O, DM4, DM4_O is not allowed
  VIA3 INTERACT DUM3
  VIA3 INTERACT DUM4
  VIA3 INTERACT DM3_O
  VIA3 INTERACT DM4_O
}  

//M4 CHECKS
//=========


M4_EDGE_45 = M4 ANGLE == 45

M4.W.1 { @ Width >= 0.07 
  INT M4 < M4_W_1 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section XXX)) >= 0.17 
  INT M4_EDGE_45 < M4_W_2 ABUT < 90 REGION
}
M4.W.3 { @ Maximum width <= ^M4_W_3 um, exclude SEALRING_ALL 
  M4_MAX_WIDTH WITH WIDTH > M4_W_3
}
// M4.W.3.S is checked by M4.W.3
M4.S.1 { @ Space >= 0.07 
  EXT M4 < M4_S_1 ABUT < 90 SINGULAR REGION
}
M4.S.2 { @ Min. Metal space (for W> ^M4_S_2_W um & parallel length > ^M4_S_2_L um) >= ^M4_S_2 um
  X = EXT M4Wide_2_0 M4 < M4_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_L+GRID
}
// M4.S.2.S is checked by M4.S.2
M4.S.2.1 { @ Min. Metal space (for W> ^M4_S_2_1_W um & parallel length > ^M4_S_2_1_L um) >= ^M4_S_2_1 um
  X = EXT M4Wide_2_1 M4 < M4_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_1_L+GRID
}
// M4.S.2.1.S is checked by M4.S.2.1
M4.S.2.2 { @ Min. Metal space (for W> ^M4_S_2_2_W um & parallel length > ^M4_S_2_2_L um) >= ^M4_S_2_2 um
  X = EXT M4Wide_2_2 M4 < M4_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_2_L+GRID
}
// M4.S.2.2.S is checked by M4.S.2.2
M4.S.2.3 { @ Min. Metal space (for W> ^M4_S_2_3_W um & parallel length > ^M4_S_2_3_L um) >= ^M4_S_2_3 um
  X = EXT M4Wide_2_3 M4 < M4_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_3_L+GRID
}
// M4.S.2.3.S is checked by M4.S.2.3
#IFDEF WIDE_ADJUST
M4.S.2.4 { @ Min. Metal space (for W> ^M4_S_2_4_W um & parallel length > ^M4_S_2_4_L um) >= ^M4_S_2_4 um
  X = EXT M4Wide_2_4 M4 < M4_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_4_L+GRID
}
// M4.S.2.4.S is checked by M4.S.2.4
M4.S.2.5 { @ Min. Metal space (for W> ^M4_S_2_5_W um & parallel length > ^M4_S_2_5_L um) >= ^M4_S_2_5 um
  X = EXT M4Wide_2_5 M4 < M4_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_5_L+GRID
}
// M4.S.2.5.S is checked by M4.S.2.5
M4.S.2.6 { @ Min. Metal space (for W> ^M4_S_2_6_W um & parallel length > ^M4_S_2_6_L um) >= ^M4_S_2_6 um
  X = EXT M4Wide_2_6 M4 < M4_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_6_L+GRID
}
// M4.S.2.6.S is checked by M4.S.2.6
M4.S.2.7 { @ Min. Metal space (for W> ^M4_S_2_7_W um & parallel length > ^M4_S_2_7_L um) >= ^M4_S_2_7 um
  X = EXT M4Wide_2_7 M4 < M4_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_7_L+GRID
}
// M4.S.2.7.S is checked by M4.S.2.7
#ENDIF
M4.S.3 { @ Min. Metal space (for W> ^M4_S_3_W um & parallel length > ^M4_S_3_L um) >= ^M4_S_3 um
  X = EXT M4Wide_3_0 M4 < M4_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  (ENCLOSE RECTANGLE Y 0.001 M4_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M4.S.3.S is checked by M4.S.3
M4.S.5 { @ Space at Mx line-end (W < 0.1 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge < Q distance from the corner of the 2 edges], then one of the spaces (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um (R)) (M2.S.5 except SRAMDMY;0 (186;0) region) >= 0.1 
  A = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M4_S_5_W
  B = EXT [A] M4 < M4_S_5 ABUT < 90 OPPOSITE EXTENDED M4_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M4] < M4_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M4_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M4_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M4 < M4_S_5 ABUT < 90 OPPOSITE REGION

}

M4.S.5.1 { @ Space at Mx line-end (W<Q=^M4_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M4_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M4_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M4_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M4_S_5_1 um.
  A = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M4_S_5_1_W
  V3_EN = ENC [VIA3i] A < M4_S_5_1_E ABUT < 90 OPPOSITE
  M4_EN = ENC V3_EN [A] < M4_S_5_1_E ABUT < 90 OPPOSITE
  M4_SA = EXT A [M4] < M4_S_5_1 ABUT < 90 OPPOSITE EXTENDED M4_S_5_1_T
  M4_SB = EXT [A] M4_SA < M4_S_5_1 ABUT < 90 OPPOSITE EXTENDED M4_S_5_1_T
  M4_END = (A TOUCH INSIDE EDGE M4_EN) TOUCH INSIDE EDGE M4_SB
  EN_B = ENC V3_EN [M4_END] < M4_S_5_1_E2 OPPOSITE
  EN_C = ENC V3_EN [M4_END] < M4_S_5_1_E3 OPPOSITE
  EN_D = ENC V3_EN [M4_END] < M4_S_5_1_E4 OPPOSITE
  S1_B = EXT [M4_END] M4_SA < M4_S_5_1_S2 OPPOSITE EXTENDED M4_S_5_1_T
  S1_C = EXT [M4_END] M4_SA < M4_S_5_1_S3 OPPOSITE EXTENDED M4_S_5_1_T
  S1_D = EXT [M4_END] M4_SA < M4_S_5_1_S4 OPPOSITE EXTENDED M4_S_5_1_T
  PASS_B = (M4_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M4_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M4_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M4_CHECK = ((M4_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M4_CHECK [M4] < M4_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M4_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M4_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE M4_SB
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M4 < M4_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA3i (O TOUCH INSIDE EDGE P) < M4_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA3i INTERACT Q
  VIA_GOOD = VIA3i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M4 AND M3) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M4_CHECK < M4_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M4.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY M4_S_6
  X AND M4
}


M4.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M4_S_1_1
  I = STAMP M4_5V_ALL BY M4i
  EXT I M4i < M4_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M4.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M4_S_8_2
  I = STAMP M4_5V_ALL BY M4i
  J = STAMP (VIA3i AND M4_5V_ALL) BY M4i
  EXT I VIA3i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  EXT I VIA4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}



M4.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] >= 0.1 
  I = STAMP M4_HV_ALL BY M4i
  J = STAMP (VIA3i AND M4_HV_ALL) BY M4i
  EXT I VIA3i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_HV_ALL) BY M4i
  EXT I VIA4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M4.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] >= 0.08 
  I = STAMP M4_MV_ALL BY M4i
  J = STAMP (VIA3i AND M4_MV_ALL) BY M4i
  EXT I VIA3i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_MV_ALL) BY M4i
  EXT I VIA4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M4.S.9 { @ This rule is to check the Metal (A) space with the neighboring VIAx [either VIAx or Mx connects to > 3.3V and <= 5V net]. The DRC methodology to find Metal (A): Find an edge (B) of the metal line-end [edge length <= 0.12 um] Run length (C) from edge (B) inside metal >= 0.13 um Jog length (D) <= 0.01 um within 0.13 um run length Extend 0.06 um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied >= 0.15 
  LINE_END_pre   = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M4_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M4_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M4 < M4_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M4_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M4_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M4 < M4_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M4_S_9_A INSIDE BY GRID
  B = STAMP A BY M4i
  I = STAMP (A INTERACT M4_5V_ALL) BY M4i
  J = STAMP (VIA3i AND M4_5V_ALL) BY M4i
  K = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  X1 = EXT I VIA3i < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA4i  < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}



// M4.EN.0 is checked by M4.EN.1 and M4.EN.2__M4.EN.3__M4.EN.3.1
M4.EN.1 { @ Enclosure of VIAx-1 >= 0.0 
  VIA3 NOT M4
}
M4.EN.2__M4.EN.3__M4.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M4_EN_2, or [four sides] >= ^M4_EN_3 with [at least two opposite sides] >= ^M4_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA3 NOT SEALRING_ALL) M4 ABUT < 90 SINGULAR GOOD 0 M4_EN_2 OPPOSITE 0 M4_EN_2 OPPOSITE
  Y = ENC X M4 < M4_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M4 ABUT < 90 GOOD M4_EN_3 M4_EN_3_1 OPPOSITE M4_EN_3 M4_EN_3_1 OPPOSITE
  Y OR (ENC Z M4 < M4_EN_3_1 ABUT < 90 SINGULAR REGION)
}
// M4.EN.2 is checked by M4.EN.2__M4.EN.3__M4.EN.3.1
// M4.EN.3 is checked by M4.EN.2__M4.EN.3__M4.EN.3.1
// M4.EN.3.1 is checked by M4.EN.2__M4.EN.3__M4.EN.3.1

M4.A.1 { @ Area (except M2 (M2.A.1) in SRAMDMY;0 (186;0) region) >= 0.027 
     AREA M4 < M4_A_1
}
M4.A.2 { @ Area [with all of edge length < 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (except M2 (M2.A.2) in SRAMDMY;0 (186;0) region) >= 0.06 
  A = AREA M4 < M4_A_2
  B = LENGTH A >= M4_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M4_A_2_W M4_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M4_A_3pre ((M4_A_3 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))*((M4_A_3 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))/3.141 // user value

M4.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M4 INNER < M4_A_3pre
  AREA ( X NOT M4 ) < M4_A_3
}

// M4.R.1 can not be checked


// M4.DN.0 is checked by M4.DN.1, M4.DN.1.1, M4.DN.4, and DM4.R.1
#IFDEF CHECK_LOW_DENSITY
M4.DN.1 { @ Minimum local density [window ^M4_DN_1_W um x ^M4_DN_1_W um, stepping ^M4_DN_1_S um] >= ^M4_DN_1
  M4_CHECK = M4x NOT M4_EXC_LOW
  CHIP_CHECK = CHIP NOT M4_EXC_LOW

  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK < M4_DN_1 WINDOW M4_DN_1_W STEP M4_DN_1_S INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4_EXC_LOW) >= M4_DN_1_E
  DENSITY F M4_CHECK CHIP_CHECK < M4_DN_1 WINDOW M4_DN_1_W STEP M4_DN_1_S INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.1.density
         [ !AREA(F)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M4.DN.1.1 { @ Maximum local density [window ^M4_DN_1_1_W um x ^M4_DN_1_1_W um, stepping ^M4_DN_1_1_S um] <= ^M4_DN_1_1
  M4_CHECK = M4x NOT M4_EXC_HIGH
  CHIP_CHECK = CHIP NOT M4_EXC_HIGH
  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK > M4_DN_1_1 WINDOW M4_DN_1_1_W STEP M4_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4_EXC_HIGH) >= M4_DN_1_1_E
  DENSITY F M4_CHECK CHIP_CHECK > M4_DN_1_1 WINDOW M4_DN_1_1_W STEP M4_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M4.DN.1.1.density
         [ !!AREA(F)*AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}

M4.DN.4 { @ The metal density difference between any two neighboring checking windows including DM4EXCL [window ^M4_DN_4_W um x ^M4_DN_4_W um, stepping ^M4_DN_4_W um]  <= ^M4_DN_4
  DENSITY M4x CHIP <=1 WINDOW M4_DN_4_W BACKUP GRADIENT > M4_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M4.DN.4.density
  	[ AREA(M4x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M4.DN.6 { @ Metal Desnsity >= ^M4_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M4_DN_6_W_A um x ^M4_DN_6_W_A um, stepping ^M4_DN_6_S_A um] >= ^M4_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M4_DN_6_W_BC um x ^M4_DN_6_W_BC um, stepping ^M4_DN_6_S_BC um < ^M4_DN_6] <= ^M4_DN_6_A_B um2, except merged low density windows width <= ^M4_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M4_DN_6_W_BC um x ^M4_DN_6_W_BC um, stepping ^M4_DN_6_S_BC um < ^M4_DN_6] <= ^M4_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M4_DN_6_E_A um for condition-A and >= ^M4_DN_6_E_BC um for both condition-B/condition-C 
  M4_CHECK = M4x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_A STEP M4_DN_6_S_A INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M4_DN_6_E_A
  DENSITY F_A M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_A STEP M4_DN_6_S_A INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6_A.density
         [ !AREA(F_A)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_BC STEP M4_DN_6_S_BC INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M4_DN_6_E_BC
  A = DENSITY F_B M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_BC STEP M4_DN_6_S_BC INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6_BC.density
         [ !AREA(F_B)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M4_DN_6_A_B
  C = SIZE B BY M4_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M4_DN_6_A_C
}
#ENDIF



// Mx.DN.5
//===========
M4_CORE = M4x NOT SEALRING_EXCLUDE

Mx.DN.5:M2_M3_M4 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1, and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check doesn't include chip corner stress relief pattern, SEALRING_ALL (162;2) and top 2 metals at the CUP area   
    DENSITY  M2_CORE M3_CORE M4_CORE >0 WINDOW M2_DN_5_W STEP M2_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M2_CORE)/AREA()- M2_DN_5)*!~(AREA(M3_CORE)/AREA()- M2_DN_5)*!~(AREA(M4_CORE)/AREA()- M2_DN_5) ]
 	  RDB Mx.DN.5:M2_M3_M4.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M2_M3_M4 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M2,M3,M4) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M2, M3, or M4 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M2_CHECK = M2x NOT NEW_DEN_EXC
   M3_CHECK = M3x NOT NEW_DEN_EXC
   M4_CHECK = M4x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W STEP M2_DN_7_S BACKUP INSIDE OF LAYER CHIP_M4
   [ !~(M2_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M2_DN_7_E
   DENSITY F M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W STEP M2_DN_7_S BACKUP INSIDE OF LAYER CHIP_M4
   [ !!AREA(F)*!~(M2_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M2_M3_M4.density
}
#ENDIF


M4.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M4_PIN NOT INTERACT M4i == 1
}


//VIA4 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M5Wide_2_0 = M5 WITH WIDTH > M5_S_2_W            // 0.17
M5Wide_2_1 = M5Wide_2_0 WITH WIDTH > M5_S_2_1_W  // 0.24
M5Wide_2_2 = M5Wide_2_1 WITH WIDTH > M5_S_2_2_W  // 0.31
M5Wide_2_3 = M5Wide_2_2 WITH WIDTH > M5_S_2_3_W  // 0.62
M5Wide_3_0 = M5Wide_2_3 WITH WIDTH > M5_S_3_W    // 1.65
#ELSE
M5Wide_2_4 = M5 WITH WIDTH > M5_S_2_4_W          // 0.17
M5Wide_2_0 = M5Wide_2_4 WITH WIDTH > M5_S_2_W    // 0.19
M5Wide_2_5 = M5Wide_2_0 WITH WIDTH > M5_S_2_5_W  // 0.24
M5Wide_2_1 = M5Wide_2_5 WITH WIDTH > M5_S_2_1_W  // 0.265
M5Wide_2_6 = M5Wide_2_1 WITH WIDTH > M5_S_2_6_W  // 0.31
M5Wide_2_2 = M5Wide_2_6 WITH WIDTH > M5_S_2_2_W  // 0.345
M5Wide_2_7 = M5Wide_2_2 WITH WIDTH > M5_S_2_7_W  // 0.62
M5Wide_2_3 = M5Wide_2_7 WITH WIDTH > M5_S_2_3_W  // 0.685
M5Wide_3_0 = M5Wide_2_3 WITH WIDTH > M5_S_3_W    // 1.65
#ENDIF

M4Wide_R2_VIA4 = M4Wide_2_0 WITH WIDTH > VIA4_R_2_W        // 0.21
M4Wide_R4_VIA4 = M4Wide_R2_VIA4 WITH WIDTH > VIA4_R_4_W    // 0.21
M4Wide_R3_VIA4 = M4Wide_R4_VIA4 WITH WIDTH > VIA4_R_3_W    // 0.55
M4Wide_R5_VIA4 = M4Wide_R3_VIA4 WITH WIDTH > VIA4_R_5_W    // 1.4
M4Wide_R6_VIA4 = M4Wide_R5_VIA4 WITH WIDTH > VIA4_R_6_W    // 2.1
M5Wide_R2_VIA4 = M5Wide_2_0 WITH WIDTH > VIA4_R_2_W      // 0.21
M5Wide_R4_VIA4 = M5Wide_R2_VIA4 WITH WIDTH > VIA4_R_4_W  // 0.21
M5Wide_R3_VIA4 = M5Wide_R4_VIA4 WITH WIDTH > VIA4_R_3_W  // 0.55
M5Wide_R5_VIA4 = M5Wide_R3_VIA4 WITH WIDTH > VIA4_R_5_W  // 1.4
M5Wide_R6_VIA4 = M5Wide_R5_VIA4 WITH WIDTH > VIA4_R_6_W  // 2.1

VIA4.W.1 { @ Width (maximum = minimum) (Except SEALRING_ALL (162;2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA4i NOT INSIDE (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
}
VIA4.S.1 { @ Space >= 0.07 
  EXT VIA4i < VIA4_S_1 ABUT < 90 SINGULAR REGION
}

VIA4.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA4_S_1_1
  J = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  EXT J VIA4i < VIA4_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

VIA4.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA4i > 2 SPACE < VIA4_S_2_D
  EXT X VIA4i < VIA4_S_2 ABUT < 90 SINGULAR REGION
}
VIA4.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA4i < VIA4_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA4.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA4i < VIA4_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA4.EN.0 is checked by VIA4.EN.1 and VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1

VIA4.EN.1 { @ Enclosure by Mx or M1 >= 0.0 
  VIA4 NOT M4
}

VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1 { @ Enclosure by M4 [at least two opposite sides] >= ^VIA4_EN_2, or [four sides] >= ^VIA4_EN_4 with [at least two opposite sides] >= ^VIA4_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA4 NOT SEALRING_EXCLUDE) M4 ABUT < 90 SINGULAR GOOD 0 VIA4_EN_2 OPPOSITE 0 VIA4_EN_2 OPPOSITE
  Y = ENC X M4 < VIA4_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M4 ABUT < 90 GOOD VIA4_EN_4 VIA4_EN_4_1 OPPOSITE VIA4_EN_4 VIA4_EN_4_1 OPPOSITE
  Y OR (ENC Z M4 < VIA4_EN_4_1 ABUT < 90 SINGULAR REGION)

}
// VIA4.EN.2 is checked by VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1
// VIA4.EN.4 is checked by VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1
// VIA4.EN.4.1 is checked by VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1


// VIA4.EN.3.1 is not necessary to check

// VIA4.R.1 is checked by VIA4.W.1
// VIA4.R.2 is checked by VIA4.R.2__VIA4.R.3
// VIA4.R.3 is checked by VIA4.R.2__VIA4.R.3
VIA4.R.2__VIA4.R.3 { @ When M4 or M5 width > ^VIA4_R_2_W um, more than one VIA4 is required.
                    @ 2 vias spacing should be <= ^VIA4_R_2_S1 um or 4 vias spacing should be <= ^VIA4_R_2_S2 um
                    @ When M4 or M5 width > ^VIA4_R_3_W um, more than three VIA4 is required.
                    @ 4 vias spacing should be <= ^VIA4_R_3_S1 um or 9 vias spacing should be <= ^VIA4_R_3_S2 um
                    @ not check SRAM region					
   M5OvpM4_W_ = (M4Wide_R2_VIA4 AND M5) OR (M5Wide_R2_VIA4 AND M4)
   M5OvpM4_B  = (M4Wide_R3_VIA4 AND M5) OR (M5Wide_R3_VIA4 AND M4)
   M5OvpM4_W  = M5OvpM4_W_ NOT M5OvpM4_B 
   Checked_VIA4_W_ = VIA4_EXD NOT OUTSIDE M5OvpM4_W
   Checked_VIA4_B  = VIA4_EXD NOT OUTSIDE M5OvpM4_B
   Checked_VIA4_W  = Checked_VIA4_W_ NOT Checked_VIA4_B
   M4_effect = M4i INTERACT M5OvpM4_W_
   M5_effect = M5i INTERACT M5OvpM4_W_
   effect_M5OvpM4_ = M4_effect AND M5_effect
   effect_M5OvpM4 = effect_M5OvpM4_ INTERACT M5OvpM4_W_
   effect_VIA = VIA4_EXD INTERACT effect_M5OvpM4

   V4Merged_A = SIZE effect_VIA BY VIA4_R_2_S1/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_B = SIZE V4Merged_A BY (VIA4_R_2_S2 - VIA4_R_2_S1)/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_C = SIZE V4Merged_B BY (VIA4_R_3_S2 - VIA4_R_2_S2)/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_A2R = V4Merged_A INTERACT effect_VIA < 2
   V4Merged_A2 = V4Merged_A OUTSIDE V4Merged_A2R
   V4Merged_A4R = V4Merged_A2 INTERACT effect_VIA < 4
   V4Merged_A4 = V4Merged_A2 OUTSIDE V4Merged_A4R
   V4Merged_B4R = V4Merged_B INTERACT effect_VIA < 4
   V4Merged_B4 = V4Merged_B OUTSIDE V4Merged_B4R
   V4Merged_C9R = V4Merged_C INTERACT effect_VIA < 9
   V4Merged_C9 = V4Merged_C OUTSIDE V4Merged_C9R

   GMergeW = V4Merged_A2 OR V4Merged_B4
   GMergeB = V4Merged_A4 OR V4Merged_C9
   GVIA_W = Checked_VIA4_W INTERACT GMergeW
   GVIA_B = Checked_VIA4_B INTERACT GMergeB
   GOOD_AREA_W = M5OvpM4_W INTERACT GVIA_W
   GOOD_AREA_B = M5OvpM4_B INTERACT GVIA_B
   Checked_VIA4_W OUTSIDE GOOD_AREA_W
   Checked_VIA4_B OUTSIDE GOOD_AREA_B
}
// VIA4.R.2.S is checked by VIA4.R.2__VIA4.R.3
// VIA4.R.3.S is checked by VIA4.R.2__VIA4.R.3

// VIA4.R.4 is checked by VIA4.R.4:M4 and VIA4.R.4:M5
VIA4.R.4:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W).)   
  Branch1 = ((SIZE M4Wide_R4_VIA4 BY VIA4_R_4_D + GRID) NOT M4Wide_R4_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R4_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Wide_R4_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA4.R.4:M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W)).   
  Branch1 = ((SIZE M5Wide_R4_VIA4 BY VIA4_R_4_D + GRID) NOT M5Wide_R4_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R4_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Wide_R4_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M5_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA4.R.4.S is checked by VIA4.R.4:M4 and VIA4.R.4:M5

// VIA4.R.5 is checked by VIA4.R.5:M4 and VIA4.R.5:M5
VIA4.R.5:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W)).
  Branch1 = ((SIZE M4Wide_R5_VIA4 BY VIA4_R_5_D + GRID) NOT M4Wide_R5_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R5_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Wide_R5_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA4.R.5:M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W)).
  Branch1 = ((SIZE M5Wide_R5_VIA4 BY VIA4_R_5_D + GRID) NOT M5Wide_R5_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R5_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Wide_R5_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA4.R.5.S is checked by VIA4.R.5:M4 and VIA4.R.5:M5

// VIA4.R.6 is checked by VIA4.R.6:M4 and VIA4.R.6:M5
M4Big_R6_VIA4 = ENCLOSE RECTANGLE M4Wide_R6_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID

VIA4.R.6:M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W)).
  Branch1 = ((SIZE M4Big_R6_VIA4 BY VIA4_R_6_D + GRID) NOT M4Big_R6_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_R6_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Big_R6_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M5Big_R6_VIA4 = ENCLOSE RECTANGLE M5Wide_R6_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID

VIA4.R.6:M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W)).
  Branch1 = ((SIZE M5Big_R6_VIA4 BY VIA4_R_6_D + GRID) NOT M5Big_R6_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_R6_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Big_R6_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA4.R.6.S is checked by VIA4.R.6:M4 and VIA4.R.6:M5

// VIA4.R.7 is checked by VIA4.EN.1
// VIA4.R.9 can't be checked

VIA4.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA4_R_11_L1 um and both two metal hole area <= ^VIA4_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA4_R_11_L2 um and the width of metal bar is <= ^VIA4_R_11_W um.
  W = M5i WITH WIDTH <= VIA4_R_11_W   
  H_HOLE = (HOLES M5i INNER <= VIA4_R_11_A) INTERACT W
  A0 = M5i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA4_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA4_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA4_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA4_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA4_R_11_L2+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA4
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA4_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA4 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M4i INTERACT CHECK_VIA)) INTERACT VIA4i == 1)
}
// VIA4.R.11.S is checked by VIA4.R.11

VIA4.R.12 { @ VIA4 connected to DM4, DM4_O, DM5, DM5_O is not allowed
  VIA4 INTERACT DUM4
  VIA4 INTERACT DUM5
  VIA4 INTERACT DM4_O
  VIA4 INTERACT DM5_O
}  

//M5 CHECKS
//=========


M5_EDGE_45 = M5 ANGLE == 45

M5.W.1 { @ Width >= 0.07 
  INT M5 < M5_W_1 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45-degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section XXX)) >= 0.17 
  INT M5_EDGE_45 < M5_W_2 ABUT < 90 REGION
}
M5.W.3 { @ Maximum width <= ^M5_W_3 um, exclude SEALRING_ALL 
  M5_MAX_WIDTH WITH WIDTH > M5_W_3
}
// M5.W.3.S is checked by M5.W.3
M5.S.1 { @ Space >= 0.07 
  EXT M5 < M5_S_1 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @ Min. Metal space (for W> ^M5_S_2_W um & parallel length > ^M5_S_2_L um) >= ^M5_S_2 um
  X = EXT M5Wide_2_0 M5 < M5_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_L+GRID
}
// M5.S.2.S is checked by M5.S.2
M5.S.2.1 { @ Min. Metal space (for W> ^M5_S_2_1_W um & parallel length > ^M5_S_2_1_L um) >= ^M5_S_2_1 um
  X = EXT M5Wide_2_1 M5 < M5_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_1_L+GRID
}
// M5.S.2.1.S is checked by M5.S.2.1
M5.S.2.2 { @ Min. Metal space (for W> ^M5_S_2_2_W um & parallel length > ^M5_S_2_2_L um) >= ^M5_S_2_2 um
  X = EXT M5Wide_2_2 M5 < M5_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_2_L+GRID
}
// M5.S.2.2.S is checked by M5.S.2.2
M5.S.2.3 { @ Min. Metal space (for W> ^M5_S_2_3_W um & parallel length > ^M5_S_2_3_L um) >= ^M5_S_2_3 um
  X = EXT M5Wide_2_3 M5 < M5_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_3_L+GRID
}
// M5.S.2.3.S is checked by M5.S.2.3
#IFDEF WIDE_ADJUST
M5.S.2.4 { @ Min. Metal space (for W> ^M5_S_2_4_W um & parallel length > ^M5_S_2_4_L um) >= ^M5_S_2_4 um
  X = EXT M5Wide_2_4 M5 < M5_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_4_L+GRID
}
// M5.S.2.4.S is checked by M5.S.2.4
M5.S.2.5 { @ Min. Metal space (for W> ^M5_S_2_5_W um & parallel length > ^M5_S_2_5_L um) >= ^M5_S_2_5 um
  X = EXT M5Wide_2_5 M5 < M5_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_5_L+GRID
}
// M5.S.2.5.S is checked by M5.S.2.5
M5.S.2.6 { @ Min. Metal space (for W> ^M5_S_2_6_W um & parallel length > ^M5_S_2_6_L um) >= ^M5_S_2_6 um
  X = EXT M5Wide_2_6 M5 < M5_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_6_L+GRID
}
// M5.S.2.6.S is checked by M5.S.2.6
M5.S.2.7 { @ Min. Metal space (for W> ^M5_S_2_7_W um & parallel length > ^M5_S_2_7_L um) >= ^M5_S_2_7 um
  X = EXT M5Wide_2_7 M5 < M5_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_7_L+GRID
}
// M5.S.2.7.S is checked by M5.S.2.7
#ENDIF
M5.S.3 { @ Min. Metal space (for W> ^M5_S_3_W um & parallel length > ^M5_S_3_L um) >= ^M5_S_3 um
  X = EXT M5Wide_3_0 M5 < M5_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  (ENCLOSE RECTANGLE Y 0.001 M5_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M5.S.3.S is checked by M5.S.3
M5.S.5 { @ Space at Mx line-end (W < 0.1 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge < Q distance from the corner of the 2 edges], then one of the spaces (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um (R)) (M2.S.5 except SRAMDMY;0 (186;0) region) >= 0.1 
  A = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M5_S_5_W
  B = EXT [A] M5 < M5_S_5 ABUT < 90 OPPOSITE EXTENDED M5_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M5] < M5_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M5_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M5_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE C
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M5 < M5_S_5 ABUT < 90 OPPOSITE REGION

}

M5.S.5.1 { @ Space at Mx line-end (W<Q=^M5_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M5_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M5_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M5_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M5_S_5_1 um.
  A = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M5_S_5_1_W
  V4_EN = ENC [VIA4i] A < M5_S_5_1_E ABUT < 90 OPPOSITE
  M5_EN = ENC V4_EN [A] < M5_S_5_1_E ABUT < 90 OPPOSITE
  M5_SA = EXT A [M5] < M5_S_5_1 ABUT < 90 OPPOSITE EXTENDED M5_S_5_1_T
  M5_SB = EXT [A] M5_SA < M5_S_5_1 ABUT < 90 OPPOSITE EXTENDED M5_S_5_1_T
  M5_END = (A TOUCH INSIDE EDGE M5_EN) TOUCH INSIDE EDGE M5_SB
  EN_B = ENC V4_EN [M5_END] < M5_S_5_1_E2 OPPOSITE
  EN_C = ENC V4_EN [M5_END] < M5_S_5_1_E3 OPPOSITE
  EN_D = ENC V4_EN [M5_END] < M5_S_5_1_E4 OPPOSITE
  S1_B = EXT [M5_END] M5_SA < M5_S_5_1_S2 OPPOSITE EXTENDED M5_S_5_1_T
  S1_C = EXT [M5_END] M5_SA < M5_S_5_1_S3 OPPOSITE EXTENDED M5_S_5_1_T
  S1_D = EXT [M5_END] M5_SA < M5_S_5_1_S4 OPPOSITE EXTENDED M5_S_5_1_T
  PASS_B = (M5_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M5_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M5_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M5_CHECK = ((M5_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M5_CHECK [M5] < M5_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M5_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M5_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE M5_SB
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M5 < M5_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA4i (O TOUCH INSIDE EDGE P) < M5_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA4i INTERACT Q
  VIA_GOOD = VIA4i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M5 AND M4) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M5_CHECK < M5_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M5.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M5_EDGE_45 OUTSIDE BY M5_S_6
  X AND M5
}


M5.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M5_S_1_1
  I = STAMP M5_5V_ALL BY M5i
  EXT I M5i < M5_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M5.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M5_S_8_2
  I = STAMP M5_5V_ALL BY M5i
  J = STAMP (VIA4i AND M5_5V_ALL) BY M5i
  EXT I VIA4i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_5V_ALL) BY M5i
  EXT I VIA5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}



M5.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] >= 0.1 
  I = STAMP M5_HV_ALL BY M5i
  J = STAMP (VIA4i AND M5_HV_ALL) BY M5i
  EXT I VIA4i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_HV_ALL) BY M5i
  EXT I VIA5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M5.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] >= 0.08 
  I = STAMP M5_MV_ALL BY M5i
  J = STAMP (VIA4i AND M5_MV_ALL) BY M5i
  EXT I VIA4i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_MV_ALL) BY M5i
  EXT I VIA5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M5.S.9 { @ This rule is to check the Metal (A) space with the neighboring VIAx [either VIAx or Mx connects to > 3.3V and <= 5V net]. The DRC methodology to find Metal (A): Find an edge (B) of the metal line-end [edge length <= 0.12 um] Run length (C) from edge (B) inside metal >= 0.13 um Jog length (D) <= 0.01 um within 0.13 um run length Extend 0.06 um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied >= 0.15 
  LINE_END_pre   = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M5_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M5_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M5 < M5_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M5_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M5_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M5 < M5_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M5_S_9_A INSIDE BY GRID
  B = STAMP A BY M5i
  I = STAMP (A INTERACT M5_5V_ALL) BY M5i
  J = STAMP (VIA4i AND M5_5V_ALL) BY M5i
  K = STAMP (VIA5i AND M5_5V_ALL) BY M5i
  X1 = EXT I VIA4i < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA5i  < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}



// M5.EN.0 is checked by M5.EN.1 and M5.EN.2__M5.EN.3__M5.EN.3.1
M5.EN.1 { @ Enclosure of VIAx-1 >= 0.0 
  VIA4 NOT M5
}
M5.EN.2__M5.EN.3__M5.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M5_EN_2, or [four sides] >= ^M5_EN_3 with [at least two opposite sides] >= ^M5_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA4 NOT SEALRING_ALL) M5 ABUT < 90 SINGULAR GOOD 0 M5_EN_2 OPPOSITE 0 M5_EN_2 OPPOSITE
  Y = ENC X M5 < M5_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M5 ABUT < 90 GOOD M5_EN_3 M5_EN_3_1 OPPOSITE M5_EN_3 M5_EN_3_1 OPPOSITE
  Y OR (ENC Z M5 < M5_EN_3_1 ABUT < 90 SINGULAR REGION)
}
// M5.EN.2 is checked by M5.EN.2__M5.EN.3__M5.EN.3.1
// M5.EN.3 is checked by M5.EN.2__M5.EN.3__M5.EN.3.1
// M5.EN.3.1 is checked by M5.EN.2__M5.EN.3__M5.EN.3.1

M5.A.1 { @ Area (except M2 (M2.A.1) in SRAMDMY;0 (186;0) region) >= 0.027 
     AREA M5 < M5_A_1
}
M5.A.2 { @ Area [with all of edge length < 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (except M2 (M2.A.2) in SRAMDMY;0 (186;0) region) >= 0.06 
  A = AREA M5 < M5_A_2
  B = LENGTH A >= M5_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M5_A_2_W M5_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M5_A_3pre ((M5_A_3 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))*((M5_A_3 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))/3.141 // user value

M5.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M5 INNER < M5_A_3pre
  AREA ( X NOT M5 ) < M5_A_3
}

// M5.R.1 can not be checked


// M5.DN.0 is checked by M5.DN.1, M5.DN.1.1, M5.DN.4, and DM5.R.1
#IFDEF CHECK_LOW_DENSITY
M5.DN.1 { @ Minimum local density [window ^M5_DN_1_W um x ^M5_DN_1_W um, stepping ^M5_DN_1_S um] >= ^M5_DN_1
  M5_CHECK = M5x NOT M5_EXC_LOW
  CHIP_CHECK = CHIP NOT M5_EXC_LOW

  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK < M5_DN_1 WINDOW M5_DN_1_W STEP M5_DN_1_S INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5_EXC_LOW) >= M5_DN_1_E
  DENSITY F M5_CHECK CHIP_CHECK < M5_DN_1 WINDOW M5_DN_1_W STEP M5_DN_1_S INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.1.density
         [ !AREA(F)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M5.DN.1.1 { @ Maximum local density [window ^M5_DN_1_1_W um x ^M5_DN_1_1_W um, stepping ^M5_DN_1_1_S um] <= ^M5_DN_1_1
  M5_CHECK = M5x NOT M5_EXC_HIGH
  CHIP_CHECK = CHIP NOT M5_EXC_HIGH
  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK > M5_DN_1_1 WINDOW M5_DN_1_1_W STEP M5_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5_EXC_HIGH) >= M5_DN_1_1_E
  DENSITY F M5_CHECK CHIP_CHECK > M5_DN_1_1 WINDOW M5_DN_1_1_W STEP M5_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.1.1.density
         [ !!AREA(F)*AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}

M5.DN.4 { @ The metal density difference between any two neighboring checking windows including DM5EXCL [window ^M5_DN_4_W um x ^M5_DN_4_W um, stepping ^M5_DN_4_W um]  <= ^M5_DN_4
  DENSITY M5x CHIP <=1 WINDOW M5_DN_4_W BACKUP GRADIENT > M5_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M5.DN.4.density
  	[ AREA(M5x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M5.DN.6 { @ Metal Desnsity >= ^M5_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M5_DN_6_W_A um x ^M5_DN_6_W_A um, stepping ^M5_DN_6_S_A um] >= ^M5_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M5_DN_6_W_BC um x ^M5_DN_6_W_BC um, stepping ^M5_DN_6_S_BC um < ^M5_DN_6] <= ^M5_DN_6_A_B um2, except merged low density windows width <= ^M5_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M5_DN_6_W_BC um x ^M5_DN_6_W_BC um, stepping ^M5_DN_6_S_BC um < ^M5_DN_6] <= ^M5_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M5_DN_6_E_A um for condition-A and >= ^M5_DN_6_E_BC um for both condition-B/condition-C 
  M5_CHECK = M5x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_A STEP M5_DN_6_S_A INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M5_DN_6_E_A
  DENSITY F_A M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_A STEP M5_DN_6_S_A INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6_A.density
         [ !AREA(F_A)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_BC STEP M5_DN_6_S_BC INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M5_DN_6_E_BC
  A = DENSITY F_B M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_BC STEP M5_DN_6_S_BC INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6_BC.density
         [ !AREA(F_B)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M5_DN_6_A_B
  C = SIZE B BY M5_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M5_DN_6_A_C
}
#ENDIF



// Mx.DN.5
//===========
M5_CORE = (M5x NOT SEALRING_EXCLUDE) NOT (WBDMY OR CB_MT)

Mx.DN.5:M3_M4_M5 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1, and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check doesn't include chip corner stress relief pattern, SEALRING_ALL (162;2) and top 2 metals at the CUP area   
    DENSITY  M3_CORE M4_CORE M5_CORE >0 WINDOW M3_DN_5_W STEP M3_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M3_CORE)/AREA()- M3_DN_5)*!~(AREA(M4_CORE)/AREA()- M3_DN_5)*!~(AREA(M5_CORE)/AREA()- M3_DN_5) ]
 	  RDB Mx.DN.5:M3_M4_M5.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M3_M4_M5 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M3,M4,M5) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M3, M4, or M5 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M3_CHECK = M3x NOT NEW_DEN_EXC
   M4_CHECK = M4x NOT NEW_DEN_EXC
   M5_CHECK = M5x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W STEP M3_DN_7_S BACKUP INSIDE OF LAYER CHIP_M5
   [ !~(M3_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M3_DN_7_E
   DENSITY F M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W STEP M3_DN_7_S BACKUP INSIDE OF LAYER CHIP_M5
   [ !!AREA(F)*!~(M3_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M3_M4_M5.density
}
#ENDIF


M5.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M5_PIN NOT INTERACT M5i == 1
}


//VIA5 CHECKS
//===========

VIA5.W.1 { @ Width (maximum = minimum), except SEALRING_ALL (162;2) region = 0.36 
  NOT RECTANGLE (VIA5 NOT SEALRING_EXCLUDE) == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
}
VIA5.S.1 { @ Space >= 0.34 
  EXT VIA5 < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
VIA5.S.2 { @ Space to 3-neighboring VIAz (distance < 0.56 um) >= 0.54 
  X = WITH NEIGHBOR VIA5 > 2 SPACE < VIA5_S_2_D
  EXT X VIA5 < VIA5_S_2 ABUT < 90 SINGULAR REGION
}
VIA5.EN.1 { @ Enclosure by Mx or My or Mz (This check doesn't include the SEALRING_ALL (162;2) region) >= 0.02 
  ENC (VIA5 NOT SEALRING_EXCLUDE) M5 < VIA5_EN_1 ABUT < 90 SINGULAR REGION
  VIA5 NOT M5 
}

VIA5.EN.2 { @ Enclosure by Mx or My or Mz [at least 2 opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT < 90 SINGULAR GOOD VIA5_EN_1 VIA5_EN_2 OPPOSITE VIA5_EN_1 VIA5_EN_2 OPPOSITE
  Y = ENC [X] M5 < VIA5_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA5_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

// VIA5.R.1 is checked by VIA5.W.1

M6Wide_1.8_VIA5T = M6 WITH WIDTH > VIA5_R_2_W
M5Wide_1.8_VIA5T = M5 WITH WIDTH > VIA5_R_2_W
M6Wide_3_VIA5T = M6Wide_1.8_VIA5T WITH WIDTH > VIA5_R_3_W
M5Wide_3_VIA5T =  M5Wide_1.8_VIA5T WITH WIDTH > VIA5_R_3_W

VIA5.R.2 { @ At least two VIAz with spacing <= ^VIA5_R_2_S um are required to connect Mz and Mz+1 when one of these metals has a width and length > ^VIA5_R_2_W um.
   M6OvpM5W = (M6 AND M5Wide_1.8_VIA5T) OR (M5 AND M6Wide_1.8_VIA5T)
   Checked_VIA5 = VIA5_EXD NOT OUTSIDE M6OvpM5W
   M5_effect = M5i INTERACT M6OvpM5W
   M6_effect = M6i INTERACT M6OvpM5W
   effect_M6OvpM5_ = M5_effect AND M6_effect
   effect_M6OvpM5 = effect_M6OvpM5_ INTERACT M6OvpM5W
   Effect_VIA5 = VIA5_EXD INTERACT effect_M6OvpM5
   VIA5Merged = SIZE Effect_VIA5 BY VIA5_R_2_S /2 INSIDE OF effect_M6OvpM5 STEP M5_S_1*0.7
   VIA5Merged2 = VIA5Merged ENCLOSE Effect_VIA5 >=2
   GVIA = Checked_VIA5 INTERACT VIA5Merged2
   GM6OvpM5W = M6OvpM5W INTERACT GVIA
   Checked_VIA5 OUTSIDE GM6OvpM5W
}   
// VIA5.R.2.S is checked by VIA5.R.2

// VIA5.R.3 is checked by VIA5.R.3:M5 and VIA5.R.3:M6
M5Big_3_VIA5T = ENCLOSE RECTANGLE M5Wide_3_VIA5T VIA5_R_3_W VIA5_R_3_L+GRID

VIA5.R.3:M5 { @ At least two VIAz must be used for a connection that is <= ^VIA5_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA5_R_3_L um (L) and width  ^VIA5_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA5_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA5_R_3_L um (L) and width  ^VIA5_R_3_W um (W)).
  Branch1 = ((SIZE M5Big_3_VIA5T BY VIA5_R_3_D + GRID) NOT M5Big_3_VIA5T) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_3_VIA5T) INTERACT VIA5
  Branch1Edge = M5Big_3_VIA5T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_3_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M6Big_3_VIA5T = ENCLOSE RECTANGLE M6Wide_3_VIA5T VIA5_R_3_W VIA5_R_3_L+GRID

VIA5.R.3:M6 { @ At least two VIAz must be used for a connection that is <= ^VIA5_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA5_R_3_L um (L) and width  ^VIA5_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA5_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA5_R_3_L um (L) and width  ^VIA5_R_3_W um (W)).
  Branch1 = ((SIZE M6Big_3_VIA5T BY VIA5_R_3_D + GRID) NOT M6Big_3_VIA5T) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_3_VIA5T) INTERACT VIA5
  Branch1Edge = M6Big_3_VIA5T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_3_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA5.R.3.S is checked by VIA5.R.3:M5 and VIA5.R.3:M6

// VIA5.R.4 is checked by VIA5.EN.1
// VIA5.R.5 can not be checked.

VIA5.R.6 { @ VIA5 connected to DM5, DM6 is not allowed
  VIA5 INTERACT DUM5
  VIA5 INTERACT DUM6
}  

//M6 CHECKS
//=============

M6Wide_1.5 =  M6 WITH WIDTH > M6_S_2_W
M6Wide_4.5 =  M6Wide_1.5 WITH WIDTH > M6_S_3_W


M6.W.1 { @ Width >= 0.4 
  (INT M6 < M6_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}

M6.W.2 { @ Maximun width <= ^M6_W_2 um 
  M6_MAX_WIDTH WITH WIDTH > M6_W_2
}
// M6.W.2.S is checked by M6.W.2

M6.S.1 { @ Space >= 0.4 
  (EXT M6 < M6_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}
M6.S.2 { @ Min. Metal space (for W > ^M6_S_2_W um & parallel length > ^M6_S_2_L um) >= ^M6_S_2 um
  X = EXT M6Wide_1.5 M6 < M6_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  (ENCLOSE RECTANGLE Y 0.001 M6_S_2_L+0.001) NOT INSIDE IND_REGION
}
// M6.S.2.S is checked by M6.S.2
M6.S.3 { @ Min. Metal space (for W > ^M6_S_3_W um & parallel length > ^M6_S_3_L um) >= ^M6_S_3 um
  X = EXT M6Wide_4.5 M6 < M6_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  (ENCLOSE RECTANGLE Y 0.001 M6_S_3_L+0.001) NOT INSIDE IND_REGION
}
// M6.S.3.S is checked by M6.S.3
M6.EN.1 { @ Enclosure of VIAz-1 (This check doesn't include the SEALRING_ALL (162;2) region) >= 0.02 
  ENC (VIA5 NOT SEALRING_EXCLUDE) M6 < M6_EN_1 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6
}
M6.EN.2 { @ Enclosure of VIAz-1 [at least 2 opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA5 M6 ABUT < 90 SINGULAR GOOD M6_EN_1 M6_EN_2 OPPOSITE M6_EN_1 M6_EN_2 OPPOSITE
  Y = ENC [X] M6 < M6_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA5_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M6.A.1 { @ Area >= 0.565 
  AREA M6 < M6_A_1
}


VARIABLE M6_A_2pre ((M6_A_2 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))*((M6_A_2 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))/3.141 // user value

M6.A.2 { @ Enclosed area >= 0.565 
  X = HOLES M6 INNER < M6_A_2pre
  AREA ( X NOT M6 ) < M6_A_2
}


// M6.DN.0 is checked by M6.DN.1, M6.DN.1.1, M6.DN.4, and DM6.R.1
#IFDEF CHECK_LOW_DENSITY
M6.DN.1 { @ Minimum local density [window ^M6_DN_1_W um x ^M6_DN_1_W um, stepping ^M6_DN_1_S um] >= ^M6_DN_1
  M6_CHECK = M6x NOT M6_EXC_LOW
  CHIP_CHECK = CHIP NOT M6_EXC_LOW

  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK < M6_DN_1 WINDOW M6_DN_1_W STEP M6_DN_1_S INSIDE OF LAYER CHIP_M6 BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6_EXC_LOW) >= M6_DN_1_E
  DENSITY F M6_CHECK CHIP_CHECK < M6_DN_1 WINDOW M6_DN_1_W STEP M6_DN_1_S INSIDE OF LAYER CHIP_M6 BACKUP PRINT M6.DN.1.density
         [ !AREA(F)+AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M6.DN.1.1 { @ Maximum local density [window ^M6_DN_1_1_W um x ^M6_DN_1_1_W um, stepping ^M6_DN_1_1_S um] <= ^M6_DN_1_1
  M6_CHECK = M6x NOT M6_EXC_HIGH
  CHIP_CHECK = CHIP NOT M6_EXC_HIGH
  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK > M6_DN_1_1 WINDOW M6_DN_1_1_W STEP M6_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6_EXC_HIGH) >= M6_DN_1_1_E
  DENSITY F M6_CHECK CHIP_CHECK > M6_DN_1_1 WINDOW M6_DN_1_1_W STEP M6_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M6.DN.1.1.density
         [ !!AREA(F)*AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}

M6.DN.4 { @ The metal density difference between any two neighboring checking windows including DM6EXCL [window ^M6_DN_4_W um x ^M6_DN_4_W um, stepping ^M6_DN_4_W um]  <= ^M6_DN_4
  DENSITY M6x CHIP <=1 WINDOW M6_DN_4_W BACKUP GRADIENT > M6_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M6.DN.4.density
  	[ AREA(M6x)/AREA(CHIP) ]    
}




// M6.R.1 can't be checked

M6.R.2 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M6_PIN NOT INTERACT M6i == 1
}




// LOWMEDN CHECKS
//===============
LOWMEDN.W.1 { @ Width of {(M1, DM1, DM1_O) AND LOWMEDN} >= 0.14
  A = M1x AND LOWMEDN
  INT A < LOWMEDN_W_1 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2:M2 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M2x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.W.2 is checked by LOWMEDN.W.2:M2
LOWMEDN.W.2:M3 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M3x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.W.2 is checked by LOWMEDN.W.2:M3
LOWMEDN.W.2:M4 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M4x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.W.2 is checked by LOWMEDN.W.2:M4
LOWMEDN.W.2:M5 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M5x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.W.2 is checked by LOWMEDN.W.2:M5
LOWMEDN.S.1 { @ Space of {(M1, DM1, DM1_O) AND LOWMEDN} >= 0.14
  A = M1x AND LOWMEDN
  EXT A < LOWMEDN_S_1 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2:M2 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M2x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.S.2 is checked by LOWMEDN.S.2:M2
LOWMEDN.S.2:M3 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M3x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.S.2 is checked by LOWMEDN.S.2:M3
LOWMEDN.S.2:M4 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M4x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.S.2 is checked by LOWMEDN.S.2:M4
LOWMEDN.S.2:M5 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M5x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
// LOWMEDN.S.2 is checked by LOWMEDN.S.2:M5

LOWMEDN.R.1 { @ Protection ring must be inside {LOWMEDN NOT (LOWMEDN SIZING -1 um)}. The protection ring must include all Mx/all VIAx/.../V1/M1 layers.
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA1
  P_RING_VIA1_end = CONVEX EDGE P_RING_VIA1 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA1_c = EXT P_RING_VIA1_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_o = P_RING_VIA1_c OR P_RING_VIA1
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA1_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA2
  P_RING_VIA2_end = CONVEX EDGE P_RING_VIA2 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA2_c = EXT P_RING_VIA2_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_o = P_RING_VIA2_c OR P_RING_VIA2
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA2_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA3
  P_RING_VIA3_end = CONVEX EDGE P_RING_VIA3 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA3_c = EXT P_RING_VIA3_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_o = P_RING_VIA3_c OR P_RING_VIA3
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA3_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA4
  P_RING_VIA4_end = CONVEX EDGE P_RING_VIA4 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA4_c = EXT P_RING_VIA4_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_o = P_RING_VIA4_c OR P_RING_VIA4
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA4_o)
}

LOWMEDN.R.2 { @ There must be continuous VIAx bar as a ring within {LOWMEDN NOT (LOWMEDN SIZING -4 um)}. (except {LOWMEDN interact INDDMY}).
  CONVEX EDGE P_RING_VIA1_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  NOT DONUT P_RING_VIA1_noIND
  CONVEX EDGE P_RING_VIA2_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  NOT DONUT P_RING_VIA2_noIND
  CONVEX EDGE P_RING_VIA3_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  NOT DONUT P_RING_VIA3_noIND
  CONVEX EDGE P_RING_VIA4_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  NOT DONUT P_RING_VIA4_noIND
}

// LOWMEDN.R.3 is checked by [VIAx.W.1]
// LOWMEDN.R.4 is checked by [VIAx.EN.8, Mx.EN.4]

LOWMEDN.R.5 { @ For {LOWMEDN interact INDDMY}, there must be either only one breach (C-shape ring) of metal/Via with via space <= 4um or VIAx bar must be continuous within {LOWMEDN NOT (LOWMEDN SIZING -4 um)}.
  P_RING_VIA1_IND_end = CONVEX EDGE P_RING_VIA1_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA1_IND_c = EXT P_RING_VIA1_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA1_IND_c
  P_RING_VIA1_IND_c INTERACT P_RING_VIA1_IND > 1
  P_RING_VIA1_IND INTERACT P_RING_VIA1_IND_c > 1
  P_RING_VIA1_IND_o = P_RING_VIA1_IND_c OR P_RING_VIA1_IND
  NOT DONUT P_RING_VIA1_IND_o
  P_RING_VIA2_IND_end = CONVEX EDGE P_RING_VIA2_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA2_IND_c = EXT P_RING_VIA2_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA2_IND_c
  P_RING_VIA2_IND_c INTERACT P_RING_VIA2_IND > 1
  P_RING_VIA2_IND INTERACT P_RING_VIA2_IND_c > 1
  P_RING_VIA2_IND_o = P_RING_VIA2_IND_c OR P_RING_VIA2_IND
  NOT DONUT P_RING_VIA2_IND_o
  P_RING_VIA3_IND_end = CONVEX EDGE P_RING_VIA3_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA3_IND_c = EXT P_RING_VIA3_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA3_IND_c
  P_RING_VIA3_IND_c INTERACT P_RING_VIA3_IND > 1
  P_RING_VIA3_IND INTERACT P_RING_VIA3_IND_c > 1
  P_RING_VIA3_IND_o = P_RING_VIA3_IND_c OR P_RING_VIA3_IND
  NOT DONUT P_RING_VIA3_IND_o
  P_RING_VIA4_IND_end = CONVEX EDGE P_RING_VIA4_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA4_IND_c = EXT P_RING_VIA4_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA4_IND_c
  P_RING_VIA4_IND_c INTERACT P_RING_VIA4_IND > 1
  P_RING_VIA4_IND INTERACT P_RING_VIA4_IND_c > 1
  P_RING_VIA4_IND_o = P_RING_VIA4_IND_c OR P_RING_VIA4_IND
  NOT DONUT P_RING_VIA4_IND_o
}

LOWMEDN.R.6 { @ For C-shape ring, at least 2 protection rings are must in {LOWMEDN INTERACT INDDMY}. At least 2 VIAx bar in {LOWMEDN NOT (LOWMEDN SIZING -4 um)} for the protection ring with the breach.
  P_RING_REGION_IND = P_RING_REGION INTERACT LOWMEDN_IND
  P_RING_VIA1_IND_end = CONVEX EDGE P_RING_VIA1_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA1_IND_c = EXT P_RING_VIA1_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_IND_o = (P_RING_VIA1_IND_c OR P_RING_VIA1_IND) INTERACT P_RING_VIA1_IND_c
  P_RING_VIA1_IND_ox = HOLES P_RING_VIA1_IND_o
  LOWMEDN_CORE2_IND_VIA1 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA1_IND_c)
  LOWMEDN_CORE2_IND_VIA1 NOT INSIDE P_RING_VIA1_IND_ox
  P_RING_VIA1_IND_o2 = P_RING_VIA1_IND_o INSIDE P_RING_VIA1_IND_ox
  P_RING_VIA1_IND_o2x = HOLES P_RING_VIA1_IND_o2
  LOWMEDN_CORE2_IND_VIA1 NOT INSIDE P_RING_VIA1_IND_o2x
  P_RING_VIA2_IND_end = CONVEX EDGE P_RING_VIA2_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA2_IND_c = EXT P_RING_VIA2_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_IND_o = (P_RING_VIA2_IND_c OR P_RING_VIA2_IND) INTERACT P_RING_VIA2_IND_c
  P_RING_VIA2_IND_ox = HOLES P_RING_VIA2_IND_o
  LOWMEDN_CORE2_IND_VIA2 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA2_IND_c)
  LOWMEDN_CORE2_IND_VIA2 NOT INSIDE P_RING_VIA2_IND_ox
  P_RING_VIA2_IND_o2 = P_RING_VIA2_IND_o INSIDE P_RING_VIA2_IND_ox
  P_RING_VIA2_IND_o2x = HOLES P_RING_VIA2_IND_o2
  LOWMEDN_CORE2_IND_VIA2 NOT INSIDE P_RING_VIA2_IND_o2x
  P_RING_VIA3_IND_end = CONVEX EDGE P_RING_VIA3_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA3_IND_c = EXT P_RING_VIA3_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_IND_o = (P_RING_VIA3_IND_c OR P_RING_VIA3_IND) INTERACT P_RING_VIA3_IND_c
  P_RING_VIA3_IND_ox = HOLES P_RING_VIA3_IND_o
  LOWMEDN_CORE2_IND_VIA3 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA3_IND_c)
  LOWMEDN_CORE2_IND_VIA3 NOT INSIDE P_RING_VIA3_IND_ox
  P_RING_VIA3_IND_o2 = P_RING_VIA3_IND_o INSIDE P_RING_VIA3_IND_ox
  P_RING_VIA3_IND_o2x = HOLES P_RING_VIA3_IND_o2
  LOWMEDN_CORE2_IND_VIA3 NOT INSIDE P_RING_VIA3_IND_o2x
  P_RING_VIA4_IND_end = CONVEX EDGE P_RING_VIA4_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6A+GRID
  P_RING_VIA4_IND_c = EXT P_RING_VIA4_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_IND_o = (P_RING_VIA4_IND_c OR P_RING_VIA4_IND) INTERACT P_RING_VIA4_IND_c
  P_RING_VIA4_IND_ox = HOLES P_RING_VIA4_IND_o
  LOWMEDN_CORE2_IND_VIA4 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA4_IND_c)
  LOWMEDN_CORE2_IND_VIA4 NOT INSIDE P_RING_VIA4_IND_ox
  P_RING_VIA4_IND_o2 = P_RING_VIA4_IND_o INSIDE P_RING_VIA4_IND_ox
  P_RING_VIA4_IND_o2x = HOLES P_RING_VIA4_IND_o2
  LOWMEDN_CORE2_IND_VIA4 NOT INSIDE P_RING_VIA4_IND_o2x
}


VIA1.W.6 { @ Width of VIAx bar in protection ring [INSIDE LOWMEDN] Checking tolerance for 45-degree protection ring: 0.005 um [Width = 0.070 um] 0.010 um [Width = 0.075 um] = 0.070 or 0.075 
  X1 = ANGLE P_RING_VIA1 != 45
  X2 = ANGLE P_RING_VIA1 == 45
  WITH WIDTH P_RING_VIA1 >= VIAx_W_6A*2
  INT X1 < VIAx_W_6A ABUT < 90 REGION
  INT X1 > VIAx_W_6A < VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X1 > VIAx_W_6B < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION

  INT X2 < VIAx_W_6A-0.005 ABUT < 90 REGION
  INT X2 > VIAx_W_6B+0.01 < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  X = INT X2 > VIAx_W_6A+0.005 < VIAx_W_6B+0.01 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (SIZE X BY GRID) NOT INTERACT (INT X1 == VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION)
}
VIA1.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA1 VIA1_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA1.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA1 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA1.EN.8 { @ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA1 != 45
  X3 = ANGLE M1 != 45
  ENC P_RING_VIA1 M1 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M2.EN.4 { @ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA1 != 45
  X3 = ANGLE M2 != 45
  ENC P_RING_VIA1 M2 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA2.W.6 { @ Width of VIAx bar in protection ring [INSIDE LOWMEDN] Checking tolerance for 45-degree protection ring: 0.005 um [Width = 0.070 um] 0.010 um [Width = 0.075 um] = 0.070 or 0.075 
  X1 = ANGLE P_RING_VIA2 != 45
  X2 = ANGLE P_RING_VIA2 == 45
  WITH WIDTH P_RING_VIA2 >= VIAx_W_6A*2
  INT X1 < VIAx_W_6A ABUT < 90 REGION
  INT X1 > VIAx_W_6A < VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X1 > VIAx_W_6B < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION

  INT X2 < VIAx_W_6A-0.005 ABUT < 90 REGION
  INT X2 > VIAx_W_6B+0.01 < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  X = INT X2 > VIAx_W_6A+0.005 < VIAx_W_6B+0.01 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (SIZE X BY GRID) NOT INTERACT (INT X1 == VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION)
}
VIA2.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA2 VIA2_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA2.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA2 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA2.EN.8 { @ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA2 != 45
  X3 = ANGLE M2 != 45
  ENC P_RING_VIA2 M2 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M3.EN.4 { @ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA2 != 45
  X3 = ANGLE M3 != 45
  ENC P_RING_VIA2 M3 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA3.W.6 { @ Width of VIAx bar in protection ring [INSIDE LOWMEDN] Checking tolerance for 45-degree protection ring: 0.005 um [Width = 0.070 um] 0.010 um [Width = 0.075 um] = 0.070 or 0.075 
  X1 = ANGLE P_RING_VIA3 != 45
  X2 = ANGLE P_RING_VIA3 == 45
  WITH WIDTH P_RING_VIA3 >= VIAx_W_6A*2
  INT X1 < VIAx_W_6A ABUT < 90 REGION
  INT X1 > VIAx_W_6A < VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X1 > VIAx_W_6B < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION

  INT X2 < VIAx_W_6A-0.005 ABUT < 90 REGION
  INT X2 > VIAx_W_6B+0.01 < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  X = INT X2 > VIAx_W_6A+0.005 < VIAx_W_6B+0.01 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (SIZE X BY GRID) NOT INTERACT (INT X1 == VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION)
}
VIA3.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA3 VIA3_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA3.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA3 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA3.EN.8 { @ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA3 != 45
  X3 = ANGLE M3 != 45
  ENC P_RING_VIA3 M3 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M4.EN.4 { @ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA3 != 45
  X3 = ANGLE M4 != 45
  ENC P_RING_VIA3 M4 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA4.W.6 { @ Width of VIAx bar in protection ring [INSIDE LOWMEDN] Checking tolerance for 45-degree protection ring: 0.005 um [Width = 0.070 um] 0.010 um [Width = 0.075 um] = 0.070 or 0.075 
  X1 = ANGLE P_RING_VIA4 != 45
  X2 = ANGLE P_RING_VIA4 == 45
  WITH WIDTH P_RING_VIA4 >= VIAx_W_6A*2
  INT X1 < VIAx_W_6A ABUT < 90 REGION
  INT X1 > VIAx_W_6A < VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X1 > VIAx_W_6B < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION

  INT X2 < VIAx_W_6A-0.005 ABUT < 90 REGION
  INT X2 > VIAx_W_6B+0.01 < VIAx_W_6A*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  X = INT X2 > VIAx_W_6A+0.005 < VIAx_W_6B+0.01 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (SIZE X BY GRID) NOT INTERACT (INT X1 == VIAx_W_6B ABUT < 90 OPPOSITE PARALLEL ONLY REGION)
}
VIA4.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA4 VIA4_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA4.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA4 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA4.EN.8 { @ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA4 != 45
  X3 = ANGLE M4 != 45
  ENC P_RING_VIA4 M4 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M5.EN.4 { @ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA4 != 45
  X3 = ANGLE M5 != 45
  ENC P_RING_VIA4 M5 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}



// RV CHECKS
//==========

RV_CHECK = RV NOT SEALRING_EXCLUDE
RV_NIND = RV_CHECK NOT INSIDE IND_EXD
RV_IND = RV_CHECK INSIDE IND_EXD
// RV.R.2 is checked by RV.W.1, RV.S.1, and RV.EN.1
RV.W.1 { @ Width (maximum = minimum) (Except SEALRING_ALL (162;2)) (It is allowed to have both via dimensions in the same chip.) = 3 
  NOT RECTANGLE RV_NIND == RV_W_1A BY == RV_W_1A ORTHOGONAL ONLY
  NOT RECTANGLE RV_IND >= (RV_W_1A-2*GRID) <= (RV_W_1A+2*GRID) BY >= (RV_W_1A-2*GRID) <= (RV_W_1A+2*GRID)
}
RV.S.1 { @ Space >= 2 
  EXT RV_NIND RV < RV_S_1 ABUT < 90 SINGULAR REGION
  EXT RV_IND RV < RV_S_1-2*GRID ABUT < 90 SINGULAR REGION
}
RV.EN.1 { @ Enclosure by top metal >= 0.5 
  ENC RV_NIND M6 < RV_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  ENC RV_IND M6 < RV_EN_1-2*GRID ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
RV.R.1 { @ A 45-degree rotated RV is not allowed (Except {(INDDMY OR INDDMY_MD) SIZING 22 um})   
  (NOT RECTANGLE RV_CHECK ORTHOGONAL ONLY) NOT INSIDE IND_EXD
}

// AP CHECKS
//==========
//AP.R.1 is checked by AP.W.1, AP.S.1, and AP.EN.1
AP.W.1 { @ Width (as interconnect) >= ^AP_W_1 um
  (INT AP < AP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_EXD
  (INT AP < AP_W_1-2*GRID ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_EXD
}
AP.W.2 { @ Maximum width by {{AP/AP-MD SIZING 0.995 um} SIZING -0.995 um} (as interconnect) {NOT INSIDE UBM, CB or CB2} <= 35 
#IFNDEF WLCSP
  A = AP NOT (UBMi OR (CB1i OR CB2i))
#ELSE
  A = AP NOT (CB1i OR CB2i)
#ENDIF  
  B = SIZE (SIZE A BY 0.995) BY -0.995
  (B WITH WIDTH > AP_W_2) NOT INSIDE IND_EXD
  (B WITH WIDTH > AP_W_2+2*GRID) NOT OUTSIDE IND_EXD
}
#IFDEF FULL_CHIP
#IFDEF AP_28K_THICKNESS
AP_HOLE = HOLES AP INNER 
AP_HOLE_SHORT_EDGE = LENGTH AP_HOLE < 3
GRID_VERTEX = INT AP_HOLE <= 0.01 ABUT == 90 REGION
AP_HOLE_SHORT_EDGE_region = EXPAND EDGE AP_HOLE_SHORT_EDGE INSIDE BY 0.005
GRID_VERTEX_check = GRID_VERTEX INTERACT AP_HOLE_SHORT_EDGE_region
GRID_EXTENT = EXTENTS GRID_VERTEX_check CENTERS 0.01

AP.W.5 { @ AP hole width for 28KA AP, except < 100 inner 90-degrees vertex of AP holes [width < 3 um] within window 100 um x 100 um, stepping 50 um >= 3 
  DENSITY GRID_EXTENT >= 100 WINDOW 100 STEP 50 INSIDE OF LAYER CHIP_EDGE BACKUP PRINT AP.W.5.density RDB AP.W.5.rdb
          [ 1E4 * AREA(GRID_EXTENT) ]
}
#ENDIF // AP_28K_THICKNESS
#ENDIF // FULL_CHIP

AP.S.1 { @ Space >= ^AP_S_1 um
         @  Except the following conditions in the same polygon: 1. {{{AP AND {AP_PAD SIZING 2 um}} NOT AP_PAD} INTERACT AP_PAD} 2. Jog <= 1 um in the same polygon 3. AP hole [Width < 2 um]
  AP_PAD = (AP INTERACT (CB2Fi OR CB2Wi)) SIZE BY 35/2 underover

  AP_PAD_1 = SIZE AP_PAD BY 0.005
  A = ((AP AND (SIZE AP_PAD BY 2)) NOT AP_PAD) INTERACT AP_PAD_1
  B = EXT AP < AP_S_1 NOTCH REGION
  C = (EXT A AP_PAD < AP_S_1 REGION) AND B
  C1 = (EXT A < AP_S_1 REGION) AND B
  C2 = (EXT AP_PAD < AP_S_1 REGION) AND B
  D_pre = HOLES AP INNER
  D = (INT D_pre < 2 REGION) AND B
  E = LENGTH AP <= 0.5* 2.0
  F = (EXT E AP < AP_S_1 REGION) AND B
  G2 = EXPAND EDGE AP_PAD BY 0.005
  WAIVE_REGION = SIZE (((((C OR C1) OR C2) OR G2) OR D) OR F) BY 0.005
  ((EXT AP < AP_S_1  SINGULAR REGION) NOT INSIDE IND_EXD) NOT WAIVE_REGION
  ((EXT AP < AP_S_1-2*GRID  SINGULAR REGION) NOT OUTSIDE IND_EXD) NOT WAIVE_REGION
  (EXT AP < AP_S_1 SPACE  SINGULAR REGION) NOT INSIDE IND_EXD
  (EXT AP < AP_S_1-2*GRID SPACE  SINGULAR REGION) NOT OUTSIDE IND_EXD
  X = INT APi < 0.1 ABUT < 90 INTERSECTING ONLY REGION
  Y = EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY REGION
  X NOT INTERACT AP_PAD_1
  Y NOT INTERACT AP_PAD_1
}

AP_PAD_p = WITH WIDTH (AP INTERACT CB2) > AP_W_2
CONNECT AP_PAD_p AP

AP.S.1.1 { @ space of AP pad metal and AP >= ^AP_S_1_1 um
  EXT AP_PAD_p AP < AP_S_1_1 REGION NOT CONNECTED
}

AP.EN.1 { @ Enclosure of RV >= 0.5 
  ENC RV_NIND AP < AP_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  ENC RV_IND AP < AP_EN_1-2*GRID ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}

#IFDEF FULL_CHIP

AP.DN.1 { @ AP density across full chip >= ^AP_DN_1
  DENSITY APi CHIP < AP_DN_1 INSIDE OF LAYER CHIP_AP PRINT AP.DN.1.density
   [AREA(APi)/AREA(CHIP)]   
}
AP.DN.1.1 { @ AP density across full chip <= ^AP_DN_1_1
  DENSITY APi CHIP > AP_DN_1_1 INSIDE OF LAYER CHIPx PRINT AP.DN.1.1.density
   [AREA(APi)/AREA(CHIP)]   
}
#ENDIF



// 'AP.S.6' is not necessary to check
// 'AP.S.7' is not necessary to check
// 'AP.S.8' is not necessary to check



#IFDEF HALF_NODE
VARIABLE m1_thickness 0.125 // user value
#ELSE
VARIABLE m1_thickness 0.13 // user value
#ENDIF
#IFDEF HALF_NODE
VARIABLE m2_thickness 0.145 // user value
#ELSE
VARIABLE m2_thickness 0.14 // user value
#ENDIF
#IFDEF HALF_NODE
VARIABLE m3_thickness 0.145 // user value
#ELSE
VARIABLE m3_thickness 0.14 // user value
#ENDIF
#IFDEF HALF_NODE
VARIABLE m4_thickness 0.145 // user value
#ELSE
VARIABLE m4_thickness 0.14 // user value
#ENDIF
#IFDEF HALF_NODE
VARIABLE m5_thickness 0.145 // user value
#ELSE
VARIABLE m5_thickness 0.14 // user value
#ENDIF
#IFDEF HALF_NODE
VARIABLE m6_thickness 0.85 // user value
#ELSE
VARIABLE m6_thickness 0.9 // user value
#ENDIF
#IFDEF AP_36K_THICKNESS 
VARIABLE ap_thickness 3.6 // user value
#ELSE
#IFDEF AP_28K_THICKNESS
VARIABLE ap_thickness 2.8 // user value
#ELSE
#IFDEF AP_20K_THICKNESS
VARIABLE ap_thickness 2.0 // user value
#ELSE
VARIABLE ap_thickness 1.45 // user value
#ENDIF
#ENDIF
#ENDIF

// MOM CHECKS
//===========
CHIP_MOM = COPY CHIPx

MOM_M1 = MOMDMY_1 AND M1
MOM_M1_EDGE = M1 COIN INSIDE EDGE MOM_M1

MOM_M1_LINE_END = CONVEX EDGE MOM_M1_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M1_SIDE_EDGE = MOM_M1_EDGE NOT COIN INSIDE EDGE MOM_M1_LINE_END
MOM_M1_SIDE_EDGE_FULL = M1i TOUCH INSIDE EDGE MOM_M1_SIDE_EDGE

MOM_M1_SPACE_pre = EXPAND EDGE (MOMDMY_1 NOT TOUCH OUTSIDE EDGE M1) OUTSIDE BY GRID CORNER FILL
MOM_M1_SPACE = (MOMDMY_1 OR MOM_M1_SPACE_pre) NOT M1
MOM_M1_SPACE_90_90 = CONVEX EDGE MOM_M1_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M1_SPACE_90_90_1 = CONVEX EDGE MOM_M1_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M1_SPACE_90_90_2 = CONVEX EDGE MOM_M1_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M1_METAL_EDGE_pre = MOM_M1_SIDE_EDGE COIN INSIDE EDGE (MOM_M1_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M1_SIDE_EDGE_FULL] MOM_M1_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M1_METAL_EDGE = LAST_M1_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M1_SPACE_90_90_1 OR EDGE MOM_M1_SPACE_90_90_2) INSIDE BY GRID))
MOM_M1_SPACE_90_90_3 = MOM_M1_SPACE_90_90 NOT COIN EDGE MOM_M1_SPACE_90_90_1
MOM_M1_SPACE_90_270 = CONVEX EDGE MOM_M1_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M1_METAL = MOM_M1_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M1_SPACE_90_90_3 OR EDGE MOM_M1_SPACE_90_270) INSIDE BY GRID))
MOM_M1_CAP_EDGE = MOM_M1_METAL NOT COIN EDGE LAST_M1_METAL_EDGE



MOM_M2 = MOMDMY_2 AND M2
MOM_M2_EDGE = M2 COIN INSIDE EDGE MOM_M2

MOM_M2_LINE_END = CONVEX EDGE MOM_M2_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M2_SIDE_EDGE = MOM_M2_EDGE NOT COIN INSIDE EDGE MOM_M2_LINE_END
MOM_M2_SIDE_EDGE_FULL = M2i TOUCH INSIDE EDGE MOM_M2_SIDE_EDGE

MOM_M2_SPACE_pre = EXPAND EDGE (MOMDMY_2 NOT TOUCH OUTSIDE EDGE M2) OUTSIDE BY GRID CORNER FILL
MOM_M2_SPACE = (MOMDMY_2 OR MOM_M2_SPACE_pre) NOT M2
MOM_M2_SPACE_90_90 = CONVEX EDGE MOM_M2_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M2_SPACE_90_90_1 = CONVEX EDGE MOM_M2_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M2_SPACE_90_90_2 = CONVEX EDGE MOM_M2_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M2_METAL_EDGE_pre = MOM_M2_SIDE_EDGE COIN INSIDE EDGE (MOM_M2_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M2_SIDE_EDGE_FULL] MOM_M2_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M2_METAL_EDGE = LAST_M2_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M2_SPACE_90_90_1 OR EDGE MOM_M2_SPACE_90_90_2) INSIDE BY GRID))
MOM_M2_SPACE_90_90_3 = MOM_M2_SPACE_90_90 NOT COIN EDGE MOM_M2_SPACE_90_90_1
MOM_M2_SPACE_90_270 = CONVEX EDGE MOM_M2_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M2_METAL = MOM_M2_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M2_SPACE_90_90_3 OR EDGE MOM_M2_SPACE_90_270) INSIDE BY GRID))
MOM_M2_CAP_EDGE = MOM_M2_METAL NOT COIN EDGE LAST_M2_METAL_EDGE



MOM_M3 = MOMDMY_3 AND M3
MOM_M3_EDGE = M3 COIN INSIDE EDGE MOM_M3

MOM_M3_LINE_END = CONVEX EDGE MOM_M3_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M3_SIDE_EDGE = MOM_M3_EDGE NOT COIN INSIDE EDGE MOM_M3_LINE_END
MOM_M3_SIDE_EDGE_FULL = M3i TOUCH INSIDE EDGE MOM_M3_SIDE_EDGE

MOM_M3_SPACE_pre = EXPAND EDGE (MOMDMY_3 NOT TOUCH OUTSIDE EDGE M3) OUTSIDE BY GRID CORNER FILL
MOM_M3_SPACE = (MOMDMY_3 OR MOM_M3_SPACE_pre) NOT M3
MOM_M3_SPACE_90_90 = CONVEX EDGE MOM_M3_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M3_SPACE_90_90_1 = CONVEX EDGE MOM_M3_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M3_SPACE_90_90_2 = CONVEX EDGE MOM_M3_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M3_METAL_EDGE_pre = MOM_M3_SIDE_EDGE COIN INSIDE EDGE (MOM_M3_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M3_SIDE_EDGE_FULL] MOM_M3_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M3_METAL_EDGE = LAST_M3_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M3_SPACE_90_90_1 OR EDGE MOM_M3_SPACE_90_90_2) INSIDE BY GRID))
MOM_M3_SPACE_90_90_3 = MOM_M3_SPACE_90_90 NOT COIN EDGE MOM_M3_SPACE_90_90_1
MOM_M3_SPACE_90_270 = CONVEX EDGE MOM_M3_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M3_METAL = MOM_M3_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M3_SPACE_90_90_3 OR EDGE MOM_M3_SPACE_90_270) INSIDE BY GRID))
MOM_M3_CAP_EDGE = MOM_M3_METAL NOT COIN EDGE LAST_M3_METAL_EDGE



MOM_M4 = MOMDMY_4 AND M4
MOM_M4_EDGE = M4 COIN INSIDE EDGE MOM_M4

MOM_M4_LINE_END = CONVEX EDGE MOM_M4_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M4_SIDE_EDGE = MOM_M4_EDGE NOT COIN INSIDE EDGE MOM_M4_LINE_END
MOM_M4_SIDE_EDGE_FULL = M4i TOUCH INSIDE EDGE MOM_M4_SIDE_EDGE

MOM_M4_SPACE_pre = EXPAND EDGE (MOMDMY_4 NOT TOUCH OUTSIDE EDGE M4) OUTSIDE BY GRID CORNER FILL
MOM_M4_SPACE = (MOMDMY_4 OR MOM_M4_SPACE_pre) NOT M4
MOM_M4_SPACE_90_90 = CONVEX EDGE MOM_M4_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M4_SPACE_90_90_1 = CONVEX EDGE MOM_M4_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M4_SPACE_90_90_2 = CONVEX EDGE MOM_M4_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M4_METAL_EDGE_pre = MOM_M4_SIDE_EDGE COIN INSIDE EDGE (MOM_M4_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M4_SIDE_EDGE_FULL] MOM_M4_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M4_METAL_EDGE = LAST_M4_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M4_SPACE_90_90_1 OR EDGE MOM_M4_SPACE_90_90_2) INSIDE BY GRID))
MOM_M4_SPACE_90_90_3 = MOM_M4_SPACE_90_90 NOT COIN EDGE MOM_M4_SPACE_90_90_1
MOM_M4_SPACE_90_270 = CONVEX EDGE MOM_M4_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M4_METAL = MOM_M4_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M4_SPACE_90_90_3 OR EDGE MOM_M4_SPACE_90_270) INSIDE BY GRID))
MOM_M4_CAP_EDGE = MOM_M4_METAL NOT COIN EDGE LAST_M4_METAL_EDGE



MOM_M5 = MOMDMY_5 AND M5
MOM_M5_EDGE = M5 COIN INSIDE EDGE MOM_M5

MOM_M5_LINE_END = CONVEX EDGE MOM_M5_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M5_SIDE_EDGE = MOM_M5_EDGE NOT COIN INSIDE EDGE MOM_M5_LINE_END
MOM_M5_SIDE_EDGE_FULL = M5i TOUCH INSIDE EDGE MOM_M5_SIDE_EDGE

MOM_M5_SPACE_pre = EXPAND EDGE (MOMDMY_5 NOT TOUCH OUTSIDE EDGE M5) OUTSIDE BY GRID CORNER FILL
MOM_M5_SPACE = (MOMDMY_5 OR MOM_M5_SPACE_pre) NOT M5
MOM_M5_SPACE_90_90 = CONVEX EDGE MOM_M5_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M5_SPACE_90_90_1 = CONVEX EDGE MOM_M5_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M5_SPACE_90_90_2 = CONVEX EDGE MOM_M5_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M5_METAL_EDGE_pre = MOM_M5_SIDE_EDGE COIN INSIDE EDGE (MOM_M5_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M5_SIDE_EDGE_FULL] MOM_M5_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M5_METAL_EDGE = LAST_M5_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M5_SPACE_90_90_1 OR EDGE MOM_M5_SPACE_90_90_2) INSIDE BY GRID))
MOM_M5_SPACE_90_90_3 = MOM_M5_SPACE_90_90 NOT COIN EDGE MOM_M5_SPACE_90_90_1
MOM_M5_SPACE_90_270 = CONVEX EDGE MOM_M5_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M5_METAL = MOM_M5_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M5_SPACE_90_90_3 OR EDGE MOM_M5_SPACE_90_270) INSIDE BY GRID))
MOM_M5_CAP_EDGE = MOM_M5_METAL NOT COIN EDGE LAST_M5_METAL_EDGE



MOM_M6 = MOMDMY_6 AND M6
MOM_M6_EDGE = M6 COIN INSIDE EDGE MOM_M6

MOM_M6_LINE_END = CONVEX EDGE MOM_M6_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M6_SIDE_EDGE = MOM_M6_EDGE NOT COIN INSIDE EDGE MOM_M6_LINE_END
MOM_M6_SIDE_EDGE_FULL = M6i TOUCH INSIDE EDGE MOM_M6_SIDE_EDGE

MOM_M6_SPACE_pre = EXPAND EDGE (MOMDMY_6 NOT TOUCH OUTSIDE EDGE M6) OUTSIDE BY GRID CORNER FILL
MOM_M6_SPACE = (MOMDMY_6 OR MOM_M6_SPACE_pre) NOT M6
MOM_M6_SPACE_90_90 = CONVEX EDGE MOM_M6_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_M6_SPACE_90_90_1 = CONVEX EDGE MOM_M6_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_M6_SPACE_90_90_2 = CONVEX EDGE MOM_M6_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_M6_METAL_EDGE_pre = MOM_M6_SIDE_EDGE COIN INSIDE EDGE (MOM_M6_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_M6_SIDE_EDGE_FULL] MOM_M6_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_M6_METAL_EDGE = LAST_M6_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M6_SPACE_90_90_1 OR EDGE MOM_M6_SPACE_90_90_2) INSIDE BY GRID))
MOM_M6_SPACE_90_90_3 = MOM_M6_SPACE_90_90 NOT COIN EDGE MOM_M6_SPACE_90_90_1
MOM_M6_SPACE_90_270 = CONVEX EDGE MOM_M6_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_M6_METAL = MOM_M6_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_M6_SPACE_90_90_3 OR EDGE MOM_M6_SPACE_90_270) INSIDE BY GRID))
MOM_M6_CAP_EDGE = MOM_M6_METAL NOT COIN EDGE LAST_M6_METAL_EDGE



MOM_AP = MOMDMY_AP AND AP
MOM_AP_EDGE = AP COIN INSIDE EDGE MOM_AP
MOM_AP_LINE_END = CONVEX EDGE MOM_AP_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_AP_SIDE_EDGE = MOM_AP_EDGE NOT COIN INSIDE EDGE MOM_AP_LINE_END
MOM_AP_SIDE_EDGE_FULL = APi TOUCH INSIDE EDGE MOM_AP_SIDE_EDGE

MOM_AP_SPACE_pre = EXPAND EDGE (MOMDMY_AP NOT TOUCH OUTSIDE EDGE AP) OUTSIDE BY GRID CORNER FILL
MOM_AP_SPACE = (MOMDMY_AP OR MOM_AP_SPACE_pre) NOT AP
MOM_AP_SPACE_90_90 = CONVEX EDGE MOM_AP_SPACE ANGLE1 == 90 ANGLE2 == 90
MOM_AP_SPACE_90_90_1 = CONVEX EDGE MOM_AP_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 90
MOM_AP_SPACE_90_90_2 = CONVEX EDGE MOM_AP_SPACE_90_90 ANGLE1 == 90 ANGLE2 == 0
LAST_AP_METAL_EDGE_pre = MOM_AP_SIDE_EDGE COIN INSIDE EDGE (MOM_AP_SIDE_EDGE_FULL TOUCH INSIDE EDGE (ENC [MOM_AP_SIDE_EDGE_FULL] MOM_AP_SPACE_90_90_2 < GRID ABUT == 90 INTERSECTING ONLY))
LAST_AP_METAL_EDGE = LAST_AP_METAL_EDGE_pre INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_AP_SPACE_90_90_1 OR EDGE MOM_AP_SPACE_90_90_2) INSIDE BY GRID))
MOM_AP_SPACE_90_90_3 = MOM_AP_SPACE_90_90 NOT COIN EDGE MOM_AP_SPACE_90_90_1
MOM_AP_SPACE_90_270 = CONVEX EDGE MOM_AP_SPACE ANGLE1 == 90 ANGLE2 == 270
MOM_AP_METAL = MOM_AP_SIDE_EDGE INSIDE EDGE (EXTENTS (EXPAND EDGE (MOM_AP_SPACE_90_90_3 OR EDGE MOM_AP_SPACE_90_270) INSIDE BY GRID))
MOM_AP_CAP_EDGE = MOM_AP_METAL NOT COIN EDGE LAST_AP_METAL_EDGE

// MOM.S.2 is checked by MOM.S.2:M1
MOM.S.2:M1 { @ Space of metal (M1/Mx) line-end in MOMDMY_n >= 0.1 
  EXT MOM_M1_LINE_END M1 < MOM_S_2 ABUT < 90 REGION
}

// MOM.S.2 is checked by MOM.S.2:M2
MOM.S.2:M2 { @ Space of metal (M1/Mx) line-end in MOMDMY_n >= 0.1 
  EXT MOM_M2_LINE_END M2 < MOM_S_2 ABUT < 90 REGION
}

// MOM.S.2 is checked by MOM.S.2:M3
MOM.S.2:M3 { @ Space of metal (M1/Mx) line-end in MOMDMY_n >= 0.1 
  EXT MOM_M3_LINE_END M3 < MOM_S_2 ABUT < 90 REGION
}

// MOM.S.2 is checked by MOM.S.2:M4
MOM.S.2:M4 { @ Space of metal (M1/Mx) line-end in MOMDMY_n >= 0.1 
  EXT MOM_M4_LINE_END M4 < MOM_S_2 ABUT < 90 REGION
}

// MOM.S.2 is checked by MOM.S.2:M5
MOM.S.2:M5 { @ Space of metal (M1/Mx) line-end in MOMDMY_n >= 0.1 
  EXT MOM_M5_LINE_END M5 < MOM_S_2 ABUT < 90 REGION
}




MOM.A.1 { @ Maximum sidewall area of total metals in MOM without Via <= ^MOM_A_1
     MOM_SA = DFM PROPERTY CHIP_MOM  MOM_M1_CAP_EDGE  MOM_M2_CAP_EDGE  MOM_M3_CAP_EDGE  MOM_M4_CAP_EDGE  MOM_M5_CAP_EDGE  MOM_M6_CAP_EDGE  MOM_AP_CAP_EDGE OVERLAP
   [
 	Sidewall_Area = (  LENGTH(MOM_M1_CAP_EDGE)*m1_thickness+  LENGTH(MOM_M2_CAP_EDGE)*m2_thickness+  LENGTH(MOM_M3_CAP_EDGE)*m3_thickness+  LENGTH(MOM_M4_CAP_EDGE)*m4_thickness+  LENGTH(MOM_M5_CAP_EDGE)*m5_thickness+  LENGTH(MOM_M6_CAP_EDGE)*m6_thickness+ LENGTH(MOM_AP_CAP_EDGE)*ap_thickness)/2 
  ] > MOM_A_1
  MERGE MOM_SA
  DFM RDB MOM_SA MOM.A.1.rep NOEMPTY NOPSEUDO
}

MOM.R.1 { @ VIA in MOMDMY is not allowed   
  MOMDMY_1 AND VIA1
  MOMDMY_2 AND VIA1
  MOMDMY_2 AND VIA2
  MOMDMY_3 AND VIA2
  MOMDMY_3 AND VIA3
  MOMDMY_4 AND VIA3
  MOMDMY_4 AND VIA4
  MOMDMY_5 AND VIA4
  MOMDMY_5 AND VIA5
  MOMDMY_6 AND VIA5
  MOMDMY_6 AND RV
  MOMDMY_AP AND RV
}

#IFDEF FULL_CHIP
MOM.R.2 { @ Each MOM cell must be covered by MOMDMY_n (n=155;0~10/20/21/100). DRC only flags no MOMDMY_n(n=155;0~10/20/21/100) in the chip. But if there is no MOM cell in the chip, the violation can be waived.
  MOMDMY_LAYERS = ((((((((MOMDMY_1 OR MOMDMY_2) OR MOMDMY_3) OR MOMDMY_4) OR MOMDMY_5) OR MOMDMY_6) OR MOMDMY_AP) OR MOMDMY) OR MOMDMY_0) OR MOMDMY_100
  CHIPx NOT INTERACT MOMDMY_LAYERS
}
#ENDIF

MOM.R.6 { @ Poly shielding and underneath NW or PW must bias at same potential for reliability consideration. If poly shielding terminal could not be tied to the underneath NW or PW, customer should keep bias between poly terminal and underneath well within thin gate oxide (Without OD2) or thick gate oxide (With OD2) maximum applied voltage for reliability consideration. 

@ DRC only check following conditions: 
@ (1) {(MOM_PO INTERACT (MOM_OD NOT INSIDE OD2)) INTERACT ((MOMDMY(155;100) OR MOMDMY(155;0)) NOT (MOMDMY(155;27) OR MOMDMY(155;28) OR MOMDMY(155;31) OR MOMDMY(155;32) OR MOMDMY(155;33))} [Poly shielding MOM with dummy OD underneath] and underneath NW or PW must bias at same potential (Connection is based on Disconnect Resistor
MOM_OD = OD OR DOD
PO_MOMi = (SRDPOi INTERACT (MOM_OD NOT INSIDE OD2)) INTERACT ((MOMDMY_0 OR MOMDMY_100) NOT ((((MOMDMY_2T OR MOMDMY28) OR MOMDMY31) OR MOMDMY32) OR MOMDMY33))
NW_NOT_POi = NWi NOT PO_MOMi
PW_NOT_POi = PWELi NOT PO_MOMi
EXT PO_MOMi NW_NOT_POi < 0.001 ABUT == 0 NOT CONNECTED REGION
EXT PO_MOMi PW_NOT_POi < 0.001 ABUT == 0 NOT CONNECTED REGION
}






//DM1 CHECKS
//===========

DM1.W.1 { @ Width >= ^DM1_W_1 um
  INT DUM1 < DM1_W_1 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM1 BY DM1_W_2 /2 UNDEROVER
}
DM1.S.1 { @ Space >= ^DM1_S_1 um
  EXT DUM1 < DM1_S_1 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM1_S_2a/^DM1_S_2b um
  DUM1a = DUM1 WITH WIDTH <= 1
  DUM1b = DUM1 WITH WIDTH >  1	
  EXT M1i DUM1a < DM1_S_2a ABUT < 90 SINGULAR REGION
  EXT M1i DUM1b < DM1_S_2b ABUT < 90 SINGULAR REGION
  M1i AND DUM1
}
DM1.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M1_Wide = M1Wide_3_0 WITH WIDTH > DM1_S_3_W
  X = EXT M1_Wide DUM1 < DM1_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM1_S_2a DM1_S_3_L+GRID
}




// DM1.EN.2 is not necessary to check

DM1.A.1 { @ Min. area >= ^DM1_A_1 um2
  AREA DUM1 < DM1_A_1 
}
DM1.A.2 { @ Max. area <= ^DM1_A_2 um2
  AREA DUM1 > DM1_A_2 
}

#IFDEF FULL_CHIP
DM1.R.1 { @ DM1 is a must. The DM1 CAD layer must be different from the M1 CAD layer.
  MERGE (CHIP NOT INTERACT DUM1)
}
#ENDIF

// DM1.R.2 is checked by CSR.R.1:DUM1

DM1.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM1
}

// DMx_O.R.1 is checked by DM1_O.R.1
DM1_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM1_O INTERACT M1i_R
}    

// DM1.R.4.R is not necessary to check

//DM2 CHECKS
//===========

DM2.W.1 { @ Width >= ^DM2_W_1 um
  INT DUM2 < DM2_W_1 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM2 BY DM2_W_2 /2 UNDEROVER
}
DM2.S.1 { @ Space >= ^DM2_S_1 um
  EXT DUM2 < DM2_S_1 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM2_S_2a/^DM2_S_2b um
  DUM2a = DUM2 WITH WIDTH <= 1
  DUM2b = DUM2 WITH WIDTH >  1	
  EXT M2i DUM2a < DM2_S_2a ABUT < 90 SINGULAR REGION
  EXT M2i DUM2b < DM2_S_2b ABUT < 90 SINGULAR REGION
  M2i AND DUM2
}
DM2.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M2_Wide = M2Wide_3_0 WITH WIDTH > DM2_S_3_W
  X = EXT M2_Wide DUM2 < DM2_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM2_S_2a DM2_S_3_L+GRID
}




DM2.EN.2 { @ Enclosure of DVIAx-1 >= 0.01 
   ENC DVIA1 DUM2 < DM2_EN_2 ABUT < 90 SINGULAR REGION
}

DM2.A.1 { @ Min. area >= ^DM2_A_1 um2
  AREA DUM2 < DM2_A_1 
}
DM2.A.2 { @ Max. area <= ^DM2_A_2 um2
  AREA DUM2 > DM2_A_2 
}

#IFDEF FULL_CHIP
DM2.R.1 { @ DM2 is a must. The DM2 CAD layer must be different from the M2 CAD layer.
  MERGE (CHIP NOT INTERACT DUM2)
}
#ENDIF

// DM2.R.2 is checked by CSR.R.1:DUM2

DM2.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM2
}

// DMx_O.R.1 is checked by DM2_O.R.1
DM2_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM2_O INTERACT M2i_R
}    

// DM2.R.4.R is not necessary to check

//DM3 CHECKS
//===========

DM3.W.1 { @ Width >= ^DM3_W_1 um
  INT DUM3 < DM3_W_1 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM3 BY DM3_W_2 /2 UNDEROVER
}
DM3.S.1 { @ Space >= ^DM3_S_1 um
  EXT DUM3 < DM3_S_1 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM3_S_2a/^DM3_S_2b um
  DUM3a = DUM3 WITH WIDTH <= 1
  DUM3b = DUM3 WITH WIDTH >  1	
  EXT M3i DUM3a < DM3_S_2a ABUT < 90 SINGULAR REGION
  EXT M3i DUM3b < DM3_S_2b ABUT < 90 SINGULAR REGION
  M3i AND DUM3
}
DM3.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M3_Wide = M3Wide_3_0 WITH WIDTH > DM3_S_3_W
  X = EXT M3_Wide DUM3 < DM3_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM3_S_2a DM3_S_3_L+GRID
}




DM3.EN.2 { @ Enclosure of DVIAx-1 >= 0.01 
   ENC DVIA2 DUM3 < DM3_EN_2 ABUT < 90 SINGULAR REGION
}

DM3.A.1 { @ Min. area >= ^DM3_A_1 um2
  AREA DUM3 < DM3_A_1 
}
DM3.A.2 { @ Max. area <= ^DM3_A_2 um2
  AREA DUM3 > DM3_A_2 
}

#IFDEF FULL_CHIP
DM3.R.1 { @ DM3 is a must. The DM3 CAD layer must be different from the M3 CAD layer.
  MERGE (CHIP NOT INTERACT DUM3)
}
#ENDIF

// DM3.R.2 is checked by CSR.R.1:DUM3

DM3.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM3
}

// DMx_O.R.1 is checked by DM3_O.R.1
DM3_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM3_O INTERACT M3i_R
}    

// DM3.R.4.R is not necessary to check

//DM4 CHECKS
//===========

DM4.W.1 { @ Width >= ^DM4_W_1 um
  INT DUM4 < DM4_W_1 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM4 BY DM4_W_2 /2 UNDEROVER
}
DM4.S.1 { @ Space >= ^DM4_S_1 um
  EXT DUM4 < DM4_S_1 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM4_S_2a/^DM4_S_2b um
  DUM4a = DUM4 WITH WIDTH <= 1
  DUM4b = DUM4 WITH WIDTH >  1	
  EXT M4i DUM4a < DM4_S_2a ABUT < 90 SINGULAR REGION
  EXT M4i DUM4b < DM4_S_2b ABUT < 90 SINGULAR REGION
  M4i AND DUM4
}
DM4.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M4_Wide = M4Wide_3_0 WITH WIDTH > DM4_S_3_W
  X = EXT M4_Wide DUM4 < DM4_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM4_S_2a DM4_S_3_L+GRID
}




DM4.EN.2 { @ Enclosure of DVIAx-1 >= 0.01 
   ENC DVIA3 DUM4 < DM4_EN_2 ABUT < 90 SINGULAR REGION
}

DM4.A.1 { @ Min. area >= ^DM4_A_1 um2
  AREA DUM4 < DM4_A_1 
}
DM4.A.2 { @ Max. area <= ^DM4_A_2 um2
  AREA DUM4 > DM4_A_2 
}

#IFDEF FULL_CHIP
DM4.R.1 { @ DM4 is a must. The DM4 CAD layer must be different from the M4 CAD layer.
  MERGE (CHIP NOT INTERACT DUM4)
}
#ENDIF

// DM4.R.2 is checked by CSR.R.1:DUM4

DM4.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM4
}

// DMx_O.R.1 is checked by DM4_O.R.1
DM4_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM4_O INTERACT M4i_R
}    

// DM4.R.4.R is not necessary to check

//DM5 CHECKS
//===========

DM5.W.1 { @ Width >= ^DM5_W_1 um
  INT DUM5 < DM5_W_1 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM5 BY DM5_W_2 /2 UNDEROVER
}
DM5.S.1 { @ Space >= ^DM5_S_1 um
  EXT DUM5 < DM5_S_1 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM5_S_2a/^DM5_S_2b um
  DUM5a = DUM5 WITH WIDTH <= 1
  DUM5b = DUM5 WITH WIDTH >  1	
  EXT M5i DUM5a < DM5_S_2a ABUT < 90 SINGULAR REGION
  EXT M5i DUM5b < DM5_S_2b ABUT < 90 SINGULAR REGION
  M5i AND DUM5
}
DM5.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M5_Wide = M5Wide_3_0 WITH WIDTH > DM5_S_3_W
  X = EXT M5_Wide DUM5 < DM5_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM5_S_2a DM5_S_3_L+GRID
}




DM5.EN.2 { @ Enclosure of DVIAx-1 >= 0.01 
   ENC DVIA4 DUM5 < DM5_EN_2 ABUT < 90 SINGULAR REGION
}

DM5.A.1 { @ Min. area >= ^DM5_A_1 um2
  AREA DUM5 < DM5_A_1 
}
DM5.A.2 { @ Max. area <= ^DM5_A_2 um2
  AREA DUM5 > DM5_A_2 
}

#IFDEF FULL_CHIP
DM5.R.1 { @ DM5 is a must. The DM5 CAD layer must be different from the M5 CAD layer.
  MERGE (CHIP NOT INTERACT DUM5)
}
#ENDIF

// DM5.R.2 is checked by CSR.R.1:DUM5

DM5.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM5
}

// DMx_O.R.1 is checked by DM5_O.R.1
DM5_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM5_O INTERACT M5i_R
}    

// DM5.R.4.R is not necessary to check

//DM6 CHECKS
//===========

DM6.W.1 { @ Width >= ^DM6_W_1 um
  INT DUM6 < DM6_W_1 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3 
  SIZE DUM6 BY DM6_W_2 /2 UNDEROVER
}
DM6.S.1 { @ Space >= ^DM6_S_1 um
  EXT DUM6 < DM6_S_1 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM6_S_2 um
  EXT M6i DUM6 < DM6_S_2 ABUT < 90 SINGULAR REGION
  M6i AND DUM6
}
DM6.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M6_Wide = M6Wide_1.5 WITH WIDTH > DM6_S_3_W
  X = EXT M6_Wide DUM6 < DM6_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM6_S_2 DM6_S_3_L+GRID
}



// DM6.EN.2 is not necessary to check

DM6.A.1 { @ Min. area >= ^DM6_A_1 um2
  AREA DUM6 < DM6_A_1 
}
DM6.A.2 { @ Max. area <= ^DM6_A_2 um2
  AREA DUM6 > DM6_A_2 
}

#IFDEF FULL_CHIP
DM6.R.1 { @ DM6 is a must. The DM6 CAD layer must be different from the M6 CAD layer.
  MERGE (CHIP NOT INTERACT DUM6)
}
#ENDIF

// DM6.R.2 is checked by CSR.R.1:DUM6_OLD
// DM6.R.2 is checked by CSR.R.1:DUM6_NEW

DM6.R.3 { @ DMx must be rectangular
  NOT RECTANGLE DUM6
}


// DM6.R.4.R is not necessary to check


//DVIA1 CHECK
//=============

DVIA1.W.1 { @  Width (maximum = minimum) = 0.12
  NOT RECTANGLE DVIA1 == DVIA1_W_1 BY == DVIA1_W_1 ORTHOGONAL ONLY
}
DVIA1.S.1 { @ Space >= 0.20
  EXT DVIA1 < DVIA1_S_1 ABUT<90 SINGULAR REGION
}
DVIA1.S.2 { @ Space to VIAx >= 0.20
  EXT DVIA1 VIA1 < DVIA1_S_2 ABUT<90 SINGULAR REGION
}
DVIA1.EN.1 { @ Enclosure by DMx >= 0.01
  ENC DVIA1 DUM1 < DVIA1_EN_1 ABUT<90 SINGULAR REGION
}
DVIA1.R.1 { @ DVIAx must be fully inside DMx and DMx+1.
  DVIA1 NOT DUM1
  DVIA1 NOT DUM2
}
DVIA1.R.2 { @ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed
  DVIA1 INTERACT M1
  DVIA1 INTERACT M2
}

#IFDEF FULL_CHIP
#IFDEF DVIAxR3_For_NonFlipChip
DVIAxR3_CHECK = COPY CHIPx
#ELSE
#IFDEF SINGLE_PASSIVATION
DVIAxR3_CHECK = COPY CHIPx
#ELSE
#IFDEF WLCSP
DVIAxR3_CHECK = COPY CHIPx
#ELSE
#IFDEF WIRE_BOND
DVIAxR3_CHECK = COPY EMPTYi
#ELSE
DVIAxR3_CHECK = COPY CHIPx
#ENDIF
#ENDIF
#ENDIF
#ENDIF
DVIA1.R.3 { @ DVIA1 is a must for Flip Chip.
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA1 to DM1) and (DVIA1 to DM2) are < 1% at the same time
  A = DENSITY DVIA1 DUM1 < DVIA1_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA1DM1.R.3.density
    	[AREA(DVIA1)/AREA(DUM1)]
  B = DENSITY DVIA1 DUM2 < DVIA1_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA1DM2.R.3.density
    	[AREA(DVIA1)/AREA(DUM2)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA2 CHECK
//=============

DVIA2.W.1 { @  Width (maximum = minimum) = 0.12
  NOT RECTANGLE DVIA2 == DVIA2_W_1 BY == DVIA2_W_1 ORTHOGONAL ONLY
}
DVIA2.S.1 { @ Space >= 0.20
  EXT DVIA2 < DVIA2_S_1 ABUT<90 SINGULAR REGION
}
DVIA2.S.2 { @ Space to VIAx >= 0.20
  EXT DVIA2 VIA2 < DVIA2_S_2 ABUT<90 SINGULAR REGION
}
DVIA2.EN.1 { @ Enclosure by DMx >= 0.01
  ENC DVIA2 DUM2 < DVIA2_EN_1 ABUT<90 SINGULAR REGION
}
DVIA2.R.1 { @ DVIAx must be fully inside DMx and DMx+1.
  DVIA2 NOT DUM2
  DVIA2 NOT DUM3
}
DVIA2.R.2 { @ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed
  DVIA2 INTERACT M2
  DVIA2 INTERACT M3
}

#IFDEF FULL_CHIP
DVIA2.R.3 { @ DVIA2 is a must for Flip Chip.
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA2 to DM2) and (DVIA2 to DM3) are < 1% at the same time
  A = DENSITY DVIA2 DUM2 < DVIA2_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA2DM2.R.3.density
    	[AREA(DVIA2)/AREA(DUM2)]
  B = DENSITY DVIA2 DUM3 < DVIA2_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA2DM3.R.3.density
    	[AREA(DVIA2)/AREA(DUM3)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA3 CHECK
//=============

DVIA3.W.1 { @  Width (maximum = minimum) = 0.12
  NOT RECTANGLE DVIA3 == DVIA3_W_1 BY == DVIA3_W_1 ORTHOGONAL ONLY
}
DVIA3.S.1 { @ Space >= 0.20
  EXT DVIA3 < DVIA3_S_1 ABUT<90 SINGULAR REGION
}
DVIA3.S.2 { @ Space to VIAx >= 0.20
  EXT DVIA3 VIA3 < DVIA3_S_2 ABUT<90 SINGULAR REGION
}
DVIA3.EN.1 { @ Enclosure by DMx >= 0.01
  ENC DVIA3 DUM3 < DVIA3_EN_1 ABUT<90 SINGULAR REGION
}
DVIA3.R.1 { @ DVIAx must be fully inside DMx and DMx+1.
  DVIA3 NOT DUM3
  DVIA3 NOT DUM4
}
DVIA3.R.2 { @ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed
  DVIA3 INTERACT M3
  DVIA3 INTERACT M4
}

#IFDEF FULL_CHIP
DVIA3.R.3 { @ DVIA3 is a must for Flip Chip.
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA3 to DM3) and (DVIA3 to DM4) are < 1% at the same time
  A = DENSITY DVIA3 DUM3 < DVIA3_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA3DM3.R.3.density
    	[AREA(DVIA3)/AREA(DUM3)]
  B = DENSITY DVIA3 DUM4 < DVIA3_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA3DM4.R.3.density
    	[AREA(DVIA3)/AREA(DUM4)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA4 CHECK
//=============

DVIA4.W.1 { @  Width (maximum = minimum) = 0.12
  NOT RECTANGLE DVIA4 == DVIA4_W_1 BY == DVIA4_W_1 ORTHOGONAL ONLY
}
DVIA4.S.1 { @ Space >= 0.20
  EXT DVIA4 < DVIA4_S_1 ABUT<90 SINGULAR REGION
}
DVIA4.S.2 { @ Space to VIAx >= 0.20
  EXT DVIA4 VIA4 < DVIA4_S_2 ABUT<90 SINGULAR REGION
}
DVIA4.EN.1 { @ Enclosure by DMx >= 0.01
  ENC DVIA4 DUM4 < DVIA4_EN_1 ABUT<90 SINGULAR REGION
}
DVIA4.R.1 { @ DVIAx must be fully inside DMx and DMx+1.
  DVIA4 NOT DUM4
  DVIA4 NOT DUM5
}
DVIA4.R.2 { @ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed
  DVIA4 INTERACT M4
  DVIA4 INTERACT M5
}

#IFDEF FULL_CHIP
DVIA4.R.3 { @ DVIA4 is a must for Flip Chip.
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA4 to DM4) and (DVIA4 to DM5) are < 1% at the same time
  A = DENSITY DVIA4 DUM4 < DVIA4_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA4DM4.R.3.density
    	[AREA(DVIA4)/AREA(DUM4)]
  B = DENSITY DVIA4 DUM5 < DVIA4_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA4DM5.R.3.density
    	[AREA(DVIA4)/AREA(DUM5)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF



#ENDIF // BACK_END


//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, PO, or Metals (non-dummy patterns, and non-dummy TCD) (This check doesn't include the M1/ Mx protection ring inside {LOWMEDN NOT (LOWMEDN SIZING -4 um)} region, seal-ring region, and CSR region) >= 10 
  LOGO_EXT = (SIZE LOGO BY LOGO_S_1) NOT LOGO
  LOGO_EXT AND ((ODi NOT TCDDMY) NOT SRCSR)
  LOGO_EXT AND ((POi NOT TCDDMY) NOT SRCSR)
  LOGO_EXT AND ((M1i_R NOT P_RING_REGION) NOT SRCSR)
  LOGO_EXT AND ((M2i_R NOT P_RING_REGION) NOT SRCSR)
  LOGO_EXT AND ((M3i_R NOT P_RING_REGION) NOT SRCSR)
  LOGO_EXT AND ((M4i_R NOT P_RING_REGION) NOT SRCSR)
  LOGO_EXT AND ((M5i_R NOT P_RING_REGION) NOT SRCSR)
  LOGO_EXT AND (M6i NOT SRCSR)
}
LOGO.O.1 { @ Overlap of CB, CBD, PM, UBM is not allowed   
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND PMi
  LOGO AND UBMi
}

// LOGO.R.1 can not be checked.
// LOGO.R.2 is checked by related rules.




#IFDEF FULL_CHIP

//CSR CHECKS
//===========
#IFNDEF WITH_SEALRING
CSR.R.1:DNWi { @ DNWi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DNWi
}
CSR.R.1:NWi { @ NWi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NWi
}
CSR.R.1:OD12i { @ OD12i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD12i
}
CSR.R.1:OD18i { @ OD18i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD18i
}
CSR.R.1:OD1815 { @ OD1815 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1815
}
CSR.R.1:OD25i { @ OD25i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD25i
}
CSR.R.1:OD2533 { @ OD2533 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD2533
}
CSR.R.1:OD2518 { @ OD2518 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD2518
}
CSR.R.1:OD25_LK { @ OD25_LK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD25_LK
}
CSR.R.1:OD33i { @ OD33i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD33i
}
CSR.R.1:ODDECAP { @ ODDECAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODDECAP
}
CSR.R.1:PPi { @ PPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PPi
}
CSR.R.1:NPi { @ NPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NPi
}
CSR.R.1:HVD_N { @ HVD_N is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HVD_N
}
CSR.R.1:HVD_P { @ HVD_P is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HVD_P
}
CSR.R.1:DEHVD_N { @ DEHVD_N is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DEHVD_N
}
CSR.R.1:COi { @ COi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COi
}
CSR.R.1:COPUSH { @ COPUSH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COPUSH
}
CSR.R.1:COiSRAM { @ COiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COiSRAM
}
CSR.R.1:CBi { @ CBi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBi
}
CSR.R.1:CB2Fi { @ CB2Fi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CB2Fi
}
CSR.R.1:CB2Wi { @ CB2Wi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CB2Wi
}
CSR.R.1:RPOi { @ RPOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RPOi
}
CSR.R.1:NTNi { @ NTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NTNi
}
CSR.R.1:NCapNTNi { @ NCapNTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NCapNTNi
}
CSR.R.1:LPP_NTNi { @ LPP_NTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTNi
}
CSR.R.1:LPP_NTN_21i { @ LPP_NTN_21i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_21i
}
CSR.R.1:LPP_NTN_DPOi { @ LPP_NTN_DPOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_DPOi
}
CSR.R.1:LPP_NTN_120i { @ LPP_NTN_120i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_120i
}
CSR.R.1:POFUSE { @ POFUSE is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POFUSE
}
CSR.R.1:FUSELINK { @ FUSELINK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND FUSELINK
}
CSR.R.1:PMi { @ PMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PMi
}
CSR.R.1:PM1i { @ PM1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PM1i
}
CSR.R.1:PM2i { @ PM2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PM2i
}
CSR.R.1:SEALRING_ORI { @ SEALRING_ORI is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_ORI
}
CSR.R.1:SEALRING_DB { @ SEALRING_DB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_DB
}
CSR.R.1:SEALRING_ALL { @ SEALRING_ALL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_ALL
}
CSR.R.1:VTHNi { @ VTHNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTHNi
}
CSR.R.1:VTHPi { @ VTHPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTHPi
}
CSR.R.1:VTLNi { @ VTLNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLNi
}
CSR.R.1:VTLPi { @ VTLPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLPi
}
CSR.R.1:VTULNi { @ VTULNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTULNi
}
CSR.R.1:VTULPi { @ VTULPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTULPi
}
CSR.R.1:ULVT_Ni { @ ULVT_Ni is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ULVT_Ni
}
CSR.R.1:ULVT_Pi { @ ULVT_Pi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ULVT_Pi
}
CSR.R.1:VTLN18 { @ VTLN18 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLN18
}
CSR.R.1:CBDi { @ CBDi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBDi
}
CSR.R.1:CBDB { @ CBDB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBDB
}
CSR.R.1:UBMi { @ UBMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND UBMi
}
CSR.R.1:UBMB { @ UBMB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND UBMB
}
CSR.R.1:RH { @ RH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RH
}
CSR.R.1:RHDMY1 { @ RHDMY1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RHDMY1
}
CSR.R.1:ESDIMP { @ ESDIMP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ESDIMP
}
CSR.R.1:VARi { @ VARi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VARi
}
CSR.R.1:DVAR { @ DVAR is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVAR
}
CSR.R.1:APi { @ APi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND APi
}
CSR.R.1:Cu_PPIi { @ Cu_PPIi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND Cu_PPIi
}
CSR.R.1:DMY_S_Pad { @ DMY_S_Pad is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DMY_S_Pad
}
CSR.R.1:DMY_U_Pad { @ DMY_U_Pad is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DMY_U_Pad
}
CSR.R.1:AP_BSL { @ AP_BSL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND AP_BSL
}
CSR.R.1:AP_BSP { @ AP_BSP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND AP_BSP
}
CSR.R.1:CBMi { @ CBMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBMi
}
CSR.R.1:CTMi { @ CTMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CTMi
}
CSR.R.1:RVi { @ RVi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RVi
}
CSR.R.1:RV_BSL { @ RV_BSL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RV_BSL
}
CSR.R.1:DCOi { @ DCOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DCOi
}
CSR.R.1:DCO_LPPi { @ DCO_LPPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DCO_LPPi
}
CSR.R.1:DCODMY_SCi { @ DCODMY_SCi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DCODMY_SCi
}
CSR.R.1:LMARK { @ LMARK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LMARK
}
CSR.R.1:SRM { @ SRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRM
}
CSR.R.1:SRMN { @ SRMN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMN
}
CSR.R.1:SRMP { @ SRMP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMP
}
CSR.R.1:SRMRP { @ SRMRP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMRP
}
CSR.R.1:NPreDOSRM { @ NPreDOSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NPreDOSRM
}
CSR.R.1:ROM { @ ROM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ROM
}
CSR.R.1:SRM_HS { @ SRM_HS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRM_HS
}
CSR.R.1:SRAMDMY { @ SRAMDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY
}
CSR.R.1:SRAMDMY_PAS { @ SRAMDMY_PAS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PAS
}
CSR.R.1:SRAMDMY_PERI_LP { @ SRAMDMY_PERI_LP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PERI_LP
}
CSR.R.1:SRAMDMY_PERI_G { @ SRAMDMY_PERI_G is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PERI_G
}
CSR.R.1:CO2 { @ CO2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CO2
}
CSR.R.1:DPSRM { @ DPSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DPSRM
}
CSR.R.1:PRSRM { @ PRSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PRSRM
}
CSR.R.1:SRMLOP12 { @ SRMLOP12 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP12
}
CSR.R.1:SRMLOP13 { @ SRMLOP13 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP13
}
CSR.R.1:SRMLOP14 { @ SRMLOP14 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP14
}
CSR.R.1:LVLOP { @ LVLOP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LVLOP
}
CSR.R.1:HCDPLOP { @ HCDPLOP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HCDPLOP
}
CSR.R.1:TPLOP_8T { @ TPLOP_8T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TPLOP_8T
}
CSR.R.1:TPLOP_10T { @ TPLOP_10T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TPLOP_10T
}
CSR.R.1:RAM1TDMY { @ RAM1TDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RAM1TDMY
}
CSR.R.1:OD1T { @ OD1T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T
}
CSR.R.1:OD1TH { @ OD1TH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1TH
}
CSR.R.1:OD1TM { @ OD1TM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1TM
}
CSR.R.1:OD1T_WLD { @ OD1T_WLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_WLD
}
CSR.R.1:OD1T_MOSCAP { @ OD1T_MOSCAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_MOSCAP
}
CSR.R.1:OD1T_CP { @ OD1T_CP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_CP
}
CSR.R.1:OD1T_20 { @ OD1T_20 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_20
}
CSR.R.1:OD1T_18 { @ OD1T_18 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_18
}
CSR.R.1:OD1T_16 { @ OD1T_16 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_16
}
CSR.R.1:CLDD { @ CLDD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CLDD
}
CSR.R.1:EDRAM_DECAP { @ EDRAM_DECAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND EDRAM_DECAP
}
CSR.R.1:SNCT { @ SNCT is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SNCT
}
CSR.R.1:CROWN { @ CROWN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CROWN
}
CSR.R.1:P3 { @ P3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND P3
}
CSR.R.1:CSRDMY { @ CSRDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRDMY
}
CSR.R.1:CSRBIB1DMY { @ CSRBIB1DMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRBIB1DMY
}
CSR.R.1:CSRBIB2DMY { @ CSRBIB2DMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRBIB2DMY
}
CSR.R.1:CDUDMY { @ CDUDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CDUDMY
}
CSR.R.1:TCDDMY { @ TCDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY
}
CSR.R.1:TCDDMY_H { @ TCDDMY_H is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY_H
}
CSR.R.1:TCDDMY_V { @ TCDDMY_V is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY_V
}
CSR.R.1:ICOVL { @ ICOVL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ICOVL
}
CSR.R.1:LOGO { @ LOGO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LOGO
}
CSR.R.1:INDDMY { @ INDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND INDDMY
}
CSR.R.1:INDDMY_MD { @ INDDMY_MD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND INDDMY_MD
}
CSR.R.1:INDDMY_HD { @ INDDMY_HD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND INDDMY_HD
}
CSR.R.1:TLDMY { @ TLDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TLDMY
}
CSR.R.1:WBDMY { @ WBDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND WBDMY
}
CSR.R.1:DIODMYi { @ DIODMYi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DIODMYi
}
CSR.R.1:DIO3TDMYi { @ DIO3TDMYi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DIO3TDMYi
}
CSR.R.1:RFDMY { @ RFDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RFDMY
}
CSR.R.1:RFIPDMY { @ RFIPDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RFIPDMY
}
CSR.R.1:LUPWDMY { @ LUPWDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LUPWDMY
}
CSR.R.1:LUPWDMY_2 { @ LUPWDMY_2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LUPWDMY_2
}
CSR.R.1:M1i { @ M1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M1i
}
CSR.R.1:DM1_O { @ DM1_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM1_O
}
CSR.R.1:DUM1 { @ DUM1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM1
}
CSR.R.1:M2i { @ M2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M2i
}
CSR.R.1:DM2_O { @ DM2_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM2_O
}
CSR.R.1:DUM2 { @ DUM2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM2
}
CSR.R.1:M3i { @ M3i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M3i
}
CSR.R.1:DM3_O { @ DM3_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM3_O
}
CSR.R.1:DUM3 { @ DUM3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM3
}
CSR.R.1:M4i { @ M4i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M4i
}
CSR.R.1:DM4_O { @ DM4_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM4_O
}
CSR.R.1:DUM4 { @ DUM4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM4
}
CSR.R.1:M5i { @ M5i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M5i
}
CSR.R.1:DM5_O { @ DM5_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM5_O
}
CSR.R.1:DUM5 { @ DUM5 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM5
}
CSR.R.1:M6_OLD { @ M6_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M6_OLD
}
CSR.R.1:M6_NEW { @ M6_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M6_NEW
}
CSR.R.1:DUM6_OLD { @ DUM6_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM6_OLD
}
CSR.R.1:DUM6_NEW { @ DUM6_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM6_NEW
}
CSR.R.1:VIA1i { @ VIA1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA1i
}
CSR.R.1:DVIA1 { @ DVIA1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA1
}
CSR.R.1:VIA2i { @ VIA2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA2i
}
CSR.R.1:DVIA2 { @ DVIA2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA2
}
CSR.R.1:VIA3i { @ VIA3i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA3i
}
CSR.R.1:DVIA3 { @ DVIA3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA3
}
CSR.R.1:VIA4i { @ VIA4i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA4i
}
CSR.R.1:DVIA4 { @ DVIA4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA4
}
CSR.R.1:VIA5_OLD { @ VIA5_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA5_OLD
}
CSR.R.1:VIA5_NEW { @ VIA5_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA5_NEW
}
CSR.R.1:ODi { @ ODi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODi
}
CSR.R.1:ODiRFDRAIN { @ ODiRFDRAIN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODiRFDRAIN
}
CSR.R.1:ODiSRAM { @ ODiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODiSRAM
}
CSR.R.1:DOD { @ DOD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DOD
}
CSR.R.1:SRDOD { @ SRDOD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRDOD
}
CSR.R.1:POi { @ POi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POi
}
CSR.R.1:POiSRAM { @ POiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POiSRAM
}
CSR.R.1:DPO { @ DPO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DPO
}
CSR.R.1:SRDPO { @ SRDPO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRDPO
}
CSR.R.1:mVTLi { @ mVTLi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND mVTLi
}
CSR.R.1:CPO { @ CPO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CPO
}
CSR.R.1:BJT4TDMY { @ BJT4TDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJT4TDMY
}
CSR.R.1:BJTDMY { @ BJTDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJTDMY
}
CSR.R.1:BJTDMY1 { @ BJTDMY1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJTDMY1
}
CSR.R.1:BJT7TDMY { @ BJT7TDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJT7TDMY
}
CSR.R.1:BJTMDDMY { @ BJTMDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJTMDDMY
}
CSR.R.1:BJTSNDMY { @ BJTSNDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJTSNDMY
}
CSR.R.1:BJT7TDMY_19 { @ BJT7TDMY_19 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJT7TDMY_19
}
CSR.R.1:BJT7TDMY_33 { @ BJT7TDMY_33 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJT7TDMY_33
}
CSR.R.1:BJT5TDMY { @ BJT5TDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJT5TDMY
}
CSR.R.1:MATCHING_HV { @ MATCHING_HV is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND MATCHING_HV
}
CSR.R.1:MATCHING { @ MATCHING is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND MATCHING
}
CSR.R.1:MATCHING_S { @ MATCHING_S is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND MATCHING_S
}
CSR.R.1:RES50 { @ RES50 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RES50
}
CSR.R.1:POS1 { @ POS1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS1
}
CSR.R.1:POS2 { @ POS2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS2
}
CSR.R.1:POS_OTHERS { @ POS_OTHERS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS_OTHERS
}
CSR.R.1:RMDMY1 { @ RMDMY1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY1
}
CSR.R.1:RMDMY2 { @ RMDMY2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY2
}
CSR.R.1:RMDMY3 { @ RMDMY3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY3
}
CSR.R.1:RMDMY4 { @ RMDMY4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY4
}
CSR.R.1:RMDMY5 { @ RMDMY5 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY5
}
CSR.R.1:RMDMY6 { @ RMDMY6 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMY6
}
CSR.R.1:RMDMYAP { @ RMDMYAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RMDMYAP
}
#ELSE
SEALRING_INNER = SEALRING_ORI INSIDE (HOLES SEALRING_ORI)
SEALRING_OUTER = SEALRING_ORI NOT SEALRING_INNER

CSR_M1 = M1i AND CSRDMY
Reinforced_M1 = (CSR_M1 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M1 = M1i AND SEALRING_ORI
SR_M1_INNER = SR_M1 INTERACT SEALRING_INNER
SR_M1_OUTER = SR_M1 INTERACT SEALRING_OUTER
CSR_M2 = M2i AND CSRDMY
Reinforced_M2 = (CSR_M2 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M2 = M2i AND SEALRING_ORI
SR_M2_INNER = SR_M2 INTERACT SEALRING_INNER
SR_M2_OUTER = SR_M2 INTERACT SEALRING_OUTER
CSR_M3 = M3i AND CSRDMY
Reinforced_M3 = (CSR_M3 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M3 = M3i AND SEALRING_ORI
SR_M3_INNER = SR_M3 INTERACT SEALRING_INNER
SR_M3_OUTER = SR_M3 INTERACT SEALRING_OUTER
CSR_M4 = M4i AND CSRDMY
Reinforced_M4 = (CSR_M4 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M4 = M4i AND SEALRING_ORI
SR_M4_INNER = SR_M4 INTERACT SEALRING_INNER
SR_M4_OUTER = SR_M4 INTERACT SEALRING_OUTER
CSR_M5 = M5i AND CSRDMY
Reinforced_M5 = (CSR_M5 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M5 = M5i AND SEALRING_ORI
SR_M5_INNER = SR_M5 INTERACT SEALRING_INNER
SR_M5_OUTER = SR_M5 INTERACT SEALRING_OUTER
CSR_M6 = M6i AND CSRDMY
Reinforced_M6 = (CSR_M6 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M6 = M6i AND SEALRING_ORI
SR_M6_INNER = SR_M6 INTERACT SEALRING_INNER
SR_M6_OUTER = SR_M6 INTERACT SEALRING_OUTER
SR_CO = CO INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA1 = VIA1 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA1_BAR = NOT RECTANGLE SR_VIA1
SR_VIA1_HOLE = SR_VIA1 NOT SR_VIA1_BAR
SR_VIA1_BAR_INNER = SR_VIA1_BAR INTERACT SEALRING_INNER
SR_VIA1_BAR_OUTER = SR_VIA1_BAR INTERACT SEALRING_OUTER
SR_VIA2 = VIA2 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA2_BAR = NOT RECTANGLE SR_VIA2
SR_VIA2_HOLE = SR_VIA2 NOT SR_VIA2_BAR
SR_VIA2_BAR_INNER = SR_VIA2_BAR INTERACT SEALRING_INNER
SR_VIA2_BAR_OUTER = SR_VIA2_BAR INTERACT SEALRING_OUTER
SR_VIA3 = VIA3 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA3_BAR = NOT RECTANGLE SR_VIA3
SR_VIA3_HOLE = SR_VIA3 NOT SR_VIA3_BAR
SR_VIA3_BAR_INNER = SR_VIA3_BAR INTERACT SEALRING_INNER
SR_VIA3_BAR_OUTER = SR_VIA3_BAR INTERACT SEALRING_OUTER
SR_VIA4 = VIA4 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA4_BAR = NOT RECTANGLE SR_VIA4
SR_VIA4_HOLE = SR_VIA4 NOT SR_VIA4_BAR
SR_VIA4_BAR_INNER = SR_VIA4_BAR INTERACT SEALRING_INNER
SR_VIA4_BAR_OUTER = SR_VIA4_BAR INTERACT SEALRING_OUTER
SR_VIA5 = VIA5 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA5_BAR = NOT RECTANGLE SR_VIA5
SR_VIA5_HOLE = SR_VIA5 NOT SR_VIA5_BAR
SR_VIA5_BAR_INNER = SR_VIA5_BAR INTERACT SEALRING_INNER
SR_VIA5_BAR_OUTER = SR_VIA5_BAR INTERACT SEALRING_OUTER
SR_CBi = CBi INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_CBDi = CBDi INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_RVi = RVi INTERACT (SEALRING_ORI OR SEALRING_DB)


#IFDEF WITH_APRDL
SR_CB = CB1i OR RVi
#ELSE
SR_CB = COPY CB1i
#ENDIF

#IFNDEF OLD_SEALRING
CHIP_CORNER_C = (CHIP NOT ((HOLES SEALRING_DB) OR SEALRING_DB)) AND SEALRING_ALL
CSR_M1_D =  ((CSR_M1 NOT SEALRING_ORI) NOT Reinforced_M1) OR (M1i AND CHIP_CORNER_C)
ISO_M1_D = (M1 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M1 = M1 INTERACT SEALRING_DB                            // Metal1 in SLDB
CSR_M2_D =  ((CSR_M2 NOT SEALRING_ORI) NOT Reinforced_M2) OR (M2i AND CHIP_CORNER_C)
ISO_M2_D = (M2 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M2 = M2 INTERACT SEALRING_DB                            // Metal2 in SLDB
CSR_M3_D =  ((CSR_M3 NOT SEALRING_ORI) NOT Reinforced_M3) OR (M3i AND CHIP_CORNER_C)
ISO_M3_D = (M3 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M3 = M3 INTERACT SEALRING_DB                            // Metal3 in SLDB
CSR_M4_D =  ((CSR_M4 NOT SEALRING_ORI) NOT Reinforced_M4) OR (M4i AND CHIP_CORNER_C)
ISO_M4_D = (M4 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M4 = M4 INTERACT SEALRING_DB                            // Metal4 in SLDB
CSR_M5_D =  ((CSR_M5 NOT SEALRING_ORI) NOT Reinforced_M5) OR (M5i AND CHIP_CORNER_C)
ISO_M5_D = (M5 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M5 = M5 INTERACT SEALRING_DB                            // Metal5 in SLDB
CSR_M6_D =  ((CSR_M6 NOT SEALRING_ORI) NOT Reinforced_M6) OR (M6i AND CHIP_CORNER_C)
ISO_M6_D = (M6 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M6 = M6 INTERACT SEALRING_DB                            // Metal6 in SLDB
CSR_VIA1_D = (((VIA1i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M1) OR (VIA1i AND CHIP_CORNER_C)
ISO_VIA1_D = (VIA1 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA1_BAR_SLDB = SR_VIA1_BAR AND SEALRING_DB
SR_VIA1_BAR_SR = SR_VIA1_BAR NOT SEALRING_DB
SR_VIA1_HOLE_SLDB = SR_VIA1_HOLE AND SEALRING_DB
SR_VIA1_HOLE_SR = SR_VIA1_HOLE NOT SEALRING_DB
CSR_VIA2_D = (((VIA2i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M2) OR (VIA2i AND CHIP_CORNER_C)
ISO_VIA2_D = (VIA2 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA2_BAR_SLDB = SR_VIA2_BAR AND SEALRING_DB
SR_VIA2_BAR_SR = SR_VIA2_BAR NOT SEALRING_DB
SR_VIA2_HOLE_SLDB = SR_VIA2_HOLE AND SEALRING_DB
SR_VIA2_HOLE_SR = SR_VIA2_HOLE NOT SEALRING_DB
CSR_VIA3_D = (((VIA3i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M3) OR (VIA3i AND CHIP_CORNER_C)
ISO_VIA3_D = (VIA3 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA3_BAR_SLDB = SR_VIA3_BAR AND SEALRING_DB
SR_VIA3_BAR_SR = SR_VIA3_BAR NOT SEALRING_DB
SR_VIA3_HOLE_SLDB = SR_VIA3_HOLE AND SEALRING_DB
SR_VIA3_HOLE_SR = SR_VIA3_HOLE NOT SEALRING_DB
CSR_VIA4_D = (((VIA4i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M4) OR (VIA4i AND CHIP_CORNER_C)
ISO_VIA4_D = (VIA4 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA4_BAR_SLDB = SR_VIA4_BAR AND SEALRING_DB
SR_VIA4_BAR_SR = SR_VIA4_BAR NOT SEALRING_DB
SR_VIA4_HOLE_SLDB = SR_VIA4_HOLE AND SEALRING_DB
SR_VIA4_HOLE_SR = SR_VIA4_HOLE NOT SEALRING_DB
CSR_VIA5_D = (((VIA5i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M5) OR (VIA5i AND CHIP_CORNER_C)
ISO_VIA5_D = (VIA5 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA5_BAR_SLDB = SR_VIA5_BAR AND SEALRING_DB
SR_VIA5_BAR_SR = SR_VIA5_BAR NOT SEALRING_DB
SR_VIA5_HOLE_SLDB = SR_VIA5_HOLE AND SEALRING_DB
SR_VIA5_HOLE_SR = SR_VIA5_HOLE NOT SEALRING_DB
#IFDEF SINGLE_PASSIVATION
SR_CB_BAR_OUTER = CB1i INTERACT SEALRING_OUTER
#ENDIF

SR_CB_BAR_INNER = SR_CB INTERACT SEALRING_INNER	
SR_CB_BAR_SLDB = SR_CB INTERACT SEALRING_DB

SR_AP_BAR_INNER = (AP AND SEALRING_INNER) AND CHIP_AP
SR_AP_BAR_SLDB = (AP INTERACT SEALRING_DB) AND CHIP_AP
SR_CB2_BAR_OUTER = CB2i INTERACT SEALRING_OUTER
SR_CB2_BAR_SLDB = CB2i INTERACT SEALRING_DB
#ENDIF

CSR.R.2 { @ The CSR structure must include PM, CB2_FC or CB2_WB, AP, {{CB OR CBD} OR RV}, Mtop/Mtop-1 (top metal), VIAtop/VIAtop-1, M8, VIA7...VIA1, M1, CO, PP, OD layers. The CSR pattern includes an additional 2/6 um width seal-ring and reinforced metal structure, as shown in Figure XXX   
  SEALRING_ORI NOT ODi
  SEALRING_ORI NOT PPi
  SEALRING_ORI NOT M1x
  SEALRING_ORI NOT M2x
  SEALRING_ORI NOT M3x
  SEALRING_ORI NOT M4x
  SEALRING_ORI NOT M5x
  SEALRING_ORI NOT M6x
  (SR_M1 AND CSRDMY) NOT ENCLOSE (SR_CO AND CSRDMY)
  (SR_M1 NOT CSRDMY) NOT ENCLOSE (SR_CO NOT CSRDMY)
  (SR_M2 AND CSRDMY) NOT ENCLOSE (SR_VIA1 AND CSRDMY)
  (SR_M2 NOT CSRDMY) NOT ENCLOSE (SR_VIA1 NOT CSRDMY)
  (SR_M3 AND CSRDMY) NOT ENCLOSE (SR_VIA2 AND CSRDMY)
  (SR_M3 NOT CSRDMY) NOT ENCLOSE (SR_VIA2 NOT CSRDMY)
  (SR_M4 AND CSRDMY) NOT ENCLOSE (SR_VIA3 AND CSRDMY)
  (SR_M4 NOT CSRDMY) NOT ENCLOSE (SR_VIA3 NOT CSRDMY)
  (SR_M5 AND CSRDMY) NOT ENCLOSE (SR_VIA4 AND CSRDMY)
  (SR_M5 NOT CSRDMY) NOT ENCLOSE (SR_VIA4 NOT CSRDMY)
  (SR_M6 AND CSRDMY) NOT ENCLOSE (SR_VIA5 AND CSRDMY)
  (SR_M6 NOT CSRDMY) NOT ENCLOSE (SR_VIA5 NOT CSRDMY)
#IFDEF SINGLE_PASSIVATION
  (SEALRING_OUTER AND CSRDMY) NOT INTERACT (SR_CB AND CSRDMY) 
  (SEALRING_OUTER NOT CSRDMY) NOT INTERACT (SR_CB NOT CSRDMY)   
#ELSE
  (SEALRING_INNER AND CSRDMY) NOT ENCLOSE (SR_CB AND CSRDMY)
  (SEALRING_INNER NOT CSRDMY) NOT ENCLOSE (SR_CB NOT CSRDMY)
  ((SEALRING_INNER AND CSRDMY) AND CHIP_AP) NOT INTERACT (APi AND CSRDMY)
  ((SEALRING_INNER NOT CSRDMY) AND CHIP_AP) NOT INTERACT (APi NOT CSRDMY)
  (SEALRING_OUTER AND CSRDMY) NOT ENCLOSE (CB2i AND CSRDMY)
  (SEALRING_OUTER NOT CSRDMY) NOT ENCLOSE (CB2i NOT CSRDMY)
#ENDIF
}

// CSR.W.1 is checked by CSR.W.1:M1
CSR.W.1:M1 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M1 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M1
CSR.L.1:M1 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M1_HOLE_R = HOLES CSR_M1
  A = INT [CSR_M1_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M1_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
// CSR.W.1 is checked by CSR.W.1:M2
CSR.W.1:M2 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M2 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M2
CSR.L.1:M2 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M2_HOLE_R = HOLES CSR_M2
  A = INT [CSR_M2_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M2_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
// CSR.W.1 is checked by CSR.W.1:M3
CSR.W.1:M3 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M3 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M3
CSR.L.1:M3 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M3_HOLE_R = HOLES CSR_M3
  A = INT [CSR_M3_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M3_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
// CSR.W.1 is checked by CSR.W.1:M4
CSR.W.1:M4 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M4 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M4
CSR.L.1:M4 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M4_HOLE_R = HOLES CSR_M4
  A = INT [CSR_M4_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M4_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
// CSR.W.1 is checked by CSR.W.1:M5
CSR.W.1:M5 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M5 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M5
CSR.L.1:M5 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M5_HOLE_R = HOLES CSR_M5
  A = INT [CSR_M5_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M5_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
// CSR.W.1 is checked by CSR.W.1:M6
CSR.W.1:M6 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M6 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
// CSR.L.1 is checked by CSR.L.1:M6
CSR.L.1:M6 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M6_HOLE_R = HOLES CSR_M6
  A = INT [CSR_M6_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M6_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}

CSR.R.3 { @ Distance between 45 degree outer seal ring and seal ring corner >= ^CSR_R_3A um <= ^CSR_R_3B um
  X = EXTENT SEALRING_OUTER
  CHIP_CORNER_A = INT X  <= CSR_R_3A ABUT == 90 REGION INTERSECTING ONLY
  CHIP_CORNER_B = INT X  <= CSR_R_3B ABUT == 90 REGION INTERSECTING ONLY
  CHIP_CORNER_A AND SEALRING_ORI
  CHIP_CORNER_B NOT INTERACT SEALRING_ORI
}

#IFNDEF OLD_SEALRING
CSR.R.4 { @ CSRDMY layer (CAD layer: 166;0), CSRBIB1DMY (166;1) and CSRBIB2DMY (166;2) are must if customers add seal ring by themselves.
	  @ Sealring related rules will not be checked without dummy layers.
  CHIP NOT INTERACT CSRDMY
  CHIP NOT INTERACT CSRBIB1DMY
  CHIP NOT INTERACT CSRBIB2DMY
}

CSR.R.5 { @ DMV pattern in CSR must include Mtop/VIAtop/Mtop-1/VIAtop-1/Mtop-2/VIAtop-2/.../V1/M1, except for Mu design.
  CSRDMY NOT INTERACT CSR_M1_D
  CSRDMY NOT INTERACT CSR_M2_D
  CSRDMY NOT INTERACT CSR_M3_D
  CSRDMY NOT INTERACT CSR_M4_D
  CSRDMY NOT INTERACT CSR_M5_D
  CSRDMY NOT INTERACT CSR_M6_D
  CSRDMY NOT INTERACT CSR_VIA1_D
  CSRDMY NOT INTERACT CSR_VIA2_D
  CSRDMY NOT INTERACT CSR_VIA3_D
  CSRDMY NOT INTERACT CSR_VIA4_D
  CSRDMY NOT INTERACT CSR_VIA5_D
}
// CSR.R.6 is not necessary to check

SR.R.2 { @ DMV pattern in assembly isolation region must include Mtop/VIAtop/ Mtop-1/VIAtop-1/Mtop-2/VIAtop-2/.../V1/M1, except Mu design.
  ISO_REGION NOT INTERACT ISO_M1_D
  ISO_REGION NOT INTERACT ISO_M2_D
  ISO_REGION NOT INTERACT ISO_M3_D
  ISO_REGION NOT INTERACT ISO_M4_D
  ISO_REGION NOT INTERACT ISO_M5_D
  ISO_REGION NOT INTERACT ISO_M6_D
  ISO_REGION NOT INTERACT ISO_VIA1_D
  ISO_REGION NOT INTERACT ISO_VIA2_D
  ISO_REGION NOT INTERACT ISO_VIA3_D
  ISO_REGION NOT INTERACT ISO_VIA4_D
  ISO_REGION NOT INTERACT ISO_VIA5_D
}


// CSR_DM.W.1 is checked by CSR_DM.W.1:M1
CSR_DM.W.1:M1 { @ Metal width of DMV in CSR region =  ^CSR_DM1_W_1
  NOT RECTANGLE CSR_M1_D == CSR_DM1_W_1 BY == CSR_DM1_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M1
CSR_DM.S.1:M1 { @ Metal space of DMV in CSR region >= ^CSR_DM1_S_1
  EXT CSR_M1_D < CSR_DM1_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M1
CSR_DM.S.2:M1 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM1_S_2
  EXT CSR_M1_D (M1i NOT CSR_M1_D) < CSR_DM1_S_2 ABUT < 90 SINGULAR REGION
}
// CSR_DM.O.1 is checked by CSR_DM.O.1:M1
CSR_DM.O.1:M1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM1_O_1
 CSR_M1_M2 = CSR_M1_D AND CSR_M2_D
 NOT RECTANGLE CSR_M1_M2 == CSR_DM1_O_1 BY == CSR_DM1_O_1 ORTHOGONAL ONLY
}
// SR_DM.W.1 is checked by SR_DM.W.1:M1
SR_DM.W.1:M1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM1_W_1
  NOT RECTANGLE ISO_M1_D == SR_DM1_W_1 BY == SR_DM1_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M1
SR_DM.S.1:M1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM1_S_1
  EXT ISO_M1_D < SR_DM1_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M1
SR_DM.S.2:M1 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM1_S_2
  EXT ISO_M1_D SR_M1_INNER < SR_DM1_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.O.1 is checked by SR_DM.O.1:M1
SR_DM.O.1:M1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM1_O_1
 ISO_M1_M2 = ISO_M1_D AND ISO_M2_D
 NOT RECTANGLE ISO_M1_M2 == SR_DM1_O_1 BY == SR_DM1_O_1 ORTHOGONAL ONLY
}



// CSR_DM.W.1 is checked by CSR_DM.W.1:M2
CSR_DM.W.1:M2 { @ Metal width of DMV in CSR region =  ^CSR_DM2_W_1
  NOT RECTANGLE CSR_M2_D == CSR_DM2_W_1 BY == CSR_DM2_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M2
CSR_DM.S.1:M2 { @ Metal space of DMV in CSR region >= ^CSR_DM2_S_1
  EXT CSR_M2_D < CSR_DM2_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M2
CSR_DM.S.2:M2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM2_S_2
  EXT CSR_M2_D (M2i NOT CSR_M2_D) < CSR_DM2_S_2 ABUT < 90 SINGULAR REGION
}
// CSR_DM.O.1 is checked by CSR_DM.O.1:M2
CSR_DM.O.1:M2 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM2_O_1
 CSR_M2_M3 = CSR_M2_D AND CSR_M3_D
 NOT RECTANGLE CSR_M2_M3 == CSR_DM2_O_1 BY == CSR_DM2_O_1 ORTHOGONAL ONLY
}
// SR_DM.W.1 is checked by SR_DM.W.1:M2
SR_DM.W.1:M2  { @ Metal width of DMV in Assembly isolation region = ^SR_DM2_W_1
  NOT RECTANGLE ISO_M2_D == SR_DM2_W_1 BY == SR_DM2_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M2
SR_DM.S.1:M2 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM2_S_1
  EXT ISO_M2_D < SR_DM2_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M2
SR_DM.S.2:M2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM2_S_2
  EXT ISO_M2_D SR_M2_INNER < SR_DM2_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.O.1 is checked by SR_DM.O.1:M2
SR_DM.O.1:M2 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM2_O_1
 ISO_M2_M3 = ISO_M2_D AND ISO_M3_D
 NOT RECTANGLE ISO_M2_M3 == SR_DM2_O_1 BY == SR_DM2_O_1 ORTHOGONAL ONLY
}



// CSR_DM.W.1 is checked by CSR_DM.W.1:M3
CSR_DM.W.1:M3 { @ Metal width of DMV in CSR region =  ^CSR_DM3_W_1
  NOT RECTANGLE CSR_M3_D == CSR_DM3_W_1 BY == CSR_DM3_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M3
CSR_DM.S.1:M3 { @ Metal space of DMV in CSR region >= ^CSR_DM3_S_1
  EXT CSR_M3_D < CSR_DM3_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M3
CSR_DM.S.2:M3 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM3_S_2
  EXT CSR_M3_D (M3i NOT CSR_M3_D) < CSR_DM3_S_2 ABUT < 90 SINGULAR REGION
}
// CSR_DM.O.1 is checked by CSR_DM.O.1:M3
CSR_DM.O.1:M3 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM3_O_1
 CSR_M3_M4 = CSR_M3_D AND CSR_M4_D
 NOT RECTANGLE CSR_M3_M4 == CSR_DM3_O_1 BY == CSR_DM3_O_1 ORTHOGONAL ONLY
}
// SR_DM.W.1 is checked by SR_DM.W.1:M3
SR_DM.W.1:M3  { @ Metal width of DMV in Assembly isolation region = ^SR_DM3_W_1
  NOT RECTANGLE ISO_M3_D == SR_DM3_W_1 BY == SR_DM3_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M3
SR_DM.S.1:M3 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM3_S_1
  EXT ISO_M3_D < SR_DM3_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M3
SR_DM.S.2:M3 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM3_S_2
  EXT ISO_M3_D SR_M3_INNER < SR_DM3_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.O.1 is checked by SR_DM.O.1:M3
SR_DM.O.1:M3 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM3_O_1
 ISO_M3_M4 = ISO_M3_D AND ISO_M4_D
 NOT RECTANGLE ISO_M3_M4 == SR_DM3_O_1 BY == SR_DM3_O_1 ORTHOGONAL ONLY
}



// CSR_DM.W.1 is checked by CSR_DM.W.1:M4
CSR_DM.W.1:M4 { @ Metal width of DMV in CSR region =  ^CSR_DM4_W_1
  NOT RECTANGLE CSR_M4_D == CSR_DM4_W_1 BY == CSR_DM4_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M4
CSR_DM.S.1:M4 { @ Metal space of DMV in CSR region >= ^CSR_DM4_S_1
  EXT CSR_M4_D < CSR_DM4_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M4
CSR_DM.S.2:M4 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM4_S_2
  EXT CSR_M4_D (M4i NOT CSR_M4_D) < CSR_DM4_S_2 ABUT < 90 SINGULAR REGION
}
// CSR_DM.O.1 is checked by CSR_DM.O.1:M4
CSR_DM.O.1:M4 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM4_O_1
 CSR_M4_M5 = CSR_M4_D AND CSR_M5_D
 NOT RECTANGLE CSR_M4_M5 == CSR_DM4_O_1 BY == CSR_DM4_O_1 ORTHOGONAL ONLY
}
// SR_DM.W.1 is checked by SR_DM.W.1:M4
SR_DM.W.1:M4  { @ Metal width of DMV in Assembly isolation region = ^SR_DM4_W_1
  NOT RECTANGLE ISO_M4_D == SR_DM4_W_1 BY == SR_DM4_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M4
SR_DM.S.1:M4 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM4_S_1
  EXT ISO_M4_D < SR_DM4_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M4
SR_DM.S.2:M4 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM4_S_2
  EXT ISO_M4_D SR_M4_INNER < SR_DM4_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.O.1 is checked by SR_DM.O.1:M4
SR_DM.O.1:M4 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM4_O_1
 ISO_M4_M5 = ISO_M4_D AND ISO_M5_D
 NOT RECTANGLE ISO_M4_M5 == SR_DM4_O_1 BY == SR_DM4_O_1 ORTHOGONAL ONLY
}



// CSR_DM.W.1 is checked by CSR_DM.W.1:M5
CSR_DM.W.1:M5 { @ Metal width of DMV in CSR region =  ^CSR_DM5_W_1
  NOT RECTANGLE CSR_M5_D == CSR_DM5_W_1 BY == CSR_DM5_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M5
CSR_DM.S.1:M5 { @ Metal space of DMV in CSR region >= ^CSR_DM5_S_1
  EXT CSR_M5_D < CSR_DM5_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M5
CSR_DM.S.2:M5 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM5_S_2
  EXT CSR_M5_D (M5i NOT CSR_M5_D) < CSR_DM5_S_2 ABUT < 90 SINGULAR REGION
}
// CSR_DM.O.1 is checked by CSR_DM.O.1:M5
CSR_DM.O.1:M5 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM5_O_1
 CSR_M5_M6 = CSR_M5_D AND CSR_M6_D
 NOT RECTANGLE CSR_M5_M6 == CSR_DM5_O_1 BY == CSR_DM5_O_1 ORTHOGONAL ONLY
}
// SR_DM.W.1 is checked by SR_DM.W.1:M5
SR_DM.W.1:M5  { @ Metal width of DMV in Assembly isolation region = ^SR_DM5_W_1
  NOT RECTANGLE ISO_M5_D == SR_DM5_W_1 BY == SR_DM5_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M5
SR_DM.S.1:M5 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM5_S_1
  EXT ISO_M5_D < SR_DM5_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M5
SR_DM.S.2:M5 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM5_S_2
  EXT ISO_M5_D SR_M5_INNER < SR_DM5_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.O.1 is checked by SR_DM.O.1:M5
SR_DM.O.1:M5 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM5_O_1
 ISO_M5_M6 = ISO_M5_D AND ISO_M6_D
 NOT RECTANGLE ISO_M5_M6 == SR_DM5_O_1 BY == SR_DM5_O_1 ORTHOGONAL ONLY
}



// CSR_DM.W.1 is checked by CSR_DM.W.1:M6
CSR_DM.W.1:M6 { @ Metal width of DMV in CSR region =  ^CSR_DM6_W_1
  NOT RECTANGLE CSR_M6_D == CSR_DM6_W_1 BY == CSR_DM6_W_1 ORTHOGONAL ONLY
}
// CSR_DM.S.1 is checked by CSR_DM.S.1:M6
CSR_DM.S.1:M6 { @ Metal space of DMV in CSR region >= ^CSR_DM6_S_1
  EXT CSR_M6_D < CSR_DM6_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DM.S.2 is checked by CSR_DM.S.2:M6
CSR_DM.S.2:M6 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM6_S_2
  EXT CSR_M6_D (M6i NOT CSR_M6_D) < CSR_DM6_S_2 ABUT < 90 SINGULAR REGION
}
// SR_DM.W.1 is checked by SR_DM.W.1:M6
SR_DM.W.1:M6  { @ Metal width of DMV in Assembly isolation region = ^SR_DM6_W_1
  NOT RECTANGLE ISO_M6_D == SR_DM6_W_1 BY == SR_DM6_W_1 ORTHOGONAL ONLY
}
// SR_DM.S.1 is checked by SR_DM.S.1:M6
SR_DM.S.1:M6 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM6_S_1
  EXT ISO_M6_D < SR_DM6_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DM.S.2 is checked by SR_DM.S.2:M6
SR_DM.S.2:M6 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM6_S_2
  EXT ISO_M6_D SR_M6_INNER < SR_DM6_S_2 ABUT < 90 SINGULAR REGION
}




// CSR_DV.W.1 is checked by CSR_DV.W.1:VIA1
CSR_DV.W.1:VIA1 { @ Via width of DMV in CSR region. = ^CSR_DV1_W_1
  NOT RECTANGLE CSR_VIA1_D == CSR_DV1_W_1 BY == CSR_DV1_W_1 ORTHOGONAL ONLY
}
// CSR_DV.S.1 is checked by CSR_DV.S.1:VIA1
CSR_DV.S.1:VIA1 { @ Via space of DMV in CSR region. >= ^CSR_DV1_S_1
  EXT CSR_VIA1_D < CSR_DV1_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DV.EN.1 is checked by CSR_DV.EN.1:VIA1
CSR_DV.EN.1:VIA1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV1_EN_1
  ENC CSR_VIA1_D CSR_M2_D < CSR_DV1_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA1_D NOT CSR_M2_D
}
// SR_DV.W.1 is checked by SR_DV.W.1:VIA1
SR_DV.W.1:VIA1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV1_W_1
  NOT RECTANGLE ISO_VIA1_D == SR_DV1_W_1 BY == SR_DV1_W_1 ORTHOGONAL ONLY
}
// SR_DV.S.1 is checked by SR_DV.S.1:VIA1
SR_DV.S.1:VIA1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV1_S_1
  EXT ISO_VIA1_D < SR_DV1_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DV.EN.1 is checked by SR_DV.EN.1:VIA1
SR_DV.EN.1:VIA1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV1_EN_1
  ENC ISO_VIA1_D ISO_M2_D < SR_DV1_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA1_D NOT ISO_M2_D
}


// CSR_DV.W.1 is checked by CSR_DV.W.1:VIA2
CSR_DV.W.1:VIA2 { @ Via width of DMV in CSR region. = ^CSR_DV2_W_1
  NOT RECTANGLE CSR_VIA2_D == CSR_DV2_W_1 BY == CSR_DV2_W_1 ORTHOGONAL ONLY
}
// CSR_DV.S.1 is checked by CSR_DV.S.1:VIA2
CSR_DV.S.1:VIA2 { @ Via space of DMV in CSR region. >= ^CSR_DV2_S_1
  EXT CSR_VIA2_D < CSR_DV2_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DV.EN.1 is checked by CSR_DV.EN.1:VIA2
CSR_DV.EN.1:VIA2 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV2_EN_1
  ENC CSR_VIA2_D CSR_M3_D < CSR_DV2_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA2_D NOT CSR_M3_D
}
// SR_DV.W.1 is checked by SR_DV.W.1:VIA2
SR_DV.W.1:VIA2 { @ Via width of DMV in Assembly isolation region. = ^SR_DV2_W_1
  NOT RECTANGLE ISO_VIA2_D == SR_DV2_W_1 BY == SR_DV2_W_1 ORTHOGONAL ONLY
}
// SR_DV.S.1 is checked by SR_DV.S.1:VIA2
SR_DV.S.1:VIA2 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV2_S_1
  EXT ISO_VIA2_D < SR_DV2_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DV.EN.1 is checked by SR_DV.EN.1:VIA2
SR_DV.EN.1:VIA2 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV2_EN_1
  ENC ISO_VIA2_D ISO_M3_D < SR_DV2_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA2_D NOT ISO_M3_D
}


// CSR_DV.W.1 is checked by CSR_DV.W.1:VIA3
CSR_DV.W.1:VIA3 { @ Via width of DMV in CSR region. = ^CSR_DV3_W_1
  NOT RECTANGLE CSR_VIA3_D == CSR_DV3_W_1 BY == CSR_DV3_W_1 ORTHOGONAL ONLY
}
// CSR_DV.S.1 is checked by CSR_DV.S.1:VIA3
CSR_DV.S.1:VIA3 { @ Via space of DMV in CSR region. >= ^CSR_DV3_S_1
  EXT CSR_VIA3_D < CSR_DV3_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DV.EN.1 is checked by CSR_DV.EN.1:VIA3
CSR_DV.EN.1:VIA3 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV3_EN_1
  ENC CSR_VIA3_D CSR_M4_D < CSR_DV3_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA3_D NOT CSR_M4_D
}
// SR_DV.W.1 is checked by SR_DV.W.1:VIA3
SR_DV.W.1:VIA3 { @ Via width of DMV in Assembly isolation region. = ^SR_DV3_W_1
  NOT RECTANGLE ISO_VIA3_D == SR_DV3_W_1 BY == SR_DV3_W_1 ORTHOGONAL ONLY
}
// SR_DV.S.1 is checked by SR_DV.S.1:VIA3
SR_DV.S.1:VIA3 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV3_S_1
  EXT ISO_VIA3_D < SR_DV3_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DV.EN.1 is checked by SR_DV.EN.1:VIA3
SR_DV.EN.1:VIA3 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV3_EN_1
  ENC ISO_VIA3_D ISO_M4_D < SR_DV3_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA3_D NOT ISO_M4_D
}


// CSR_DV.W.1 is checked by CSR_DV.W.1:VIA4
CSR_DV.W.1:VIA4 { @ Via width of DMV in CSR region. = ^CSR_DV4_W_1
  NOT RECTANGLE CSR_VIA4_D == CSR_DV4_W_1 BY == CSR_DV4_W_1 ORTHOGONAL ONLY
}
// CSR_DV.S.1 is checked by CSR_DV.S.1:VIA4
CSR_DV.S.1:VIA4 { @ Via space of DMV in CSR region. >= ^CSR_DV4_S_1
  EXT CSR_VIA4_D < CSR_DV4_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DV.EN.1 is checked by CSR_DV.EN.1:VIA4
CSR_DV.EN.1:VIA4 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV4_EN_1
  ENC CSR_VIA4_D CSR_M5_D < CSR_DV4_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA4_D NOT CSR_M5_D
}
// SR_DV.W.1 is checked by SR_DV.W.1:VIA4
SR_DV.W.1:VIA4 { @ Via width of DMV in Assembly isolation region. = ^SR_DV4_W_1
  NOT RECTANGLE ISO_VIA4_D == SR_DV4_W_1 BY == SR_DV4_W_1 ORTHOGONAL ONLY
}
// SR_DV.S.1 is checked by SR_DV.S.1:VIA4
SR_DV.S.1:VIA4 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV4_S_1
  EXT ISO_VIA4_D < SR_DV4_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DV.EN.1 is checked by SR_DV.EN.1:VIA4
SR_DV.EN.1:VIA4 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV4_EN_1
  ENC ISO_VIA4_D ISO_M5_D < SR_DV4_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA4_D NOT ISO_M5_D
}


// CSR_DV.W.1 is checked by CSR_DV.W.1:VIA5
CSR_DV.W.1:VIA5 { @ Via width of DMV in CSR region. = ^CSR_DV5_W_1
  NOT RECTANGLE CSR_VIA5_D == CSR_DV5_W_1 BY == CSR_DV5_W_1 ORTHOGONAL ONLY
}
// CSR_DV.S.1 is checked by CSR_DV.S.1:VIA5
CSR_DV.S.1:VIA5 { @ Via space of DMV in CSR region. >= ^CSR_DV5_S_1
  EXT CSR_VIA5_D < CSR_DV5_S_1 ABUT < 90 SINGULAR REGION
}
// CSR_DV.EN.1 is checked by CSR_DV.EN.1:VIA5
CSR_DV.EN.1:VIA5 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV5_EN_1
  ENC CSR_VIA5_D CSR_M6_D < CSR_DV5_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA5_D NOT CSR_M6_D
}
// SR_DV.W.1 is checked by SR_DV.W.1:VIA5
SR_DV.W.1:VIA5 { @ Via width of DMV in Assembly isolation region. = ^SR_DV5_W_1
  NOT RECTANGLE ISO_VIA5_D == SR_DV5_W_1 BY == SR_DV5_W_1 ORTHOGONAL ONLY
}
// SR_DV.S.1 is checked by SR_DV.S.1:VIA5
SR_DV.S.1:VIA5 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV5_S_1
  EXT ISO_VIA5_D < SR_DV5_S_1 ABUT < 90 SINGULAR REGION
}
// SR_DV.EN.1 is checked by SR_DV.EN.1:VIA5
SR_DV.EN.1:VIA5 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV5_EN_1
  ENC ISO_VIA5_D ISO_M6_D < SR_DV5_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA5_D NOT ISO_M6_D
}




//Box in Box (BIB) pattern inside CSR
//=======================

CSR_OD_HOLE = (HOLES SEALRING_INNER) INTERACT CSRDMY

OD_RING_BIB = OD INSIDE CSR_OD_HOLE
#IFDEF P4_SEALRING
PO_RING_BIB = POLY INSIDE CSR_OD_HOLE
#ELSE
PO_RING_BIB = CSR_OD_HOLE NOT POLY
#ENDIF
CO_BIB = CO INSIDE CSR_OD_HOLE

#IFNDEF P4_SEALRING
CO_BIB_GROUP = SIZE CO_BIB BY 0.05 OVERUNDER
#ENDIF

OD_BULK_BIB = EXTENTS OD_RING_BIB
PO_BULK_BIB = EXTENTS PO_RING_BIB

OD_BULK_BIB_POOD = OD_BULK_BIB ENCLOSE PO_RING_BIB
PO_BULK_BIB_POOD = PO_BULK_BIB INSIDE OD_BULK_BIB
#IFDEF P4_SEALRING
OD_BULK_BIB_COOD = OD_BULK_BIB INTERACT CO_BIB == BIB_R_2+BIB_R_3
PO_BULK_BIB_COOD = PO_BULK_BIB INTERACT CO_BIB == BIB_R_2+BIB_R_3
CO_BULK_BIB_pre1 = SIZE CO_BIB BY BIB_L_1-2*BIB_EN_2 OVERUNDER
CO_BULK_OUTER_BIB = EXTENTS CO_BULK_BIB_pre1
CO_RING_OUTER_BIB = CO_BULK_OUTER_BIB NOT (SIZE CO_BULK_OUTER_BIB BY -BIB_W_2)
CO_BULK_BIB_pre2 = SIZE (CO_BIB NOT CO_RING_OUTER_BIB) BY BIB_L_1-2*BIB_EN_4 OVERUNDER
CO_BULK_INNER_BIB = EXTENTS CO_BULK_BIB_pre2
#ELSE
OD_BULK_BIB_COOD = OD_BULK_BIB INTERACT CO_BIB_GROUP == 4
PO_BULK_BIB_COOD = PO_BULK_BIB INTERACT CO_BIB_GROUP == 4
#ENDIF

OD_HOLE_BIB_POOD = OD_BULK_BIB_POOD NOT OD_RING_BIB
OD_HOLE_BIB_COOD = OD_BULK_BIB_COOD NOT OD_RING_BIB
PO_HOLE_BIB_POOD = PO_BULK_BIB_POOD NOT PO_RING_BIB
PO_HOLE_BIB_COOD = PO_BULK_BIB_COOD NOT PO_RING_BIB


BiB.R.1 { @ PO_OD, CO_OD and CO_PO BiB patterns must inside CSR.
          @ PO_OD BiB pattern is formed by [OD ring + PO ring inside OD ring]
	  @ CO_PO {CO_OD} BiB pattern is formed by [PO {OD} ring + CO ring inside PO {OD} ring (inner and outer)]
  (CSR_OD_HOLE NOT INTERACT CSRBIB1DMY) NOT INTERACT CSRBIB2DMY
  (CSR_OD_HOLE INTERACT CSRBIB1DMY) INTERACT CSRBIB2DMY
  A = CSR_OD_HOLE INTERACT CSRBIB1DMY
  A NOT ENCLOSE OD_BULK_BIB_COOD
  A NOT ENCLOSE PO_BULK_BIB_COOD
  B = CSR_OD_HOLE INTERACT CSRBIB2DMY
  B NOT ENCLOSE OD_BULK_BIB_POOD
  B NOT ENCLOSE PO_BULK_BIB_COOD
  CHIPx NOT INTERACT A == 2
  CHIPx NOT INTERACT B == 2
}

BiB.W.1 { @ Width of OD ring and PO ring. == ^BIB_W_1
  NOT WITH WIDTH OD_RING_BIB == BIB_W_1
  NOT WITH WIDTH PO_RING_BIB == BIB_W_1
}

BiB.W.2 { @ Width of CO (maximum = minimum). == ^BIB_W_2
  NOT RECTANGLE CO_BIB == BIB_W_2 BY ==BIB_W_2 ORTHOGONAL ONLY
}

BiB.S.1 { @ Space of {OD ring or PO ring} to sealring OD
@ DRC only select one side of OD ring or PO ring for space check == ^BIB_S_1
  A = EXT [OD_BULK_BIB] OD == BIB_S_1 OPPOSITE
  OD_BULK_BIB NOT WITH EDGE A

  B = EXT [PO_BULK_BIB_COOD] OD == BIB_S_1 OPPOSITE
  PO_BULK_BIB_COOD NOT WITH EDGE B
}

BiB.S.2 { @ Space of {OD ring or PO ring} corner to 45 degree seal ring OD edge. >= ^BIB_S_2
  A = ANGLE CSR_OD_HOLE == 45
  B = EXPAND EDGE A OUTSIDE BY 0.005
  EXT B OD_BULK_BIB < BIB_S_2 ABUT < 90 SINGULAR REGION
  EXT B PO_BULK_BIB < BIB_S_2 ABUT < 90 SINGULAR REGION
}

BiB.L.1 { @ Length of OD ring inner edge. == ^BIB_L_1
  NOT RECTANGLE OD_HOLE_BIB_POOD == BIB_L_1 BY ==BIB_L_1 ORTHOGONAL ONLY
  NOT RECTANGLE OD_HOLE_BIB_COOD == BIB_L_1 BY ==BIB_L_1 ORTHOGONAL ONLY
}

BiB.L.2 { @ Length of PO ring inner edge [in PO_OD BiB pattern]. == ^BIB_L_2
  NOT RECTANGLE PO_HOLE_BIB_POOD == BIB_L_2 BY ==BIB_L_2 ORTHOGONAL ONLY
}

BiB.L.3 { @ Length of PO ring inner edge [in CO_OD BiB pattern]. == ^BIB_L_3
  NOT RECTANGLE PO_HOLE_BIB_COOD == BIB_L_3 BY ==BIB_L_3 ORTHOGONAL ONLY
}

BiB.EN.1 { @ Enclosure of PO to OD [opposite edge in PO_OD BiB pattern]. == ^BIB_EN_1
  NOT WITH WIDTH ((OD_BULK_BIB_POOD NOT PO_BULK_BIB_POOD) NOT OD_RING_BIB) == BIB_EN_1
}

#IFDEF P4_SEALRING
BiB.S.3 { @ Space of CO to CO [in the same ring]. == ^BIB_S_3
  CO_BAR_BIB = SIZE CO_BIB BY BIB_S_3 OVERUNDER
  CO_SPACE_BIB = CO_BAR_BIB NOT CO_BIB
  NOT RECTANGLE CO_SPACE_BIB == BIB_W_2 BY == BIB_S_3 ORTHOGONAL ONLY
}

BiB.EN.2 { @ Enclosure of outer CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_2
  NOT WITH WIDTH ((OD_BULK_BIB_COOD NOT CO_BULK_OUTER_BIB) NOT OD_RING_BIB) == BIB_EN_2
}

BiB.EN.3 { @ Enclosure of outer CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_3
  NOT WITH WIDTH ((PO_BULK_BIB_COOD NOT CO_BULK_OUTER_BIB) NOT PO_RING_BIB) == BIB_EN_3
}

BiB.EN.4 { @ Enclosure of inner CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_4
  NOT WITH WIDTH ((OD_BULK_BIB_COOD NOT CO_BULK_INNER_BIB) NOT OD_RING_BIB) == BIB_EN_4
}

BiB.EN.5 { @ Enclosure of inner CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_5
  NOT WITH WIDTH ((PO_BULK_BIB_COOD NOT CO_BULK_INNER_BIB) NOT PO_RING_BIB) == BIB_EN_5
}

BiB.R.2 { @ Total CO number of outer CO ring. == ^BIB_R_2
  CO_RING_OUTER_BIB NOT INTERACT CO_BIB == BIB_R_2
}

BiB.R.3 { @ Total CO number of inner CO ring. == ^BIB_R_3
  CO_BULK_INNER_BIB NOT INTERACT CO_BIB == BIB_R_3
}
#ELSE
BIB.W.3__BIB.L.4 { @ Width x Length of {(CO SIZE 0.05) SIZE -0.05} = ^BIB_W_3 x ^BIB_L_4_1 or ^BIB_W_3 x ^BIB_L_4_2
  A = NOT RECTANGLE CO_BIB_GROUP == BIB_W_3 BY == BIB_L_4_1 ORTHOGONAL ONLY
  NOT RECTANGLE A == BIB_W_3 BY == BIB_L_4_2 ORTHOGONAL ONLY
}
// BiB.W.3 is checked by BIB.W.3__BIB.L.4
// BiB.L.4 is checked by BIB.W.3__BIB.L.4
BiB.S.3 { @ Space of CO to CO [in the same ring]. == ^BIB_S_3
  A = CO_BIB NOT COIN INSIDE EDGE CO_BIB_GROUP
  B = EXT [A] CO_BIB == BIB_S_3 OPPOSITE
  A NOT COIN INSIDE EDGE B
}
BiB.EN.2 { @ Enclosure of outer CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_2
  A = LENGTH CO_BIB_GROUP > BIB_W_3
  B = OD_BULK_BIB_COOD NOT OD_RING_BIB
  C = ENC A [B] == BIB_EN_2 OPPOSITE
  B NOT TOUCH INSIDE EDGE C
}

BiB.EN.3 { @ Enclosure of outer CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_3
  A = LENGTH CO_BIB_GROUP > BIB_W_3
  B = PO_BULK_BIB_COOD NOT PO_RING_BIB
  C = ENC A [B] == BIB_EN_3 OPPOSITE
  B NOT TOUCH INSIDE EDGE C
}
#ENDIF

BiB.R.4 { @ Overlap of OD, PO, CO patterns are not allowed.
  OD_RING_BIB AND PO_RING_BIB
  OD_RING_BIB AND CO_BIB
  PO_RING_BIB AND CO_BIB
}


#ENDIF
#ENDIF
#ENDIF



// Seal-Ring Rule Check
//=====================

#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING
SR.R.1 { @ SEALRING layer (CAD layer: 162;0) and SEALRING_DB layer (CAD layer: 162;1) are Must if customers add seal ring by themselves.
         @ 162;0 is used to cover the outer seal ring (2um) and inner seal ring (6um);
         @ 162;1 is used to cover SLDB (3.5um duplicate).
         @ 162;2 is used to cover SEALRING, SLDB, and Assembly Isolation Region.
         @ SEALRING layer (162;0) , SEALRING_DB layer (162;1), and SEALRING_ALL layer (162;2) must exist.
         @ All the drawing of seal ring and SLDB structures must be inside of SEALRING (162;0) and SEALRING_DB (162;1). (except Mu)
         @ Please follow the CAD layers usage of 162;0, 162;1, and 162;2.
	 @ Sealring related rules will not be checked without dummy layers.
  CHIP NOT INTERACT SEALRING_ORI
  SR_CO NOT (SEALRING_ORI OR SEALRING_DB)
  SR_VIA1 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA1
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA1_BAR
  SR_VIA2 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA2
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA2_BAR
  SR_VIA3 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA3
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA3_BAR
  SR_VIA4 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA4
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA4_BAR
  SR_VIA5 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA5
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA5_BAR
#IFNDEF OLD_SEALRING
  CHIP NOT INTERACT SEALRING_DB
  CHIP NOT INTERACT SEALRING_ALL
  (SEALRING_ORI OR SEALRING_DB) NOT SEALRING_ALL
#ENDIF
}

SR.R.4 { @ Please add as many VIA holes as possible in metal lines of inner and outer sealrings.
         @ DRC flags {SEALRING NOT INTERACT VIAx, VIAy, VIAz, VIAu, and VIAr holes, respectively}
  SR_M1 NOT INTERACT SR_VIA1_HOLE
  SR_M2 NOT INTERACT SR_VIA2_HOLE
  SR_M3 NOT INTERACT SR_VIA3_HOLE
  SR_M4 NOT INTERACT SR_VIA4_HOLE
  SR_M5 NOT INTERACT SR_VIA5_HOLE
}

SR.R.5 { @ LMARK must be inside SEALRING_ALL
   LMARK NOT INSIDE SEALRING_ALL
}

SR.R.7 { @ co bar, via bar, and cb/cbd/rv bar must be continuous as a ring
  NOT DONUT SR_CO
  CONVEX EDGE SR_CO ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CO_W_2
  NOT DONUT SR_VIA1_BAR
  CONVEX EDGE SR_VIA1_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA1_W_2
  NOT DONUT SR_VIA2_BAR
  CONVEX EDGE SR_VIA2_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA2_W_2
  NOT DONUT SR_VIA3_BAR
  CONVEX EDGE SR_VIA3_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA3_W_2
  NOT DONUT SR_VIA4_BAR
  CONVEX EDGE SR_VIA4_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA4_W_2
  NOT DONUT SR_VIA5_BAR
  CONVEX EDGE SR_VIA5_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA5_W_2
  NOT DONUT (NOT RECTANGLE SR_CBi)
  CONVEX EDGE SR_CBi ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CB_W_3
  NOT DONUT (NOT RECTANGLE SR_CBDi)
  CONVEX EDGE SR_CBDi ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CB_W_3
  NOT DONUT (NOT RECTANGLE SR_RVi)
  CONVEX EDGE SR_RVi ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CB_W_3
}

SR.R.9 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern)
  ISO_REGION AND DNWi
  ISO_REGION AND NWi
  (ISO_REGION AND POi) NOT INSIDE CDUDMY
  ISO_REGION AND DPO
  (ISO_REGION AND ODi) NOT INSIDE CDUDMY
  ISO_REGION AND DOD
  (ISO_REGION AND COi) NOT INSIDE CDUDMY
  ISO_REGION AND RVi
  ISO_REGION AND UBMi
  ISO_REGION AND CBDi
  ISO_REGION AND CBi
  ISO_REGION AND CB2Fi
  ISO_REGION AND CB2Wi
}
SR.R.9:M1 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M1i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M1i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM1 AND ISO_REGION
   (M1 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M1

SR.R.9:M2 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M2i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M2i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM2 AND ISO_REGION
   (M2 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M2

SR.R.9:M3 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M3i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M3i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM3 AND ISO_REGION
   (M3 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M3

SR.R.9:M4 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M4i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M4i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM4 AND ISO_REGION
   (M4 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M4

SR.R.9:M5 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M5i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M5i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM5 AND ISO_REGION
   (M5 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M5

SR.R.9:M6 { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING
   (M6i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE
   (M6i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM6 AND ISO_REGION
   (M6 INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:M6




SR.R.9:AP { @ Width of assembly isolation = ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU are allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   (APi NOT INTERACT SEALRING_ORI) CUT ISO_REGION
    (APi AND SEALRING_EXCLUDE) AND (CB2Fi OR CB2Wi)
    (APi INTERACT ISO_REGION) AND SEALRING_DB
}
// SR.R.9 is checked by SR.R.9:AP

SR.R.10:OD { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT OD
    SEALRING_DB NOT OD
}

SR.R.10:PP { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT PP
    SEALRING_DB NOT PP
}

SR.R.10:M1 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M1x
    SEALRING_DB NOT INTERACT M1x
}
SR.R.10:M2 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M2x
    SEALRING_DB NOT INTERACT M2x
}
SR.R.10:M3 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M3x
    SEALRING_DB NOT INTERACT M3x
}
SR.R.10:M4 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M4x
    SEALRING_DB NOT INTERACT M4x
}
SR.R.10:M5 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M5x
    SEALRING_DB NOT INTERACT M5x
}
SR.R.10:M6 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SEALRING_ORI NOT INTERACT M6x
    SEALRING_DB NOT INTERACT M6x
}

SR.R.10:CO { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M1 = M1i INTERACT SEALRING_ORI
    SR_DB_M1 = M1i INTERACT SEALRING_DB
    SR_ORI_M1 NOT ENCLOSE COi
    SR_DB_M1 NOT ENCLOSE COi
}

SR.R.10:VIA1 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M1 = M1i INTERACT SEALRING_ORI
    SR_DB_M1 = M1i INTERACT SEALRING_DB
    SR_ORI_M1 NOT ENCLOSE VIA1i
    SR_DB_M1 NOT ENCLOSE VIA1i
}
SR.R.10:VIA2 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M2 = M2i INTERACT SEALRING_ORI
    SR_DB_M2 = M2i INTERACT SEALRING_DB
    SR_ORI_M2 NOT ENCLOSE VIA2i
    SR_DB_M2 NOT ENCLOSE VIA2i
}
SR.R.10:VIA3 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M3 = M3i INTERACT SEALRING_ORI
    SR_DB_M3 = M3i INTERACT SEALRING_DB
    SR_ORI_M3 NOT ENCLOSE VIA3i
    SR_DB_M3 NOT ENCLOSE VIA3i
}
SR.R.10:VIA4 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M4 = M4i INTERACT SEALRING_ORI
    SR_DB_M4 = M4i INTERACT SEALRING_DB
    SR_ORI_M4 NOT ENCLOSE VIA4i
    SR_DB_M4 NOT ENCLOSE VIA4i
}
SR.R.10:VIA5 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
    SR_ORI_M5 = M5i INTERACT SEALRING_ORI
    SR_DB_M5 = M5i INTERACT SEALRING_DB
    SR_ORI_M5 NOT ENCLOSE VIA5i
    SR_DB_M5 NOT ENCLOSE VIA5i
}


SR.UBM:WARNING1 { @ Do not draw UBM on Chip corner stress relief pattern/Seal ring/Assembly isolation
  SRCSR AND UBMi
}


#IFNDEF OLD_SEALRING
#IFDEF SINGLE_PASSIVATION
CB.O.1 { @ Overlap of CB and top metal in outer sealring. == ^CB_O_1
  SR_CB_BAR_OUTER_M6 = SR_CB_BAR_OUTER AND M6
  X1 = ANGLE SR_CB_BAR_OUTER_M6 != 45
  X2 = ANGLE SR_CB_BAR_OUTER_M6 == 45
  INT X1 > CB_O_1 < CB_O_1*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_O_1+GRID < CB_O_1*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_OUTER_M6 >= CB_O_1*2
  INT X1 < CB_O_1 ABUT < 90 REGION
  INT X2 < CB_O_1-GRID ABUT < 90 REGION
}
#ELSE
CB.W.3 { @ Width of CB/CBD/RV line opening in inner seal ring. == ^CB_W_3
  X1 = ANGLE SR_CB_BAR_INNER != 45
  X2 = ANGLE SR_CB_BAR_INNER == 45
  INT X1 > CB_W_3 < CB_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_W_3+0.01 < CB_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_INNER >= CB_W_3*2
  INT X1 < CB_W_3 ABUT < 90 REGION
  INT X2 < CB_W_3-0.01 ABUT < 90 REGION
}
CB.W.4 { @ Width of CB/CBD/RV line opening in SLDB. == ^CB_W_4
  X1 = ANGLE SR_CB_BAR_SLDB != 45
  X2 = ANGLE SR_CB_BAR_SLDB == 45
  INT X1 > CB_W_4 < CB_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_W_4+0.01 < CB_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_SLDB >= CB_W_4*2
  INT X1 < CB_W_4 ABUT < 90 REGION
  INT X2 < CB_W_4-0.01 ABUT < 90 REGION
}
CB.EN.2 { @ Enclousure of CB/CBD/RV by AP. >= ^CB_EN_2
  ENC SR_CB_BAR_INNER SR_AP_BAR_INNER < CB_EN_2-0.01 ABUT < 90 OPPOSITE REGION
  (SR_CB_BAR_INNER AND CHIP_AP) NOT SR_AP_BAR_INNER
}
CB.EN.3 { @ Enclousure of CB/CBD/RV by AP in SLDB. >= ^CB_EN_3
  ENC SR_CB_BAR_SLDB SR_AP_BAR_SLDB < CB_EN_3-0.01 ABUT < 90 OPPOSITE REGION
  (SR_CB_BAR_SLDB AND CHIP_AP) NOT SR_AP_BAR_SLDB
}


SR_INNER_D2 = DONUT SEALRING_ORI > 1
AP_AND_SR = SR_INNER_D2 AND AP
AP_INT_SR = APi INTERACT SR_INNER_D2
SR.AP.W.3 { @ Width of AP bar in {SEALRING_ALL (162;2) NOT SEALRING_DB (162;1)} == ^AP_W_3
			@ (DRC tolerance at 45-degree turning: 0.02)
  AP_INT_CHIP = AP AND (SIZE (HOLES SEALRING_ALL) BY 0.005 )  
  X = (AP INTERACT SR_INNER_D2) AND SEALRING_ALL
  X1 = ANGLE X != 45
  X2 = ANGLE X == 45
  (INT X1 < AP_W_3 ABUT < 90 OPPOSITE PARALLEL ONLY REGION) NOT INTERACT AP_INT_CHIP
  (INT X1 > AP_W_3 < AP_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION) NOT INTERACT AP_INT_CHIP
  (INT X2 < AP_W_3-GRID*4 ABUT < 90 OPPOSITE PARALLEL ONLY REGION) NOT INTERACT AP_INT_CHIP
  (INT X2 > AP_W_3+GRID*4 < AP_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION) NOT INTERACT AP_INT_CHIP
  MAY_NG_AP = AP AND (EXPAND EDGE SEALRING_ALL INSIDE BY 3 CORNER FILL)
  MAY_NG_AP NOT TOUCH (AP AND (HOLES SEALRING_ALL))
  NOT DONUT AP_AND_SR 
  AP COIN EDGE SEALRING_ORI
  (AP NOT INTERACT (SEALRING_DB OR SEALRING_ORI)) AND SEALRING_ALL
}
AP.EN.2 { @ Enclosure of AP bar overlaps with inner seal-ring and SREZ by inner seal-ring == ^AP_EN_2 
  AP_INT_SR_CHK =  AP_INT_SR NOT COIN EDGE (HOLES AP_INT_SR)
  ANGLE (ENC (AP_INT_SR_CHK) SEALRING_INNER == AP_EN_2 ) != 45
  ENC [AP_INT_SR_CHK] SEALRING_INNER < AP_EN_2 -0.02 ABUT < 90 OPPOSITE PARALLEL
  ENC [AP_INT_SR_CHK] SEALRING_INNER > AP_EN_2 +0.02 < 2 ABUT < 90 OPPOSITE PARALLEL
}

AP.W.4 { @ Width of AP bar in SLDB. == ^AP_W_4
  X1 = ANGLE SR_AP_BAR_SLDB != 45
  X2 = ANGLE SR_AP_BAR_SLDB == 45
  INT X1 > AP_W_4 < AP_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > AP_W_4+GRID < AP_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_AP_BAR_SLDB >= AP_W_4*2
  INT X1 < AP_W_4 ABUT < 90 REGION
  INT X2 < AP_W_4-GRID ABUT < 90 REGION
}
CB2.W.5 { @ Width of CB2_WB/CB2_FC line opening in outer seal-ring = 2 
  X1 = ANGLE SR_CB2_BAR_OUTER != 45
  X2 = ANGLE SR_CB2_BAR_OUTER == 45
  INT X1 > CB2_W_5 < CB2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB2_W_5+GRID < CB2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB2_BAR_OUTER >= CB2_W_5*2
  INT X1 < CB2_W_5 ABUT < 90 REGION
  INT X2 < CB2_W_5-GRID ABUT < 90 REGION
}
CB2.W.6 { @ Width of CB2_WB/CB2_FC line opening in SLDB = 2 
  X1 = ANGLE SR_CB2_BAR_SLDB != 45
  X2 = ANGLE SR_CB2_BAR_SLDB == 45
  INT X1 > CB2_W_6 < CB2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB2_W_6+GRID < CB2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB2_BAR_SLDB >= CB2_W_6*2
  INT X1 < CB2_W_6 ABUT < 90 REGION
  INT X2 < CB2_W_6-GRID ABUT < 90 REGION
}
#ENDIF

#IFDEF WITH_POLYIMIDE
PM.R.3 { @ Polyimide is prohibited over outer seal ring and SLDB regions.
         @ It only covers inner seal ring area (6um/5.4um for N45/N40).
         @ Please see Fig. 2.5.1.1. (PM drawn pattern must cover outer seal ring and SLDB regions.)
  A = COPY CHIP_EDGE_a
#IFDEF HALF_NODE
  B = (SIZE A BY 5.4) NOT A
#ELSE
  B = (SIZE A BY 6) NOT A
#ENDIF
  (SEALRING_OUTER OR SEALRING_DB) NOT PMi
  (SEALRING_INNER OR B) AND PMi
}
#ENDIF

#ENDIF
#ENDIF
#ENDIF


// Seal-Ring Wall Layout Rule Check
//=====================
#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING

CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal ring and SLDB. == ^CO_W_2
  X1 = ANGLE SR_CO != 45
  X2 = ANGLE SR_CO == 45
  INT X1 > CO_W_2 < CO_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CO_W_2+GRID < CO_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_CO >= CO_W_2*2) ENCLOSE RECTANGLE 1 GRID
  INT X1 < CO_W_2 ABUT < 90 REGION
  INT X2 < CO_W_2-GRID ABUT < 90 REGION
}
#IFNDEF OLD_SEALRING
M1.W.4 { @ Width of M1 metal line in outer seal ring == ^M1_W_4
  X1 = ANGLE SR_M1_OUTER != 45
  X2 = ANGLE SR_M1_OUTER == 45
  INT X1 > M1_W_4 < M1_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_4+GRID < M1_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M1_OUTER >= M1_W_4*2
  INT X1 < M1_W_4 ABUT < 90 REGION
  INT X2 < M1_W_4-GRID ABUT < 90 REGION
}
M1.W.5 { @ Width of M1 metal line in inner seal ring == ^M1_W_5
  X1 = ANGLE SR_M1_INNER != 45
  X2 = ANGLE SR_M1_INNER == 45
  INT X1 > M1_W_5 < M1_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_5+GRID < M1_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M1_INNER >= M1_W_5*2
  INT X1 < M1_W_5 ABUT < 90 REGION
  INT X2 < M1_W_5-GRID ABUT < 90 REGION
}
M1.W.6 { @ Width of M1 metal line in SLDB == ^M1_W_6
  X1 = ANGLE SLDB_M1 != 45
  X2 = ANGLE SLDB_M1 == 45
  INT X1 > M1_W_6 < M1_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_6+GRID < M1_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M1 >= M1_W_6*2
  INT X1 < M1_W_6 ABUT < 90 REGION
  INT X2 < M1_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA1.W.2__VIA1.W.4 { @ Width of VIA1 bar of sealring/SLDB = ^VIA1_W_2
  X1 = ANGLE SR_VIA1_BAR != 45
  X2 = ANGLE SR_VIA1_BAR == 45
  INT X1 > VIA1_W_2 < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA1_W_2+GRID < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA1_BAR >= VIA1_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA1_W_2 ABUT < 90 REGION
  INT X2 < VIA1_W_2-GRID ABUT < 90 REGION
}
// VIA1.W.2 is checked by VIA1.W.2__VIA1.W.4
// VIA1.W.4 is checked by VIA1.W.2__VIA1.W.4
VIA1.W.3__VIA1.W.5 { @ Width of VIA1 hole of sealring/SLDB = ^VIA1_W_3
  NOT RECTANGLE SR_VIA1_HOLE == VIA1_W_3 BY == VIA1_W_3 ORTHOGONAL ONLY
}
// VIA1.W.3 is checked by VIA1.W.3__VIA1.W.5
// VIA1.W.5 is checked by VIA1.W.3__VIA1.W.5
#ELSE
VIA1.W.2 { @ Width of VIA1 bar of sealring = ^VIA1_W_2
  X1 = ANGLE SR_VIA1_BAR != 45
  X2 = ANGLE SR_VIA1_BAR == 45
  INT X1 > VIA1_W_2 < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA1_W_2+GRID < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA1_BAR >= VIA1_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA1_W_2 ABUT < 90 REGION
  INT X2 < VIA1_W_2-GRID ABUT < 90 REGION
}
VIA1.W.3 { @ Width of VIA1 hole of sealring = ^VIA1_W_3
  NOT RECTANGLE SR_VIA1_HOLE == VIA1_W_3 BY == VIA1_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA1.EN.5 { @ Enclosure of VIA1 bar by M1 of seal ring >= ^VIA1_EN_5
  ENC SR_VIA1_BAR_SR M1 < VIA1_EN_5 ABUT < 90 SINGULAR REGION
}
VIA1.EN.6 { @ Enclosure of VIA1 hole by M1 of seal ring >= ^VIA1_EN_6
  ENC SR_VIA1_HOLE_SR M1 < VIA1_EN_6 ABUT < 90 SINGULAR REGION
}
VIA1.EN.7 { @ Enclosure of VIA1 hole by M1 of SLDB >= ^VIA1_EN_7
  ENC SR_VIA1_HOLE_SLDB M1 < VIA1_EN_7 ABUT < 90 SINGULAR REGION
}
VIA1.S.4 { @ Space of VIA1 hole in seal ring. >= ^VIA1_S_4
  EXT SR_VIA1_HOLE_SR < VIA1_S_4 ABUT < 90 SINGULAR REGION
}
VIA1.S.5 { @ Space of VIA1 hole to VIAx bar in seal ring. >= ^VIA1_S_5
  EXT SR_VIA1_HOLE_SR SR_VIA1_BAR_SR < VIA1_S_5 ABUT < 90 SINGULAR REGION
}
VIA1.S.6 { @ Space of VIA1 hole in SLDB.>= ^VIA1_S_6
  EXT SR_VIA1_HOLE_SLDB < VIA1_S_6 ABUT < 90 SINGULAR REGION
}
VIA1.S.9 { @ Maximum space of VIAx hole [INSIDE SEALRING] DRC flags: {SEALRING AND Mx} must be fully covered by {{SEALRING AND VIAx holes} SIZING 6 um} <= 12
  A = SIZE SR_VIA1_HOLE BY 6
  SR_M1 NOT A
}
#ENDIF
#IFNDEF OLD_SEALRING
M2.W.4 { @ Width of M2 metal line in outer seal ring == ^M2_W_4
  X1 = ANGLE SR_M2_OUTER != 45
  X2 = ANGLE SR_M2_OUTER == 45
  INT X1 > M2_W_4 < M2_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_4+GRID < M2_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M2_OUTER >= M2_W_4*2
  INT X1 < M2_W_4 ABUT < 90 REGION
  INT X2 < M2_W_4-GRID ABUT < 90 REGION
}
M2.W.5 { @ Width of M2 metal line in inner seal ring == ^M2_W_5
  X1 = ANGLE SR_M2_INNER != 45
  X2 = ANGLE SR_M2_INNER == 45
  INT X1 > M2_W_5 < M2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_5+GRID < M2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M2_INNER >= M2_W_5*2
  INT X1 < M2_W_5 ABUT < 90 REGION
  INT X2 < M2_W_5-GRID ABUT < 90 REGION
}
M2.W.6 { @ Width of M2 metal line in SLDB == ^M2_W_6
  X1 = ANGLE SLDB_M2 != 45
  X2 = ANGLE SLDB_M2 == 45
  INT X1 > M2_W_6 < M2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_6+GRID < M2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M2 >= M2_W_6*2
  INT X1 < M2_W_6 ABUT < 90 REGION
  INT X2 < M2_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA2.W.2__VIA2.W.4 { @ Width of VIA2 bar of sealring/SLDB = ^VIA2_W_2
  X1 = ANGLE SR_VIA2_BAR != 45
  X2 = ANGLE SR_VIA2_BAR == 45
  INT X1 > VIA2_W_2 < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA2_W_2+GRID < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA2_BAR >= VIA2_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA2_W_2 ABUT < 90 REGION
  INT X2 < VIA2_W_2-GRID ABUT < 90 REGION
}
// VIA2.W.2 is checked by VIA2.W.2__VIA2.W.4
// VIA2.W.4 is checked by VIA2.W.2__VIA2.W.4
VIA2.W.3__VIA2.W.5 { @ Width of VIA2 hole of sealring/SLDB = ^VIA2_W_3
  NOT RECTANGLE SR_VIA2_HOLE == VIA2_W_3 BY == VIA2_W_3 ORTHOGONAL ONLY
}
// VIA2.W.3 is checked by VIA2.W.3__VIA2.W.5
// VIA2.W.5 is checked by VIA2.W.3__VIA2.W.5
#ELSE
VIA2.W.2 { @ Width of VIA2 bar of sealring = ^VIA2_W_2
  X1 = ANGLE SR_VIA2_BAR != 45
  X2 = ANGLE SR_VIA2_BAR == 45
  INT X1 > VIA2_W_2 < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA2_W_2+GRID < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA2_BAR >= VIA2_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA2_W_2 ABUT < 90 REGION
  INT X2 < VIA2_W_2-GRID ABUT < 90 REGION
}
VIA2.W.3 { @ Width of VIA2 hole of sealring = ^VIA2_W_3
  NOT RECTANGLE SR_VIA2_HOLE == VIA2_W_3 BY == VIA2_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA2.EN.5 { @ Enclosure of VIA2 bar by M2 of seal ring >= ^VIA2_EN_5
  ENC SR_VIA2_BAR_SR M2 < VIA2_EN_5 ABUT < 90 SINGULAR REGION
}
VIA2.EN.6 { @ Enclosure of VIA2 hole by M2 of seal ring >= ^VIA2_EN_6
  ENC SR_VIA2_HOLE_SR M2 < VIA2_EN_6 ABUT < 90 SINGULAR REGION
}
VIA2.EN.7 { @ Enclosure of VIA2 hole by M2 of SLDB >= ^VIA2_EN_7
  ENC SR_VIA2_HOLE_SLDB M2 < VIA2_EN_7 ABUT < 90 SINGULAR REGION
}
VIA2.S.4 { @ Space of VIA2 hole in seal ring. >= ^VIA2_S_4
  EXT SR_VIA2_HOLE_SR < VIA2_S_4 ABUT < 90 SINGULAR REGION
}
VIA2.S.5 { @ Space of VIA2 hole to VIAx bar in seal ring. >= ^VIA2_S_5
  EXT SR_VIA2_HOLE_SR SR_VIA2_BAR_SR < VIA2_S_5 ABUT < 90 SINGULAR REGION
}
VIA2.S.6 { @ Space of VIA2 hole in SLDB.>= ^VIA2_S_6
  EXT SR_VIA2_HOLE_SLDB < VIA2_S_6 ABUT < 90 SINGULAR REGION
}
VIA2.S.9 { @ Maximum space of VIAx hole [INSIDE SEALRING] DRC flags: {SEALRING AND Mx} must be fully covered by {{SEALRING AND VIAx holes} SIZING 6 um} <= 12
  A = SIZE SR_VIA2_HOLE BY 6
  SR_M2 NOT A
}
#ENDIF
#IFNDEF OLD_SEALRING
M3.W.4 { @ Width of M3 metal line in outer seal ring == ^M3_W_4
  X1 = ANGLE SR_M3_OUTER != 45
  X2 = ANGLE SR_M3_OUTER == 45
  INT X1 > M3_W_4 < M3_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_4+GRID < M3_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M3_OUTER >= M3_W_4*2
  INT X1 < M3_W_4 ABUT < 90 REGION
  INT X2 < M3_W_4-GRID ABUT < 90 REGION
}
M3.W.5 { @ Width of M3 metal line in inner seal ring == ^M3_W_5
  X1 = ANGLE SR_M3_INNER != 45
  X2 = ANGLE SR_M3_INNER == 45
  INT X1 > M3_W_5 < M3_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_5+GRID < M3_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M3_INNER >= M3_W_5*2
  INT X1 < M3_W_5 ABUT < 90 REGION
  INT X2 < M3_W_5-GRID ABUT < 90 REGION
}
M3.W.6 { @ Width of M3 metal line in SLDB == ^M3_W_6
  X1 = ANGLE SLDB_M3 != 45
  X2 = ANGLE SLDB_M3 == 45
  INT X1 > M3_W_6 < M3_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_6+GRID < M3_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M3 >= M3_W_6*2
  INT X1 < M3_W_6 ABUT < 90 REGION
  INT X2 < M3_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA3.W.2__VIA3.W.4 { @ Width of VIA3 bar of sealring/SLDB = ^VIA3_W_2
  X1 = ANGLE SR_VIA3_BAR != 45
  X2 = ANGLE SR_VIA3_BAR == 45
  INT X1 > VIA3_W_2 < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA3_W_2+GRID < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA3_BAR >= VIA3_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA3_W_2 ABUT < 90 REGION
  INT X2 < VIA3_W_2-GRID ABUT < 90 REGION
}
// VIA3.W.2 is checked by VIA3.W.2__VIA3.W.4
// VIA3.W.4 is checked by VIA3.W.2__VIA3.W.4
VIA3.W.3__VIA3.W.5 { @ Width of VIA3 hole of sealring/SLDB = ^VIA3_W_3
  NOT RECTANGLE SR_VIA3_HOLE == VIA3_W_3 BY == VIA3_W_3 ORTHOGONAL ONLY
}
// VIA3.W.3 is checked by VIA3.W.3__VIA3.W.5
// VIA3.W.5 is checked by VIA3.W.3__VIA3.W.5
#ELSE
VIA3.W.2 { @ Width of VIA3 bar of sealring = ^VIA3_W_2
  X1 = ANGLE SR_VIA3_BAR != 45
  X2 = ANGLE SR_VIA3_BAR == 45
  INT X1 > VIA3_W_2 < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA3_W_2+GRID < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA3_BAR >= VIA3_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA3_W_2 ABUT < 90 REGION
  INT X2 < VIA3_W_2-GRID ABUT < 90 REGION
}
VIA3.W.3 { @ Width of VIA3 hole of sealring = ^VIA3_W_3
  NOT RECTANGLE SR_VIA3_HOLE == VIA3_W_3 BY == VIA3_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA3.EN.5 { @ Enclosure of VIA3 bar by M3 of seal ring >= ^VIA3_EN_5
  ENC SR_VIA3_BAR_SR M3 < VIA3_EN_5 ABUT < 90 SINGULAR REGION
}
VIA3.EN.6 { @ Enclosure of VIA3 hole by M3 of seal ring >= ^VIA3_EN_6
  ENC SR_VIA3_HOLE_SR M3 < VIA3_EN_6 ABUT < 90 SINGULAR REGION
}
VIA3.EN.7 { @ Enclosure of VIA3 hole by M3 of SLDB >= ^VIA3_EN_7
  ENC SR_VIA3_HOLE_SLDB M3 < VIA3_EN_7 ABUT < 90 SINGULAR REGION
}
VIA3.S.4 { @ Space of VIA3 hole in seal ring. >= ^VIA3_S_4
  EXT SR_VIA3_HOLE_SR < VIA3_S_4 ABUT < 90 SINGULAR REGION
}
VIA3.S.5 { @ Space of VIA3 hole to VIAx bar in seal ring. >= ^VIA3_S_5
  EXT SR_VIA3_HOLE_SR SR_VIA3_BAR_SR < VIA3_S_5 ABUT < 90 SINGULAR REGION
}
VIA3.S.6 { @ Space of VIA3 hole in SLDB.>= ^VIA3_S_6
  EXT SR_VIA3_HOLE_SLDB < VIA3_S_6 ABUT < 90 SINGULAR REGION
}
VIA3.S.9 { @ Maximum space of VIAx hole [INSIDE SEALRING] DRC flags: {SEALRING AND Mx} must be fully covered by {{SEALRING AND VIAx holes} SIZING 6 um} <= 12
  A = SIZE SR_VIA3_HOLE BY 6
  SR_M3 NOT A
}
#ENDIF
#IFNDEF OLD_SEALRING
M4.W.4 { @ Width of M4 metal line in outer seal ring == ^M4_W_4
  X1 = ANGLE SR_M4_OUTER != 45
  X2 = ANGLE SR_M4_OUTER == 45
  INT X1 > M4_W_4 < M4_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_4+GRID < M4_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M4_OUTER >= M4_W_4*2
  INT X1 < M4_W_4 ABUT < 90 REGION
  INT X2 < M4_W_4-GRID ABUT < 90 REGION
}
M4.W.5 { @ Width of M4 metal line in inner seal ring == ^M4_W_5
  X1 = ANGLE SR_M4_INNER != 45
  X2 = ANGLE SR_M4_INNER == 45
  INT X1 > M4_W_5 < M4_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_5+GRID < M4_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M4_INNER >= M4_W_5*2
  INT X1 < M4_W_5 ABUT < 90 REGION
  INT X2 < M4_W_5-GRID ABUT < 90 REGION
}
M4.W.6 { @ Width of M4 metal line in SLDB == ^M4_W_6
  X1 = ANGLE SLDB_M4 != 45
  X2 = ANGLE SLDB_M4 == 45
  INT X1 > M4_W_6 < M4_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_6+GRID < M4_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M4 >= M4_W_6*2
  INT X1 < M4_W_6 ABUT < 90 REGION
  INT X2 < M4_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA4.W.2__VIA4.W.4 { @ Width of VIA4 bar of sealring/SLDB = ^VIA4_W_2
  X1 = ANGLE SR_VIA4_BAR != 45
  X2 = ANGLE SR_VIA4_BAR == 45
  INT X1 > VIA4_W_2 < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA4_W_2+GRID < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA4_BAR >= VIA4_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA4_W_2 ABUT < 90 REGION
  INT X2 < VIA4_W_2-GRID ABUT < 90 REGION
}
// VIA4.W.2 is checked by VIA4.W.2__VIA4.W.4
// VIA4.W.4 is checked by VIA4.W.2__VIA4.W.4
VIA4.W.3__VIA4.W.5 { @ Width of VIA4 hole of sealring/SLDB = ^VIA4_W_3
  NOT RECTANGLE SR_VIA4_HOLE == VIA4_W_3 BY == VIA4_W_3 ORTHOGONAL ONLY
}
// VIA4.W.3 is checked by VIA4.W.3__VIA4.W.5
// VIA4.W.5 is checked by VIA4.W.3__VIA4.W.5
#ELSE
VIA4.W.2 { @ Width of VIA4 bar of sealring = ^VIA4_W_2
  X1 = ANGLE SR_VIA4_BAR != 45
  X2 = ANGLE SR_VIA4_BAR == 45
  INT X1 > VIA4_W_2 < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA4_W_2+GRID < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA4_BAR >= VIA4_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA4_W_2 ABUT < 90 REGION
  INT X2 < VIA4_W_2-GRID ABUT < 90 REGION
}
VIA4.W.3 { @ Width of VIA4 hole of sealring = ^VIA4_W_3
  NOT RECTANGLE SR_VIA4_HOLE == VIA4_W_3 BY == VIA4_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA4.EN.5 { @ Enclosure of VIA4 bar by M4 of seal ring >= ^VIA4_EN_5
  ENC SR_VIA4_BAR_SR M4 < VIA4_EN_5 ABUT < 90 SINGULAR REGION
}
VIA4.EN.6 { @ Enclosure of VIA4 hole by M4 of seal ring >= ^VIA4_EN_6
  ENC SR_VIA4_HOLE_SR M4 < VIA4_EN_6 ABUT < 90 SINGULAR REGION
}
VIA4.EN.7 { @ Enclosure of VIA4 hole by M4 of SLDB >= ^VIA4_EN_7
  ENC SR_VIA4_HOLE_SLDB M4 < VIA4_EN_7 ABUT < 90 SINGULAR REGION
}
VIA4.S.4 { @ Space of VIA4 hole in seal ring. >= ^VIA4_S_4
  EXT SR_VIA4_HOLE_SR < VIA4_S_4 ABUT < 90 SINGULAR REGION
}
VIA4.S.5 { @ Space of VIA4 hole to VIAx bar in seal ring. >= ^VIA4_S_5
  EXT SR_VIA4_HOLE_SR SR_VIA4_BAR_SR < VIA4_S_5 ABUT < 90 SINGULAR REGION
}
VIA4.S.6 { @ Space of VIA4 hole in SLDB.>= ^VIA4_S_6
  EXT SR_VIA4_HOLE_SLDB < VIA4_S_6 ABUT < 90 SINGULAR REGION
}
VIA4.S.9 { @ Maximum space of VIAx hole [INSIDE SEALRING] DRC flags: {SEALRING AND Mx} must be fully covered by {{SEALRING AND VIAx holes} SIZING 6 um} <= 12
  A = SIZE SR_VIA4_HOLE BY 6
  SR_M4 NOT A
}
#ENDIF
#IFNDEF OLD_SEALRING
M5.W.4 { @ Width of M5 metal line in outer seal ring == ^M5_W_4
  X1 = ANGLE SR_M5_OUTER != 45
  X2 = ANGLE SR_M5_OUTER == 45
  INT X1 > M5_W_4 < M5_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_4+GRID < M5_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M5_OUTER >= M5_W_4*2
  INT X1 < M5_W_4 ABUT < 90 REGION
  INT X2 < M5_W_4-GRID ABUT < 90 REGION
}
M5.W.5 { @ Width of M5 metal line in inner seal ring == ^M5_W_5
  X1 = ANGLE SR_M5_INNER != 45
  X2 = ANGLE SR_M5_INNER == 45
  INT X1 > M5_W_5 < M5_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_5+GRID < M5_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M5_INNER >= M5_W_5*2
  INT X1 < M5_W_5 ABUT < 90 REGION
  INT X2 < M5_W_5-GRID ABUT < 90 REGION
}
M5.W.6 { @ Width of M5 metal line in SLDB == ^M5_W_6
  X1 = ANGLE SLDB_M5 != 45
  X2 = ANGLE SLDB_M5 == 45
  INT X1 > M5_W_6 < M5_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_6+GRID < M5_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M5 >= M5_W_6*2
  INT X1 < M5_W_6 ABUT < 90 REGION
  INT X2 < M5_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA5.W.2__VIA5.W.4 { @ Width of VIA5 bar of sealring/SLDB = ^VIA5_W_2
  X1 = ANGLE SR_VIA5_BAR != 45
  X2 = ANGLE SR_VIA5_BAR == 45
  INT X1 > VIA5_W_2 < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA5_W_2+GRID < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA5_BAR >= VIA5_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA5_W_2 ABUT < 90 REGION
  INT X2 < VIA5_W_2-GRID ABUT < 90 REGION
}
// VIA5.W.2 is checked by VIA5.W.2__VIA5.W.4
// VIA5.W.4 is checked by VIA5.W.2__VIA5.W.4
VIA5.W.3__VIA5.W.5 { @ Width of VIA5 hole of sealring/SLDB = ^VIA5_W_3
  NOT RECTANGLE SR_VIA5_HOLE == VIA5_W_3 BY == VIA5_W_3 ORTHOGONAL ONLY
}
// VIA5.W.3 is checked by VIA5.W.3__VIA5.W.5
// VIA5.W.5 is checked by VIA5.W.3__VIA5.W.5
#ELSE
VIA5.W.2 { @ Width of VIA5 bar of outer sealring = ^VIA5_W_2_P3
  X1 = ANGLE SR_VIA5_BAR_OUTER != 45
  X2 = ANGLE SR_VIA5_BAR_OUTER == 45
  INT X1 > VIA5_W_2_P3 < VIA5_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA5_W_2_P3+2*GRID < VIA5_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA5_BAR_OUTER >= VIA5_W_2_P3*2
  INT X1 < VIA5_W_2_P3 ABUT < 90 REGION
  INT X2 < VIA5_W_2_P3-2*GRID ABUT < 90 REGION
}
VIA5.W.3 { @ Width of VIA5 bar of inner sealring = ^VIA5_W_3_P3
  X1 = ANGLE SR_VIA5_BAR_INNER != 45
  X2 = ANGLE SR_VIA5_BAR_INNER == 45
  INT X1 > VIA5_W_3_P3 < VIA5_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA5_W_3_P3+2*GRID < VIA5_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA5_BAR_INNER >= VIA5_W_3_P3*2
  INT X1 < VIA5_W_3_P3 ABUT < 90 REGION
  INT X2 < VIA5_W_3_P3-2*GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA5.EN.5 { @ Enclosure of VIA5 bar by M5 of seal ring >= ^VIA5_EN_5
  ENC SR_VIA5_BAR_SR M5 < VIA5_EN_5 ABUT < 90 SINGULAR REGION
}
VIA5.EN.6 { @ Enclosure of VIA5 hole by M5 of seal ring >= ^VIA5_EN_6
  ENC SR_VIA5_HOLE_SR M5 < VIA5_EN_6 ABUT < 90 SINGULAR REGION
}
VIA5.S.4 { @ Space of VIA5 hole in seal ring. >= ^VIA5_S_4
  EXT SR_VIA5_HOLE_SR < VIA5_S_4 ABUT < 90 SINGULAR REGION
}
VIA5.S.5 { @ Space of VIA5 hole to VIAx bar in seal ring. >= ^VIA5_S_5
  EXT SR_VIA5_HOLE_SR SR_VIA5_BAR_SR < VIA5_S_5 ABUT < 90 SINGULAR REGION
}
VIA5.S.6 { @ Space of VIA5 hole in SLDB.>= ^VIA5_S_6
  EXT SR_VIA5_HOLE_SLDB < VIA5_S_6 ABUT < 90 SINGULAR REGION
}
VIA5.S.7 { @ Space of VIA5 hole to VIA5 bar in SLDB. >= ^VIA5_S_7
  EXT SR_VIA5_HOLE_SLDB SR_VIA5_BAR_SLDB < VIA5_S_7 ABUT < 90 SINGULAR REGION
}
VIA5.S.8 { @ Maximum space of VIAy/z/r/u hole [INSIDE SEALRING] DRC flags: {SEALRING AND My/z/r/u} must be fully covered by {{SEALRING AND VIAy/z/r/u holes} SIZING 6 um} <= 12
  A = SIZE SR_VIA5_HOLE BY 6
  SR_M5 NOT A
}
#ENDIF
#IFNDEF OLD_SEALRING
M6.W.4 { @ Width of M6 metal line in outer seal ring == ^M6_W_4
  X1 = ANGLE SR_M6_OUTER != 45
  X2 = ANGLE SR_M6_OUTER == 45
  INT X1 > M6_W_4 < M6_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_4+GRID < M6_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M6_OUTER >= M6_W_4*2
  INT X1 < M6_W_4 ABUT < 90 REGION
  INT X2 < M6_W_4-GRID ABUT < 90 REGION
}
M6.W.5 { @ Width of M6 metal line in inner seal ring == ^M6_W_5
  X1 = ANGLE SR_M6_INNER != 45
  X2 = ANGLE SR_M6_INNER == 45
  INT X1 > M6_W_5 < M6_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_5+GRID < M6_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M6_INNER >= M6_W_5*2
  INT X1 < M6_W_5 ABUT < 90 REGION
  INT X2 < M6_W_5-GRID ABUT < 90 REGION
}
M6.W.6 { @ Width of M6 metal line in SLDB == ^M6_W_6
  X1 = ANGLE SLDB_M6 != 45
  X2 = ANGLE SLDB_M6 == 45
  INT X1 > M6_W_6 < M6_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_6+4*GRID < M6_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M6 >= M6_W_6*2
  INT X1 < M6_W_6 ABUT < 90 REGION
  INT X2 < M6_W_6-4*GRID ABUT < 90 REGION
}
#ENDIF

//CDU CHECKS
//===================

#IFNDEF OLD_SEALRING
CDU.R.1 { @ CDUDMY must be inside the assembly isolation beside seal ring.
  CDUDMY NOT INSIDE ISO_REGION
}
CDU.R.2 { @ OD/POLY/NPi/CO/M1/VIAx/Mx must be inside layer CDUDMY.
  CDUDMY NOT ENCLOSE ODi
  CDUDMY NOT ENCLOSE POi
  CDUDMY NOT ENCLOSE NPi
  CDUDMY NOT ENCLOSE COi
  CDUDMY NOT ENCLOSE M1i
  CDUDMY NOT ENCLOSE VIA1i
  CDUDMY NOT ENCLOSE M2i
  CDUDMY NOT ENCLOSE VIA2i
  CDUDMY NOT ENCLOSE M3i
  CDUDMY NOT ENCLOSE VIA3i
  CDUDMY NOT ENCLOSE M4i
  CDUDMY NOT ENCLOSE VIA4i
  CDUDMY NOT ENCLOSE M5i
}
#ENDIF

#ENDIF
#ENDIF

// ICOVL.R.1 is checked by OD.W.2.2
// ICOVL.R.1 is checked by PO.DN.3
// ICOVL.R.1 is checked by PO.R.1
// ICOVL.R.1 is checked by CO.W.1
// ICOVL.R.1 is checked by RPO.S.4

#IFDEF FRONT_END


// Latch-Up CHECKS
//================
#IFDEF DISCONNECT_ALL_RESISTOR
NWRiu = NWRiT NOT EMPTYi
NSTPiu = NSTPi NOT EMPTYi
PSTPiu = PSTPi NOT EMPTYi

NSDiu  = NSDc  NOT EMPTYi
PSDiu  = PSDc  NOT EMPTYi
PADiu  = PADi  NOT EMPTYi 
PWR_M1iu_BY_TEXT = M1i WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1i WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1i WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2i WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2i WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2i WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3i WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3i WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3i WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4i WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4i WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4i WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5i WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5i WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5i WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6i WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6i WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6i WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APi WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APi WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APi WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
#IFDEF CONNECT_ALL_RESISTOR
NWRiu = NWRuT NOT EMPTYi
NSTPiu = NSTPu NOT EMPTYi
PSTPiu = PSTPu NOT EMPTYi
NSDiu  = NSDu  NOT EMPTYi
PSDiu  = PSDu  NOT EMPTYi
PADiu  = PADu  NOT EMPTYi 
PWR_M1iu_BY_TEXT = M1u WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1u WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2u WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2u WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3u WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3u WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4u WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4u WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5u WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5u WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6u WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6u WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APu WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APu WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APu WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
NWRiu  = NWRjT NOT EMPTYi
NSTPiu = NSTPj NOT EMPTYi
PSTPiu = PSTPj NOT EMPTYi
NSDiu  = NSDj  NOT EMPTYi
PSDiu  = PSDj  NOT EMPTYi
PADiu  = PADj  NOT EMPTYi 
PWR_M1iu_BY_TEXT = M1j WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1j WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1j WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2j WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2j WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2j WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3j WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3j WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3j WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4j WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4j WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4j WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5j WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5j WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5j WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6j WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6j WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6j WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APj WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APj WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APj WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ENDIF
#ENDIF


MOS = DACT INTERACT GATE
G_DIODE   = MOS INTERACT ((GATE INTERACT PP) INTERACT NP)

// Power PAD
NSTPux = (NSTPi NOT INTERACT RNWEL) NOT VAR
PSTPux = PSTPi NOT VAR

VDD_PAD = NET AREA RATIO PADi NSTPux > 0
VSS_PAD = NET AREA RATIO PADi PSTPux > 0
VDD_PAD_BY_DUMMY = PADi NOT OUTSIDE VDDDMY
VSS_PAD_BY_DUMMY = PADi NOT OUTSIDE VSSDMY

// Signal PAD
IO_PAD = (((PADiu NOT VDD_PAD) NOT VSS_PAD) NOT VDD_PAD_BY_DUMMY) NOT VSS_PAD_BY_DUMMY


PSD_PAD = NET AREA RATIO PSDiu PADiu > 0
NSD_PAD = NET AREA RATIO NSDiu PADiu > 0
PSD_IOPAD_stp = NET AREA RATIO PSDiu IO_PAD > 0
NSD_IOPAD_stp = NET AREA RATIO NSDiu IO_PAD > 0
NWR_IOPAD_stp = NET AREA RATIO NWRiu IO_PAD > 0



#IFDEF  DEFINE_PAD_BY_TEXT
PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
NWR_PAD_TEXT = NET AREA RATIO NWRiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0
NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0
NWR_VDD_VSS_PAD_TEXT = NET AREA RATIO NWRiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0 
PSD_IOPAD = PSDiu INTERACT ((PSD_IOPAD_stp OR PSD_PAD_TEXT) NOT PSD_VDD_VSS_PAD_TEXT)
NSD_IOPAD = NSDiu INTERACT ((NSD_IOPAD_stp OR NSD_PAD_TEXT) NOT NSD_VDD_VSS_PAD_TEXT)

NWR_IOPAD = NWRiu INTERACT ((NWR_IOPAD_stp OR NWR_PAD_TEXT) NOT NWR_VDD_VSS_PAD_TEXT)
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ELSE
PSD_IOPAD = (PSDiu INTERACT PSD_IOPAD_stp) NOT (NET AREA RATIO PSDc OVER VDD_PAD VSS_PAD VDD_PAD_BY_DUMMY VSS_PAD_BY_DUMMY > 0)
NSD_IOPAD = (NSDiu INTERACT NSD_IOPAD_stp) NOT (NET AREA RATIO NSDc OVER VDD_PAD VSS_PAD VDD_PAD_BY_DUMMY VSS_PAD_BY_DUMMY > 0)
NWR_IOPAD = NWRiu INTERACT NWR_IOPAD_stp
MOS_filter_DMY = CHIP INTERACT (VDDDMY OR VSSDMY)
PMOS_filter = (MOS INTERACT PSD_PAD == 1 BY NET) NOT MOS_filter_DMY
NMOS_filter = (MOS INTERACT NSD_PAD == 1 BY NET) NOT MOS_filter_DMY
#ENDIF



SD_IOPAD = PSD_IOPAD OR NSD_IOPAD
DUMMY_MOS = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
DUMMY_DIODE = (DACT NOT INTERACT POLY) NOT INTERACT CO
DACT_real = (DACT NOT DUMMY_MOS) NOT DUMMY_DIODE
PACT_real = PACT AND DACT_real
NACT_real = NACT AND DACT_real

// ESD device [connected to Signal PAD but not connected to one PAD only]
POST_DRIVER_ACT = ((((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD) OR (OD INTERACT NWR_IOPAD)) NOT INSIDE LUPWDMY
// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_inside_guard_ring_pre1 = NWi NOT NSTPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2
PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2
NTAP_guard_ring_hole = ((HOLES NSTPi INNER) INSIDE NWi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PSTPi INNER) INSIDE PWELi) OR PW_inside_guard_ring

// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = ((POST_DRIVER_ACT INTERACT NSDiu) OR (OD INTERACT NWR_IOPAD)) NOT INSIDE LUPWDMY
// For LUP.3
//==================
POST_DRIVER_PMOS = POST_DRIVER_PACT INTERACT GATE
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL
POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT OD2
POST_DRIVER_PMOS_NW_5V = POST_DRIVER_PMOS_NW_HV INTERACT HVD_P
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_PMOS_NW_25V = (POST_DRIVER_PMOS_NW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
POST_DRIVER_PMOS_NW_18V = (POST_DRIVER_PMOS_NW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV
POST_DRIVER_NMOS = POST_DRIVER_NACT INTERACT GATE
POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT OD2
POST_DRIVER_NMOS_RW_5V  = POST_DRIVER_NMOS_RW_HV INTERACT (HVD_N OR DEHVD_N)
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_NMOS_RW_25V = (POST_DRIVER_NMOS_RW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR (HVD_N OR DEHVD_N))
POST_DRIVER_NMOS_RW_18V = (POST_DRIVER_NMOS_RW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_N
POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT OD2
POST_DRIVER_NMOS_PW_5V  = POST_DRIVER_NMOS_PW_HV INTERACT (HVD_N OR DEHVD_N)
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_NMOS_PW_25V = (POST_DRIVER_NMOS_PW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR (HVD_N OR DEHVD_N)) 
POST_DRIVER_NMOS_PW_18V = (POST_DRIVER_NMOS_PW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_N
POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV

POST_DRIVER_PINJ = COPY POST_DRIVER_PACT 
POST_DRIVER_PINJ_NW = STAMP POST_DRIVER_PINJ BY NWEL
POST_DRIVER_PINJ_NW_HV  = POST_DRIVER_PINJ_NW INTERACT OD2
POST_DRIVER_PINJ_NW_5V = POST_DRIVER_PINJ_NW_HV INTERACT HVD_P
POST_DRIVER_PINJ_NW_33V = POST_DRIVER_PINJ_NW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_PINJ_NW_25V = (POST_DRIVER_PINJ_NW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
POST_DRIVER_PINJ_NW_18V = (POST_DRIVER_PINJ_NW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
POST_DRIVER_PINJ_NW_LV  = POST_DRIVER_PINJ_NW NOT POST_DRIVER_PINJ_NW_HV
POST_DRIVER_NINJ = COPY POST_DRIVER_NACT 
POST_DRIVER_NINJ_RW = STAMP (POST_DRIVER_NINJ INSIDE DNW) BY DNW
POST_DRIVER_NINJ_RW_HV  = POST_DRIVER_NINJ_RW INTERACT OD2
POST_DRIVER_NINJ_RW_5V = POST_DRIVER_NINJ_RW_HV INTERACT (HVD_N OR DEHVD_N)
POST_DRIVER_NINJ_RW_33V = POST_DRIVER_NINJ_RW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_NINJ_RW_25V = (POST_DRIVER_NINJ_RW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR (HVD_N OR DEHVD_N)) 
POST_DRIVER_NINJ_RW_18V = (POST_DRIVER_NINJ_RW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_N
POST_DRIVER_NINJ_RW_LV  = POST_DRIVER_NINJ_RW NOT POST_DRIVER_NINJ_RW_HV
POST_DRIVER_NINJ_PW = POST_DRIVER_NINJ NOT POST_DRIVER_NINJ_RW
POST_DRIVER_NINJ_PW_HV  = POST_DRIVER_NINJ_PW INTERACT OD2
POST_DRIVER_NINJ_PW_5V = POST_DRIVER_NINJ_PW_HV INTERACT (HVD_N OR DEHVD_N)
POST_DRIVER_NINJ_PW_33V = POST_DRIVER_NINJ_PW_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_NINJ_PW_25V = (POST_DRIVER_NINJ_PW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR (HVD_N OR DEHVD_N)) 
POST_DRIVER_NINJ_PW_18V = (POST_DRIVER_NINJ_PW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_N
POST_DRIVER_NINJ_PW_LV  = POST_DRIVER_NINJ_PW NOT POST_DRIVER_NINJ_PW_HV

POST_DRIVER_NINJ_PW_NG = POST_DRIVER_NINJ_PW NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NINJ_RW_NG = POST_DRIVER_NINJ_RW NOT INSIDE PTAP_guard_ring_wide_hole

// For LUP.2 - Peripheral N/P MOS
//=================================
BESIDE_POST_DRIVER = SIZE POST_DRIVER_ACT BY LUP_2
BESIDE_POST_DRIVER_NMOS = ((NACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NMOS
BESIDE_POST_DRIVER_PMOS = ((PACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PMOS


// For LUP.3/LUP.5 - Wide GuardRing
//====================================
PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
PTAP_guard_ring_wide = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W
NTAP_guard_ring_wide = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W

PW_inside_guard_ring_wide_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide
PW_inside_guard_ring_wide = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide_pre
NW_inside_guard_ring_wide_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide
NW_inside_guard_ring_wide = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide_pre

PTAP_guard_ring_wide_hole = ((HOLES PTAP_guard_ring_wide INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide
NTAP_guard_ring_wide_hole = ((HOLES NTAP_guard_ring_wide INNER) INSIDE NWi) OR NW_inside_guard_ring_wide

POST_DRIVER_PMOS_NW_NG     = POST_DRIVER_PMOS_NW     NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_5V_NG  = POST_DRIVER_PMOS_NW_5V  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_33V_NG = POST_DRIVER_PMOS_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_25V_NG = POST_DRIVER_PMOS_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_18V_NG = POST_DRIVER_PMOS_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_LV_NG  = POST_DRIVER_PMOS_NW_LV  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_NG     = POST_DRIVER_NMOS_RW     NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_NG     = POST_DRIVER_NMOS_PW     NOT INSIDE PTAP_guard_ring_wide_hole




POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWi
POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT OD2
POST_DRIVER_PMOS_NWi_5V  = POST_DRIVER_PMOS_NWi_HV INTERACT HVD_P
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_PMOS_NWi_25V = (POST_DRIVER_PMOS_NWi_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
POST_DRIVER_PMOS_NWi_18V = (POST_DRIVER_PMOS_NWi_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
DNWc = STAMP DNW BY NWi
POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNWc

POST_DRIVER_PMOS_NWi_NG     = POST_DRIVER_PMOS_NWi     NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_5V_NG  = POST_DRIVER_PMOS_NWi_5V  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_33V_NG = POST_DRIVER_PMOS_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_25V_NG = POST_DRIVER_PMOS_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_18V_NG = POST_DRIVER_PMOS_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_LV_NG  = POST_DRIVER_PMOS_NWi_LV  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_NG     = POST_DRIVER_NMOS_RWi     NOT INSIDE PTAP_guard_ring_wide_hole


// For LUP.5
//==================
BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL
BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW
BESIDE_POST_DRIVER_PMOS_NW_HV  = BESIDE_POST_DRIVER_PMOS_NW INTERACT OD2
BESIDE_POST_DRIVER_PMOS_NW_5V  = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT HVD_P
BESIDE_POST_DRIVER_PMOS_NW_33V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT (OD33 OR OD2533)
BESIDE_POST_DRIVER_PMOS_NW_25V = (BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
BESIDE_POST_DRIVER_PMOS_NW_18V = (BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
BESIDE_POST_DRIVER_PMOS_NW_LV  = BESIDE_POST_DRIVER_PMOS_NW NOT BESIDE_POST_DRIVER_PMOS_NW_HV

BESIDE_POST_DRIVER_PMOS_NW_NG = BESIDE_POST_DRIVER_PMOS_NW NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_NG = BESIDE_POST_DRIVER_NMOS_RW NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_NG = BESIDE_POST_DRIVER_NMOS_PW NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_5V_NG  = BESIDE_POST_DRIVER_PMOS_NW_5V  NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_33V_NG = BESIDE_POST_DRIVER_PMOS_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_25V_NG = BESIDE_POST_DRIVER_PMOS_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_18V_NG = BESIDE_POST_DRIVER_PMOS_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_LV_NG  = BESIDE_POST_DRIVER_PMOS_NW_LV  NOT INSIDE NTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWi
BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNWc
BESIDE_POST_DRIVER_PMOS_NWi_HV  = BESIDE_POST_DRIVER_PMOS_NWi INTERACT OD2
BESIDE_POST_DRIVER_PMOS_NWi_5V  = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT HVD_P
BESIDE_POST_DRIVER_PMOS_NWi_33V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT (OD33 OR OD2533)
BESIDE_POST_DRIVER_PMOS_NWi_25V = (BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
BESIDE_POST_DRIVER_PMOS_NWi_18V = (BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
BESIDE_POST_DRIVER_PMOS_NWi_LV  = BESIDE_POST_DRIVER_PMOS_NWi NOT BESIDE_POST_DRIVER_PMOS_NWi_HV

BESIDE_POST_DRIVER_PMOS_NWi_NG = BESIDE_POST_DRIVER_PMOS_NWi NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_NG = BESIDE_POST_DRIVER_NMOS_RWi NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_5V_NG  = BESIDE_POST_DRIVER_PMOS_NWi_5V  NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_33V_NG = BESIDE_POST_DRIVER_PMOS_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_25V_NG = BESIDE_POST_DRIVER_PMOS_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_18V_NG = BESIDE_POST_DRIVER_PMOS_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_LV_NG  = BESIDE_POST_DRIVER_PMOS_NWi_LV  NOT INSIDE NTAP_guard_ring_wide_hole

POST_DRIVER_PINJ_NW_5V_NG  = POST_DRIVER_PINJ_NW_5V  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NW_33V_NG = POST_DRIVER_PINJ_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NW_25V_NG = POST_DRIVER_PINJ_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NW_18V_NG = POST_DRIVER_PINJ_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NW_LV_NG  = POST_DRIVER_PINJ_NW_LV  NOT INSIDE NTAP_guard_ring_wide_hole

POST_DRIVER_PINJ_NWi = STAMP POST_DRIVER_PINJ BY NWi
POST_DRIVER_PINJ_NWi_HV  = POST_DRIVER_PINJ_NWi INTERACT OD2
POST_DRIVER_PINJ_NWi_5V  = POST_DRIVER_PINJ_NWi_HV INTERACT HVD_P
POST_DRIVER_PINJ_NWi_33V = POST_DRIVER_PINJ_NWi_HV INTERACT (OD33 OR OD2533)
POST_DRIVER_PINJ_NWi_25V = (POST_DRIVER_PINJ_NWi_HV INTERACT OD25) NOT INTERACT ((OD2533 OR OD2518) OR HVD_P)
POST_DRIVER_PINJ_NWi_18V = (POST_DRIVER_PINJ_NWi_HV INTERACT (OD18 OR OD2518)) NOT INTERACT HVD_P
POST_DRIVER_PINJ_NWi_LV  = POST_DRIVER_PINJ_NWi NOT POST_DRIVER_PINJ_NWi_HV
POST_DRIVER_NINJ_RWi = STAMP (POST_DRIVER_NINJ INSIDE DNW) BY DNWc

POST_DRIVER_PINJ_NWi_5V_NG  = POST_DRIVER_PINJ_NWi_5V  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NWi_33V_NG = POST_DRIVER_PINJ_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NWi_25V_NG = POST_DRIVER_PINJ_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NWi_18V_NG = POST_DRIVER_PINJ_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PINJ_NWi_LV_NG  = POST_DRIVER_PINJ_NWi_LV  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_NINJ_RWi_NG  = POST_DRIVER_NINJ_RWi  NOT INSIDE PTAP_guard_ring_wide_hole

LUP.1 { @ Any N+ OD injector or an N+ OD injector cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
        @ Any P+ OD injector or a P+ OD injector cluster connected to an I/O pad must be surrounded by a N+ guard-ring.
  POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole
  POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole
}

LUP.2 { @ Within ^LUP_2 um space from the OD injector, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster.
  X = BESIDE_POST_DRIVER_NMOS_RW INTERACT (DNW INTERACT ((NWEL INTERACT (DNW INTERACT BESIDE_POST_DRIVER_NMOS_RW)) INTERACT POST_DRIVER_PMOS_NW))
  Y = EXT POST_DRIVER_PMOS_NWi [BESIDE_POST_DRIVER_NMOS_RWi] < LUP_2 ABUT < 90 SINGULAR NOT CONNECTED
  BESIDE_POST_DRIVER_NMOS_waive = (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT X) NOT WITH EDGE Y
  (BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_waive) NOT INSIDE PTAP_guard_ring_hole
  BESIDE_POST_DRIVER_PMOS NOT INSIDE NTAP_guard_ring_hole
}


// LUP.3.0 is checked by related rules.

// LUP.3.1.0 is checked by related rules.

LUP.3.1.1 { @ For the N/PMOS which connects to an IO pad, space between the NMOS and the core PMOS >= ^LUP_3_1_1 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_LV < LUP_3_1_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

LUP.3.1.2 { @ For the N/PMOS which connects to an IO pad, space between the NMOS and the PMOS >= ^LUP_3_1_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi_NG POST_DRIVER_PMOS_NWi_LV < LUP_3_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.3.2.0 is checked by related rules.

LUP.3.2.1 { @ For the N/PMOS which connects to an I/O pad, space between the 1.8V/1.5V PMOS and the NMOS >= ^LUP_3_2_1 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR CONNECTED //REGION 
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_18V < LUP_3_2_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION 
}
LUP.3.2.2 { @ For the N/PMOS which connects to an I/O pad, space between the 1.8V/1.5V PMOS and the NMOS >= ^LUP_3_2_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi_NG POST_DRIVER_PMOS_NWi_18V < LUP_3_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.3.3.0 is checked by related rules.

LUP.3.3.1 { @ For the N/PMOS which connects to an I/O pad, space between the 2.5V PMOS and the NMOS >= ^LUP_3_3_1 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_25V < LUP_3_3_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION 
}
LUP.3.3.2 { @ For the N/PMOS which connects to an I/O pad, space between the 2.5V PMOS and the NMOS >= ^LUP_3_3_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR CONNECTED //REGION 
  EXT POST_DRIVER_NMOS_RWi_NG POST_DRIVER_PMOS_NWi_25V < LUP_3_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR CONNECTED //REGION  
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.3.4.0 is checked by related rules.

LUP.3.4.1 { @ For the N/PMOS which connects to an I/O pad, space between the 3.3V PMOS and the NMOS >= ^LUP_3_4_1 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_33V < LUP_3_4_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

LUP.3.4.2 { @ For the N/PMOS which connects to an I/O pad, space between the 3.3V PMOS and the NMOS >= ^LUP_3_4_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi_NG POST_DRIVER_PMOS_NWi_33V < LUP_3_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.3.5.0 is checked by related rules.

LUP.3.5.1 { @ For the N/PMOS which connects to an I/O pad, space between the 5V PMOS and the NMOS >= ^LUP_3_5_1 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR CONNECTED  
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_5V < LUP_3_5_1 ABUT < 90 SINGULAR NOT CONNECTED
}

LUP.3.5.2 { @ For the N/PMOS which connects to an I/O pad, space between the 5V PMOS and the NMOS >= ^LUP_3_5_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_NG  POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR
  EXT POST_DRIVER_NMOS_RW_NG  POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR CONNECTED
  EXT POST_DRIVER_NMOS_RWi_NG  POST_DRIVER_PMOS_NWi_5V < LUP_3_5_2 ABUT < 90 SINGULAR NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW  POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR
  EXT POST_DRIVER_NMOS_RW  POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR CONNECTED
  EXT POST_DRIVER_NMOS_RWi  POST_DRIVER_PMOS_NWi_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR NOT CONNECTED
}

LUP.4 { @ Within ^LUP_2 um space from the OD injector, Minimum width for the N+ guard-ring, the P+ guard-ring, the N+ strap and the P+ strap >= ^LUP_4 um
  PTAP_guard_ring_wide2 = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  NTAP_guard_ring_wide2 = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4

  PW_inside_guard_ring_wide2_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide2
  PW_inside_guard_ring_wide2 = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide2_pre
  NW_inside_guard_ring_wide2_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide2
  NW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide2_pre

  PTAP_guard_ring_wide_hole = ((HOLES PTAP_guard_ring_wide2 INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide2
  NTAP_guard_ring_wide_hole = ((HOLES NTAP_guard_ring_wide2 INNER) INSIDE NWi) OR NW_inside_guard_ring_wide2
  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide_hole
  PTAP_guard_ring_check = PSTPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NSTPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PSTPi < LUP_4 ABUT < 90 REGION
  INT NTAP_guard_ring_check NSTPi < LUP_4 ABUT < 90 REGION
}

// LUP.5.0 is checked by related rules.
// LUP.5.1.0 is checked by related rules.

LUP.5.1.1 { @ Minimum space >= ^LUP_5_1_1 um
            @ 1. between N+ OD injector which connects to the IO pad and the core PMOS in the internal circuit
            @ 2. between core P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_LV < LUP_5_1_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}
LUP.5.1.2 { @ Minimum space >= ^LUP_5_1_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between N+ OD injector which connects to the IO pad and the core PMOS in the internal circuit
            @ 2. between core P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_LV_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_LV_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_LV_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW_NG BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW_NG BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi_NG BESIDE_POST_DRIVER_PMOS_NWi_LV < LUP_5_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_LV_NG < LUP_5_1_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_LV_NG < LUP_5_1_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_LV_NG < LUP_5_1_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.5.2.0 is checked by related rules.

LUP.5.2.1 { @ Minimum space >= ^LUP_5_2_1 um
            @ 1. between N+ OD injector which connects to the IO pad and the 1.8V/1.5V PMOS in the internal circuit
            @ 2. between 1.8V/1.5V P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_18V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_2_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_18V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_2_1 ABUT < 90 SINGULAR CONNECTED //REGION 
  EXT POST_DRIVER_PINJ_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_18V < LUP_5_2_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_18V < LUP_5_2_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_18V < LUP_5_2_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}
LUP.5.2.2 { @ Minimum space >= ^LUP_5_2_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between N+ OD injector which connects to the IO pad and the 1.8V/1.5V PMOS in the internal circuit
            @ 2. between 1.8V/1.5V P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_18V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_18V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_18V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW_NG BESIDE_POST_DRIVER_PMOS_NW_18V < LUP_5_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW_NG BESIDE_POST_DRIVER_PMOS_NW_18V < LUP_5_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi_NG BESIDE_POST_DRIVER_PMOS_NWi_18V < LUP_5_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_PINJ_NW_18V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_18V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_18V_NG < LUP_5_2_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_18V_NG < LUP_5_2_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_18V_NG < LUP_5_2_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.5.3.0 is checked by related rules.

LUP.5.3.1 { @ Minimum space >= ^LUP_5_3_1 um
            @ 1. between N+ OD injector which connects to the IO pad and the 2.5V PMOS in the internal circuit
            @ 2. between 2.5V P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_25V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_3_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_25V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_3_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_25V < LUP_5_3_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_25V < LUP_5_3_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_25V < LUP_5_3_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}
LUP.5.3.2 { @ Minimum space >= ^LUP_5_3_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between N+ OD injector which connects to the IO pad and the 2.5V PMOS in the internal circuit
            @ 2. between 2.5V P+ OD injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_25V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_25V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_3_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_25V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW_NG BESIDE_POST_DRIVER_PMOS_NW_25V < LUP_5_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW_NG BESIDE_POST_DRIVER_PMOS_NW_25V < LUP_5_3_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi_NG BESIDE_POST_DRIVER_PMOS_NWi_25V < LUP_5_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_PINJ_NW_25V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_25V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_3_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_25V_NG < LUP_5_3_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_25V_NG < LUP_5_3_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_25V_NG < LUP_5_3_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.5.4.0 is checked by related rules.

LUP.5.4.1 { @ Minimum space >= ^LUP_5_4_1 um
            @ 1. between N+ injector which connects to the IO pad and the 3.3V PMOS in the internal circuit
            @ 2. between 3.3V P+ injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_33V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_4_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_33V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_4_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_33V < LUP_5_4_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_33V < LUP_5_4_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_33V < LUP_5_4_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}
LUP.5.4.2 { @ Minimum space >= ^LUP_5_4_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between N+ injector which connects to the IO pad and the 3.3V PMOS in the internal circuit
            @ 2. between 3.3V P+ injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_33V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_33V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_33V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW_NG BESIDE_POST_DRIVER_PMOS_NW_33V < LUP_5_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW_NG BESIDE_POST_DRIVER_PMOS_NW_33V < LUP_5_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi_NG BESIDE_POST_DRIVER_PMOS_NWi_33V < LUP_5_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_PINJ_NW_33V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_33V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_33V_NG < LUP_5_4_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_33V_NG < LUP_5_4_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_33V_NG < LUP_5_4_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}

// LUP.5.5.0 is checked by related rules.

LUP.5.5.1 { @ Minimum space >= ^LUP_5_5_1 um
            @ 1. between N+ injector which connects to the IO pad and the 5V PMOS in the internal circuit
            @ 2. between 5V P+ injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_5V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_5_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_5V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_5_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_5V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_5V < LUP_5_5_1 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_5V < LUP_5_5_1 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_5V < LUP_5_5_1 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}
LUP.5.5.2 { @ Minimum space >= ^LUP_5_5_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between N+ injector which connects to the IO pad and the 5V PMOS in the internal circuit
            @ 2. between 5V P+ injector which connects to the IO pad and the NMOS in the internal circuit
  EXT POST_DRIVER_PINJ_NW_5V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_5_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_5V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_5_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_5V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW_NG BESIDE_POST_DRIVER_PMOS_NW_5V < LUP_5_5_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW_NG BESIDE_POST_DRIVER_PMOS_NW_5V < LUP_5_5_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi_NG BESIDE_POST_DRIVER_PMOS_NWi_5V < LUP_5_5_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION

  EXT POST_DRIVER_PINJ_NW_5V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_5_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_PINJ_NW_5V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_5_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_PINJ_NWi_5V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_5_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_5V_NG < LUP_5_5_2 ABUT < 90 SINGULAR //REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_5V_NG < LUP_5_5_2 ABUT < 90 SINGULAR CONNECTED //REGION
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_5V_NG < LUP_5_5_2 ABUT < 90 SINGULAR NOT CONNECTED //REGION
}




CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NSTPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM
NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PACT_CHECK = ((PACTi INTERACT COi) INTERACT POi) NOT POi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM

CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PSTPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM
PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NACT_CHECK = ((NACTi INTERACT COi) INTERACT POi) NOT POi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6 { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um 
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
        @ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
	NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)
}

//LUP.10 is checked by LUP.10__LUP.13 
//LUP.13 is checked by LUP.10__LUP.13 
LUP.10__LUP.13 { @ For Area I/O, within ^LUP_10 um from OD injector (covered by LUPWDMY_2),
@ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_13 um
@ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_13 um
  TRIGGER_SOURCE  = POST_DRIVER_ACT NOT OUTSIDE LUPWDMY_2
  CORE_LOGIC_NACT = (NACT_CHECK NOT TRIGGER_SOURCE) NOT INSIDE PTAP_guard_ring_hole
  CORE_LOGIC_PACT = (PACT_CHECK NOT TRIGGER_SOURCE) NOT INSIDE NTAP_guard_ring_hole

  NACT_LUP_pre = CORE_LOGIC_NACT NOT OUTSIDE (SIZE TRIGGER_SOURCE BY LUP_10)
  PACT_LUP_pre = CORE_LOGIC_PACT NOT OUTSIDE (SIZE TRIGGER_SOURCE BY LUP_10)
  NACT_LUP = NACT_LUP_pre NOT OUTSIDE ( SIZE (SIZE PACT_LUP_pre BY LUP_10E OVERUNDER) BY LUP_10E BEVEL 2)
  PACT_LUP = PACT_LUP_pre NOT OUTSIDE ( SIZE (SIZE NACT_LUP_pre BY LUP_10E OVERUNDER) BY LUP_10E BEVEL 2)
  
  PSTP_OS = SIZE PPUi BY LUP_13 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  NACT_LUP NOT PSTP_OS

  NSTP_OS = SIZE NPUi BY LUP_13 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  PACT_LUP NOT NSTP_OS
}
LUP.14 { @ For Area I/O, width of picup ring and guard rings for the OD injector >= 0.2
    AREA_IO_NACT = POST_DRIVER_NACT NOT OUTSIDE LUPWDMY_2
    AREA_IO_PACT = POST_DRIVER_PACT NOT OUTSIDE LUPWDMY_2
    AREA_IO_NACT NOT INSIDE PTAP_guard_ring_hole
    AREA_IO_PACT NOT INSIDE NTAP_guard_ring_hole
    PTAP_guard_ring_2nd = ((HOLES PSTPi INNER) INTERACT AREA_IO_PACT) NOT INTERACT NACT
    NTAP_guard_ring_2nd = ((HOLES NSTPi INNER) INTERACT AREA_IO_NACT) NOT INTERACT PACT
    AREA_IO_NACT NOT INSIDE NTAP_guard_ring_2nd
    AREA_IO_PACT NOT INSIDE PTAP_guard_ring_2nd
 
    PTAP_guard_ring_hole_edge = PSTPi COIN OUTSIDE EDGE (PTAP_guard_ring_hole INTERACT AREA_IO_NACT)
    NTAP_guard_ring_hole_edge = NSTPi COIN OUTSIDE EDGE (NTAP_guard_ring_hole INTERACT AREA_IO_PACT)
    INT PTAP_guard_ring_hole_edge PSTPi < LUP_14 ABUT < 90 REGION
    INT NTAP_guard_ring_hole_edge NSTPi < LUP_14 ABUT < 90 REGION
    
    PTAP_guard_ring_2nd_edge = PSTPi COIN OUTSIDE EDGE PTAP_guard_ring_2nd
    NTAP_guard_ring_2nd_edge = NSTPi COIN OUTSIDE EDGE NTAP_guard_ring_2nd
    INT PTAP_guard_ring_2nd_edge PSTPi < LUP_14 ABUT < 90 REGION
    INT NTAP_guard_ring_2nd_edge NSTPi < LUP_14 ABUT < 90 REGION
}




#IFDEF GUIDELINE_ESD

// I/O ESD Guidance
//==================
PMOSi = (PACTi INTERACT POi) INTERACT COi //Interact CONTi to filter out filler cell.
NMOSi = (NACTi INTERACT POi) INTERACT COi
EPMOS = PMOSi AND SDI
ENMOS = NMOSi AND SDI
EMOS = EPMOS OR ENMOS
PASD = (PACT NOT POLY) INTERACT POLY
NASD = (NACT NOT POLY) INTERACT POLY
EPSD = SDI AND PASD
ENSD = SDI AND NASD
EGTE = SDI AND GATE
ECO  = (CO AND SDI) AND OD
// Define ESD Gate Type
//======================
EGTE_FULL_RPO = EGTE INSIDE RPO
EGTE_PART_RPO = EGTE CUT RPO
EGTE_NO_RPO = EGTE NOT INTERACT RPO

REG_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
REG_EPMOS = (EPMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
TOL_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) INTERACT EGTE_FULL_RPO
PCL_ENMOS = ENMOS NOT INTERACT RPO

REG_EGTE = EGTE AND (REG_ENMOS OR REG_EPMOS)
TOL_EGTE = EGTE AND (TOL_ENMOS OR REG_EPMOS)
PCL_EGTE = EGTE AND PCL_ENMOS

// For ESD.1g
//=============
NSDc_HVMOS = (NSDc INTERACT NMOSi) INTERACT OD2
NSDc_LVMOS = (NSDc INTERACT NMOSi) NOT INTERACT OD2
PSDc_HVMOS = (PSDc INTERACT PMOSi) INTERACT OD2
PSDc_LVMOS = (PSDc INTERACT PMOSi) NOT INTERACT OD2

NSDc_HVMOS_SDI = NSDc_HVMOS INTERACT SDI
NSDc_LVMOS_SDI = NSDc_LVMOS INTERACT SDI
PSDc_HVMOS_SDI = PSDc_HVMOS INTERACT SDI
PSDc_LVMOS_SDI = PSDc_LVMOS INTERACT SDI
HV_GATEc = STAMP HV_GATE BY ILP1i
LV_GATEc = STAMP LV_GATE BY ILP1i

// For ESD.6g
//=============
CONNECT ENSD NSDu
CONNECT EPSD PSDu
ENSDi = NSDc INTERACT ENSD
EPSDi = PSDc INTERACT EPSD

PSTP_real = PSTPi NOT DIODMY
NSTP_real = NSTPi NOT DIODMY

ENSD_SOURCE_pre = NET AREA RATIO ENSDi PSTP_real > 0 [!!AREA(ENSDi)*!!AREA(PSTP_real)]
EPSD_SOURCE_pre = NET AREA RATIO EPSDi NSTP_real > 0 [!!AREA(EPSDi)*!!AREA(NSTP_real)]

ENSD_SOURCE = (ENSD INTERACT ENSD_SOURCE_pre) OR ((ENSD NOT PCL_ENMOS) OUTSIDE RPO)
EPSD_SOURCE = (EPSD INTERACT EPSD_SOURCE_pre) OR (EPSD OUTSIDE RPO)
ENSD_DRAIN = ENSD NOT ENSD_SOURCE
EPSD_DRAIN = EPSD NOT EPSD_SOURCE
ENSD_DRAINx = ENSD_DRAIN INTERACT CO
ENMOSc = STAMP ENMOS BY ENSD_DRAINx
EPMOSc = STAMP EPMOS BY EPSD_DRAIN

#IFDEF FULL_CHIP
ESD.WARN.1 { @ SDI is not in whole chip. If SDI does not exist, the ESD related DRC will not work well.
  CHIP NOT INTERACT SDI
}
#ENDIF

ESD.WARN.2 { @ SDI encloure of ACTIVE >= 0
  (DACT INTERACT SDI) NOT SDI
}

ESD.1g { @ Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers
  NET AREA RATIO NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0
    [!!AREA(NSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))]
    RDB ESD.1g.hv_n.rep NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
  NET AREA RATIO PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0
    [!!AREA(PSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))]
    RDB ESD.1g.hv_p.rep PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
}

ESD.3g { @ Unit finger width of NMOS and PMOS for I/O buffer and Power Clamp >= ^ESD_3g_MIN um <= ^ESD_3g_MAX um
  EGTE_W = EGTE INSIDE EDGE OD
  PATH LENGTH EGTE_W < ESD_3g_MIN
  PATH LENGTH EGTE_W > ESD_3g_MAX
}

ESD.4g { @ The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain, to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.
  EDGE_NSD = NSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_NSD PSTPu > 0 [!!AREA(EDGE_NSD)*!AREA(PSTPu)]
  EDGE_PSD = PSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_PSD NSTPu > 0 [!!AREA(EDGE_PSD)*!AREA(NSTPu)]
}

ESD.5g { @ For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. All other type ODs should be placed outside this guard-ring.
  EPMOS NOT INSIDE NTAP_guard_ring_hole
  ENMOS NOT INSIDE PTAP_guard_ring_hole
}

ESD.6g { @ Butted STRAP and the STRAP which are between two sources of the N/PMOS in the same I/O buffer and Power Clamp are strictly prohibited.
  A = (EXT ENMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  A INTERACT PSTPi
  B = (EXT EPMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  B INTERACT NSTPi
}

NWELc = COPY NWEL
CONNECT NWELc
PWELc = COPY PWEL
CONNECT PWELc

ESD.7g { @ Except the ESD device, either one of the following two conditions must be followed.
@ 1. the space of two same type ODs >= ^ESD_7g um   2. two same type ODs should be separated by different type OD.
@ The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.
  PACT_CHECK = (PACT INTERACT PSD_IOPAD) NOT EPMOS
  PACT_CHECK_CB = STAMP (PACT_CHECK INTERACT PSD_IOPAD == 1 BY NET) BY PSD_IOPAD
  P1 = EXT PACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  PACT_CHECK_NW = STAMP (PACT_CHECK INTERACT P1) BY NWELc
  P2 = EXT PACT_CHECK_NW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_P3 = P1 AND P2
  (ESD_P3 NOT NSTPi) INTERACT PACT_CHECK_CB > 1 BY NET
  PACT_CHECK INTERACT PSD_IOPAD > 1 BY NET

  NACT_CHECK = (NACT INTERACT NSD_IOPAD) NOT ENMOS
  NACT_CHECK_CB = STAMP (NACT_CHECK INTERACT NSD_IOPAD == 1 BY NET) BY NSD_IOPAD
  N1 = EXT NACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  NACT_CHECK_PW = STAMP (NACT_CHECK INTERACT N1) BY PWELc
  N2 = EXT NACT_CHECK_PW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_N3 = N1 AND N2
  (ESD_N3 NOT PSTPi) INTERACT NACT_CHECK_CB > 1 BY NET
  NACT_CHECK INTERACT NSD_IOPAD > 1 BY NET
}
#ENDIF // GUIDELINE_ESD

IO_PADi   = (((PADi NOT VDD_PAD) NOT VSS_PAD) NOT VDD_PAD_BY_DUMMY) NOT VSS_PAD_BY_DUMMY

#IFDEF DEFINE_PAD_BY_TEXT
PWR_M1i_BY_TEXT = M1i WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1i_BY_TEXT = M1i WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1i_BY_TEXT = M1i WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2i_BY_TEXT = M2i WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2i_BY_TEXT = M2i WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2i_BY_TEXT = M2i WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3i_BY_TEXT = M3i WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3i_BY_TEXT = M3i WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3i_BY_TEXT = M3i WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4i_BY_TEXT = M4i WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4i_BY_TEXT = M4i WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4i_BY_TEXT = M4i WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5i_BY_TEXT = M5i WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5i_BY_TEXT = M5i WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5i_BY_TEXT = M5i WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6i_BY_TEXT = M6i WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6i_BY_TEXT = M6i WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6i_BY_TEXT = M6i WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_APi_BY_TEXT = APi WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APi_BY_TEXT = APi WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APi_BY_TEXT = APi WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ENDIF // DEFINE_PAD_BY_TEXT


#IFDEF GUIDELINE_ESD
ESD.12g { @ It is not allowed to use OD unsilicided resistor or NW resistor connected to I/O PAD
  ODR_T = ((OD NOT POLY) INTERACT OD_RES_RPO) NOT OD_RES_RPO
  ODRiT = STAMP ODR_T BY COi
#IFDEF DEFINE_PAD_BY_TEXT
  ODR_T_IO_PAD_pre = NET AREA RATIO ODRiT OVER IO_PADi PAD_M6i_BY_TEXT PAD_M5i_BY_TEXT PAD_M4i_BY_TEXT PAD_M3i_BY_TEXT PAD_M2i_BY_TEXT PAD_M1i_BY_TEXT PAD_APi_BY_TEXT > 0
  ODR_T_VDD_VSS_PAD_TEXT = NET AREA RATIO ODRiT OVER PWR_M6i_BY_TEXT PWR_M5i_BY_TEXT PWR_M4i_BY_TEXT PWR_M3i_BY_TEXT PWR_M2i_BY_TEXT PWR_M1i_BY_TEXT PWR_APi_BY_TEXT GND_M6i_BY_TEXT GND_M5i_BY_TEXT GND_M4i_BY_TEXT GND_M3i_BY_TEXT GND_M2i_BY_TEXT GND_M1i_BY_TEXT GND_APi_BY_TEXT > 0 
  ODR_T_IO_PAD_pre NOT ODR_T_VDD_VSS_PAD_TEXT
  NWR_T_IO_PAD_pre = NET AREA RATIO NWRiT OVER IO_PADi PAD_M6i_BY_TEXT PAD_M5i_BY_TEXT PAD_M4i_BY_TEXT PAD_M3i_BY_TEXT PAD_M2i_BY_TEXT PAD_M1i_BY_TEXT PAD_APi_BY_TEXT > 0
  NWR_T_VDD_VSS_PAD_TEXT = NET AREA RATIO NWRiT OVER PWR_M6i_BY_TEXT PWR_M5i_BY_TEXT PWR_M4i_BY_TEXT PWR_M3i_BY_TEXT PWR_M2i_BY_TEXT PWR_M1i_BY_TEXT PWR_APi_BY_TEXT GND_M6i_BY_TEXT GND_M5i_BY_TEXT GND_M4i_BY_TEXT GND_M3i_BY_TEXT GND_M2i_BY_TEXT GND_M1i_BY_TEXT GND_APi_BY_TEXT > 0 
  NWR_T_IO_PAD_pre NOT NWR_T_VDD_VSS_PAD_TEXT
#ELSE
  NET AREA RATIO ODRiT OVER IO_PADi > 0
  NET AREA RATIO NWRiT OVER IO_PADi > 0
#ENDIF
}


// Regular I/O
//============

PCL_Ncs_DRAIN = (ENSD_DRAIN INTERACT REG_ENMOS) NOT INTERACT NSD_IOPAD
REG_IO_NMOS_DRAIN = (ENSD_DRAIN INTERACT REG_ENMOS) INTERACT NSD_IOPAD

ESD_GATE_W = GATE_W INSIDE EDGE SDI
ESD_PMOS_GATE_W = ESD_GATE_W INSIDE EDGE PP
ESD_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NP
ESD_PMOS_GATE_W_EXP = EXPAND EDGE ESD_PMOS_GATE_W INSIDE BY GRID
ESD_NMOS_GATE_W_EXP = EXPAND EDGE ESD_NMOS_GATE_W INSIDE BY GRID
ESD_PMOS_GATE_W_EXPc = STAMP ESD_PMOS_GATE_W_EXP BY EPMOSc
ESD_NMOS_GATE_W_EXPc = STAMP ESD_NMOS_GATE_W_EXP BY ENMOSc

ESD.16g { @ Total finger width for NMOS in same connection of drain > ^ESD_16g um [check ESD.24g also]
  NET AREA RATIO ESD_NMOS_GATE_W_EXPc < ESD_16g
    [(AREA(ESD_NMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.16g.NMOS.rep ESD_NMOS_GATE_W_EXPc
}
ESD.17g { @ Total finger width for PMOS in same connection of drain > ^ESD_17g um [check ESD.25g also]
  NET AREA RATIO ESD_PMOS_GATE_W_EXPc < ESD_17g
    [(AREA(ESD_PMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.17g.PMOS.rep ESD_PMOS_GATE_W_EXPc
}
ESD.18g { @ Channel length for 3.3V NMOS/PMOS Regular I/O >= ^ESD_18g_33V um
  REG_EGTE_33V = REG_EGTE AND OD33
  INT REG_EGTE_33V < ESD_18g_33V ABUT < 90 SINGULAR REGION
}
ESD.18.1g { @ Channel length for 2.5V NMOS/PMOS Regular I/O >= ^ESD_18g_25V um
  REG_EGTE_25V = REG_EGTE AND OD25
  INT REG_EGTE_25V < ESD_18g_25V ABUT < 90 SINGULAR REGION
}
ESD.18.2g { @ Channel length for 1.8V NMOS/PMOS Regular I/O >= ^ESD_18g_18V um
  REG_EGTE_18V = REG_EGTE AND OD18
  INT REG_EGTE_18V < ESD_18g_18V ABUT < 90 SINGULAR REGION
}

ESD.18.3g { @ Channel length for 0.9V or 1.1V NMOS/PMOS Regular I/O >= ^ESD_18g_LV um
  REG_EGTE_LV  = REG_EGTE NOT OD2
  INT REG_EGTE_LV < ESD_18g_LV ABUT < 90 SINGULAR REGION
}
ESD.19g { @ The NMOS and PMOS should have an unsilicided area on the drain side.
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
  REG_EGTE NOT INTERACT RPO
}
ESD.20g { @ Overlap of RPO on the drain side to the poly gate for Regular I/O == ^ESD_20g um
  REG_EGTE OUTSIDE RPO
  REG_EGTE_W = REG_EGTE INSIDE EDGE OD
  X = REG_EGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_20g
  REG_EGTE WITH EDGE X > 1
  (REG_EGTE AND RPO) XOR Y
}
ESD.21g { @ Width of the RPO on drain side for NMOS Regular I/O >= ^ESD_21g um
  REG_ENSD_pre = (ENSD INTERACT REG_EGTE) AND RPO
  REG_ENSD = REG_ENSD_pre AND REG_IO_NMOS_DRAIN
  INT REG_ENSD < ESD_21g ABUT < 90 SINGULAR REGION
}
ESD.22g { @ Width of the RPO on drain side for PMOS Regular I/O >= ^ESD_22g um
  REG_EPSD = (EPSD INTERACT REG_EGTE) AND RPO
  INT REG_EPSD < ESD_22g ABUT < 90 SINGULAR REGION
}
ESD.23g { @ Space of poly to CO on source side for Regular I/O >= ^ESD_23g um
  EXT ECO ((REG_EGTE AND NP) INTERACT REG_IO_NMOS_DRAIN) < ESD_23g ABUT < 90 SINGULAR REGION
  EXT ECO (REG_EGTE AND PP) < ESD_23g ABUT < 90 SINGULAR REGION
}


// HV Tolerant I/O
//================

TOL_ENOD = ENSD INTERACT TOL_EGTE
TOL_ENG  = (TOL_ENOD NOT INTERACT ECO) NOT INTERACT PSTP
TOL_ENSD = TOL_ENOD NOT TOL_ENG
TOL_ENS  = TOL_ENSD OUTSIDE RPO
TOL_END  = TOL_ENSD NOT OUTSIDE RPO

// ESD.24g is checked by ESD.16g
// ESD.25g is checked by ESD.17g
ESD.26g { @ Channel length for  5V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_5V um
  TOL_EGTE_5V = TOL_EGTE AND OD33
  INT TOL_EGTE_5V < ESD_26g_5V ABUT < 90 SINGULAR REGION
}
ESD.26.1g { @ Channel length for 3.3V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_33V um
  TOL_EGTE_33V = TOL_EGTE AND OD25
  INT TOL_EGTE_33V < ESD_26g_33V ABUT < 90 SINGULAR REGION
}
ESD.26.2g { @ Channel length for 2.5V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_25V um
  TOL_EGTE_25V = TOL_EGTE AND OD18
  INT TOL_EGTE_25V < ESD_26g_25V ABUT < 90 SINGULAR REGION
}
ESD.27g { @ The NMOS and PMOS should have an unsilicided area on the drain side.
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
  TOL_EGTE NOT INTERACT RPO
}
ESD.28g { @ Overlap of RPO on the drain side to the poly gate for NMOS HV Tolerant I/O == ^ESD_28g um
  TOL_ENGTE1 = TOL_EGTE INTERACT TOL_END
  TOL_ENGTE2 = TOL_EGTE INTERACT TOL_ENS
  TOL_ENGTE1 NOT RPO
  TOL_ENGTE2 OUTSIDE RPO
  TOL_ENG NOT INTERACT TOL_ENGTE2
  TOL_ENGTE2_W = TOL_ENGTE2 INSIDE EDGE OD
  X = TOL_ENGTE2_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_28g
  (TOL_ENGTE2 AND RPO) XOR Y
}
ESD.29g { @ Overlap of RPO on the drain side to the poly gate for PMOS HV Tolerant I/O == ^ESD_29g um
  TOL_EPGTE = TOL_EGTE INTERACT EPSD
  TOL_EPGTE OUTSIDE RPO
  TOL_EPGTE_W = TOL_EPGTE INSIDE EDGE OD
  X = TOL_EPGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_29g
  TOL_EPGTE WITH EDGE X > 1
  (TOL_EPGTE AND RPO) XOR Y
}
ESD.30g { @ Width of the RPO on drain side for NMOS HV Tolerant I/O >= ^ESD_30g um
  TOL_ENSD = TOL_END AND RPO
  INT TOL_ENSD < ESD_30g ABUT < 90 SINGULAR REGION
}
ESD.31g { @ Width of the RPO on drain side for PMOS HV Tolerant I/O >= ^ESD_31g um
  TOL_EPSD = (EPSD INTERACT TOL_EGTE) AND RPO
  INT TOL_EPSD < ESD_31g ABUT < 90 SINGULAR REGION
}
ESD.32g { @ Space of poly to CO on source side for HV Tolerant I/O >= ^ESD_32g um
  EXT ECO TOL_EGTE < ESD_32g ABUT < 90 SINGULAR REGION
}
ESD.33g { @ Space of 1st poly gate(N2) to 2nd poly gate(N3) for NMOS HV Tolerant I/O == ^ESD_33g_MIN ~ ^ESD_33g um
  INT TOL_ENG < ESD_33g_MIN ABUT < 90 SINGULAR REGION
  TOL_ENG WITH WIDTH > ESD_33g
  (TOL_EGTE AND NP) NOT INTERACT TOL_ENG
}
ESD.34g { @ The NMOS HV Tolerant I/O should have ESDIMP
  TOL_ENMOS NOT INTERACT ESDIMP
}
// ESD.35gU can not be checked by DRC


// Power Clamp
//============

PCL_GATE_W = ESD_GATE_W INSIDE EDGE PCL_ENMOS
PCL_HV_GATE_W = PCL_GATE_W INSIDE EDGE OD2
PCL_LV_GATE_W = PCL_GATE_W NOT INSIDE EDGE OD2
PCL_HV_GATE_W_EXP = EXPAND EDGE PCL_HV_GATE_W INSIDE BY GRID
PCL_LV_GATE_W_EXP = EXPAND EDGE PCL_LV_GATE_W INSIDE BY GRID
PCL_HV_GATE_W_EXPc = STAMP PCL_HV_GATE_W_EXP BY ENMOSc
PCL_LV_GATE_W_EXPc = STAMP PCL_LV_GATE_W_EXP BY ENMOSc

ESD.37g { @ Total finger width for 3.3V/2.5V/1.8V fully silicided type Power Clamp in same connection of drain > ^ESD_37g_HV um
  NET AREA RATIO PCL_HV_GATE_W_EXPc < ESD_37g_HV
    [(AREA(PCL_HV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.37g.HV.rep PCL_HV_GATE_W_EXPc
}

ESD.37.1g { @ Total finger width for 1.1V/0.9V Power Clamp in same connection of drain > ^ESD_37g_LV um
  NET AREA RATIO PCL_LV_GATE_W_EXPc < ESD_37g_LV
    [(AREA(PCL_LV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.37g.LV.rep PCL_LV_GATE_W_EXPc
}
ESD.38g { @ Channel length for 3.3V Power Clamp >= ^ESD_38g_33V um
  PCL_EGTE_33V = PCL_EGTE AND OD33
  INT PCL_EGTE_33V < ESD_38g_33V ABUT < 90 SINGULAR REGION
}
ESD.38.1g { @ Channel length for 2.5V Power Clamp >= ^ESD_38g_25V um
  PCL_EGTE_25V = PCL_EGTE AND OD25
  INT PCL_EGTE_25V < ESD_38g_25V ABUT < 90 SINGULAR REGION
}
ESD.38.2g { @ Channel length for 1.8V Power Clamp >= ^ESD_38g_18V um
  PCL_EGTE_18V = PCL_EGTE AND OD18
  INT PCL_EGTE_18V < ESD_38g_18V ABUT < 90 SINGULAR REGION
}

ESD.38.3g { @ Channel length for 0.9V or 1.1V Power Clamp >= ^ESD_38g_LV um
  PCL_EGTE_LV  = PCL_EGTE NOT OD2
  INT PCL_EGTE_LV < ESD_38g_LV ABUT < 90 SINGULAR REGION
}


ESD_HV_NMOS_GATE_W = ESD_NMOS_GATE_W INSIDE EDGE (OD2 NOT OD18)
ESD_HV_NMOS_GATE_W_EXP = EXPAND EDGE ESD_HV_NMOS_GATE_W INSIDE BY GRID
PCL_Ncs_GATE_W_EXPc = STAMP (ESD_HV_NMOS_GATE_W_EXP INTERACT (EGTE_PART_RPO INTERACT PCL_Ncs_DRAIN)) BY ENMOSc
ESD.39g { @ The total finger width for 3.3V/2.5V RPO (unsilicided) type Power Clamp in the same connection of drain. (Ncs in Figure XXX and Figure XXX) (Please refer to section XXX in detail) >= 1000 
  NET AREA RATIO PCL_Ncs_GATE_W_EXPc < ESD_39g
    [(AREA(PCL_Ncs_GATE_W_EXPc)/2)/GRID]
    RDB ESD.39g.rep PCL_Ncs_GATE_W_EXPc
}

// ESD.40g is checked by ESD.20g
ESD.41g { @ Width of the RPO on the drain side for 3.3V/2.5V RPO (unsilicided) type Power Clamp (Ncs in Figure XXX) >= 0.6 
  PCL_Ncs_ENSD_pre = ((ENSD INTERACT REG_EGTE) AND RPO) AND (OD2 NOT OD18)
  PCL_Ncs_ENSD = PCL_Ncs_ENSD_pre AND PCL_Ncs_DRAIN
  INT PCL_Ncs_ENSD < ESD_41g ABUT < 90 SINGULAR REGION
}
ESD.42g { @ Space of poly to CO on the source side for 3.3V/2.5V RPO (unsilicided) type Power Clamp (Ncs in Figure XXX) >= 0.11 
  EXT (ECO AND (OD2 NOT OD18)) (REG_EGTE INTERACT PCL_Ncs_DRAIN) < ESD_42g ABUT < 90 SINGULAR REGION
}
ESD.43g { @ The big FET of RPO (unsilicided) type Power Clamp is strongly recommended having ESDIMP. (Figure XXX)   
  (REG_ENMOS INTERACT PCL_Ncs_DRAIN) NOT INTERACT ESDIMP
}

NFD = (((NACT NOT INTERACT POLY) NOT RPDMY) AND SDI) CUT RPO
PFD = (((PACT NOT INTERACT POLY) NOT RPDMY) AND SDI) CUT RPO
NFDc = STAMP NFD BY NSDc
PFDc = STAMP PFD BY PSDc
NFD_Emitter = NET AREA RATIO NFDc PSTPi > 0
NFD_Collector = NFDc NOT NFD_Emitter
PFD_Emitter = NET AREA RATIO PFDc NSTPi > 0
PFD_Collector = PFDc NOT PFD_Emitter

NFD_STI = EXT NFD_Collector NFD_Emitter == ESD_50g OPPOSITE REGION
PFD_STI = EXT PFD_Collector PFD_Emitter == ESD_50g OPPOSITE REGION
ESD.47g { @ The layer of OD2 is required for 5V protection (NFD and PFD)
  NFD NOT OD2
  PFD NOT OD2
}
ESD.48g { @ Total width for NFD in same connection of collector >= 360
  A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
  A1 = EXPAND EDGE A INSIDE BY GRID
  Ac = STAMP A1 BY NFD_Collector
  NET AREA RATIO Ac < ESD_48g
    [AREA(Ac)/GRID]
}
ESD.49g { @ Total width for PFD in same connection of collector >= 360
  A =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
  A1 = EXPAND EDGE A INSIDE BY GRID
  Ac = STAMP A1 BY PFD_Collector
  NET AREA RATIO Ac < ESD_49g
    [AREA(Ac)/GRID]
}
ESD.50g { @ STI spacing of the NFD and PFD = 0.35
  NFD_Collector NOT INTERACT NFD_STI == 2
  PFD_Collector NOT INTERACT PFD_STI == 2
}
ESD.51g	{ @ Unit collector width of NFD and PFD = 15-60
  A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
  LENGTH A < ESD_51g_MIN
  LENGTH A > ESD_51g_MAX
  B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
  LENGTH B < ESD_51g_MIN
  LENGTH B > ESD_51g_MAX
}
ESD.52g	{ @ Unit emitter width of NFD and PFD should be the same as unit collector width
  NOT RECTANGLE ( (NFD_STI OR NFD_Emitter) OR NFD_Collector)
  NOT RECTANGLE ( (PFD_STI OR PFD_Emitter) OR PFD_Collector)
}
ESD.53g { @ Unit emitter length of NFD and PFD >= 0.86
  INT NFD_Emitter < ESD_53g ABUT<90 SINGULAR REGION
  INT PFD_Emitter < ESD_53g ABUT<90 SINGULAR REGION
}
ESD.54g	{ @ Width of the RPO on the collector side for NFD and PFD >= 1.95
  A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
  A1 = EXPAND EDGE A INSIDE BY ESD_54g
  A1 NOT RPO
  B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
  B1 = EXPAND EDGE B INSIDE BY ESD_54g
  B1 NOT RPO
}
ESD.55g	{ @ Width of the RPO on the emitter side for NFD and PFD	= 0.1
  A =  NFD_Emitter COIN OUTSIDE EDGE NFD_STI
  A1 = EXPAND EDGE A INSIDE BY ESD_55g
  A1 XOR (RPO AND NFD_Emitter)
  B =  PFD_Emitter COIN OUTSIDE EDGE PFD_STI
  B1 = EXPAND EDGE B INSIDE BY ESD_55g
  B1 XOR (RPO AND PFD_Emitter)
}
ESD.56g { @ Space of RPO to CO on the collector and emitter side >= 0.22
  A = CO AND (NFD OR PFD)
  EXT A RPO < ESD_56g ABUT<90 SINGULAR REGION
}
ESD.57g	{ @ Total width of the RPO on the HVMOS protection. >= 2.4
  A = RPO INTERACT (NFD OR PFD)
  INT A < ESD_57g ABUT<90 SINGULAR REGION
}
#ENDIF


#IFDEF N40_G

// SR_ESD CHECK
//--------------

SR_ESD.W.1 { @ width >= 0.18 
  INT SRESD < SRESD_W_1 ABUT < 90 SINGULAR REGION
}

SRESD_GATE = GATE NOT OUTSIDE SRESD
SRESD_GATE_W = POi COIN INSIDE EDGE SRESD_GATE
SRESD_GATE_L = SRESD_GATE NOT TOUCH EDGE SRESD_GATE_W

SR_ESD.W.2 { @ Channel length in SR_ESD regions >= 0.1 
  LENGTH SRESD_GATE_L < SRESD_W_2
}
SR_ESD.W.3 { @ Channel width of core device in SR_ESD regions = 15 ~ 60 
  (LENGTH SRESD_GATE_W < SRESD_W_3a) NOT INSIDE EDGE OD2i
  (LENGTH SRESD_GATE_W > SRESD_W_3b) NOT INSIDE EDGE OD2i
}
SR_ESD.S.1 { @ Space >= 0.18 
  EXT SRESD < SRESD_S_1 ABUT < 90 SINGULAR REGION
}
SR_ESD.EX.1 { @ Extension on ACTIVE >= 0.02 
  ENC DACT SRESD < SRESD_EX_1 ABUT < 90 SINGULAR REGION
}
SR_ESD.L.1 { @ Maximum ACTIVE length of core device in SR_ESD regions <= 60 
  DACT_G = ((DACT NOT OD2i) ENCLOSE GATE) INSIDE SRESD // cut SR_ESD is checked by OD.L.4
  // rectangle active
  DACT_G_R = RECTANGLE DACT_G
  ENCLOSE RECTANGLE DACT_G_R GRID SRESD_L_1+GRID ORTHOGONAL ONLY
  // not rectangle active
  DACT_G_NR = AREA (DACT_G NOT DACT_G_R) > SRESD_L_1 * SRESD_W_3a // suspected active
  DACT_G_NR_EX = EXTENTS DACT_G_NR
  DACT_G_NR_EX_ERR = ENCLOSE RECTANGLE DACT_G_NR_EX GRID SRESD_L_1+GRID ORTHOGONAL ONLY
  DACT_G_NR_EX_ERR AND DACT_G_NR
}
SR_ESD.R.1 { @ SR_ESD can not cover core PMOS
  SRESD INTERACT (GATE_PP NOT OD2)
}
#ENDIF


//SRAM CHECKS
//===========
SRAM.W.1 { @ SRM width. The SRM edge should be aligned to the boundary of the cell array, which may include storage, strapping, and dummy edge cells >= 0.19 
  INT SRM < SRAM_W_1 ABUT < 90 SINGULAR REGION
}
SRAM.S.1 { @ SRM space >= 0.19 
  EXT SRM < SRAM_S_1 ABUT < 90 SINGULAR REGION
}
SRAM.S.2 { @ SRM space to {GATE NOT INTERACT SRM} >= 0.14 
  A = POi AND ODi
  B = A NOT INTERACT SRM
  EXT B SRM < SRAM_S_2 ABUT < 90 SINGULAR REGION
}
SRAM.BTC.S.1 { @ BTC space [different nets] >= 0.09 
  X = STAMP BTC BY COi
  EXT X < SRAM_BTC_S_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
SRAM.BTC.S.2 { @ BTC space to M1 [different nets] >= 0.055 
  X = STAMP BTC BY COi
  EXT X M1i < SRAM_BTC_S_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
SRAM.BTC.S.3 { @ BTC space to CO [different nets] >= 0.067 
  X = STAMP BTC BY COi
  EXT X COi < SRAM_BTC_S_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

SRAM.EN.1__SRAM.EN.2 { @ SRM enclosusre of GATE in S/D direction >= ^SRAM_EN_1 um, in PO end-cap direction >= ^SRAM_EN_2 um
  A = GATEi INTERACT SRM
  X = A INSIDE EDGE ODi
  B = (EXPAND EDGE X OUTSIDE BY (SRAM_EN_1 - SRAM_EN_2)) OR A
  C = SIZE B BY SRAM_EN_2
  C NOT SRM
}

// SRAM.EN.1 is checked by SRAM.EN.1__SRAM.EN.2
// SRAM.EN.2 is checked by SRAM.EN.1__SRAM.EN.2

SRAM.EX.1 { @ SRM extension on NW (INTERACT with OD). Extension = 0 is allowed >= 0.19 
  (ENC NWi SRM < SRAM_EX_1 ABUT < 90 > 0 SINGULAR REGION) INTERACT ODi
}
SRAM.O.1 { @ SRM overlap of NW (INTERACT with OD) (for VTC_N, VTC_P). Extension = 0 is allowed >= 0.19 
  (INT (SRM AND NWi) < SRAM_O_1 ABUT < 90 OPPOSITE REGION) INTERACT ODi
}
SRAM.A.1 { @ SRM;0 (50;0) Area >= 11 
  AREA SRM < SRAM_A_1
}
SRAM.R.12 { @ SRAMDMY;5 (186;5)/ SRAMDMY;4 (186;4) overlap of SRAMDMY;0 (186;0) is not allowed   
  SRAMDMY_PERI AND SRAMDMY
}
SRAM.R.13 { @ SRM must fully cover GATE   
  GATEi CUT SRM
}

// SRAM.R.14 is checked by related rules

SRAM.R.15 { @ CO;11 (30;11) is a must for CO mask tape-out in SRAM. (Except RAM1TDMY (160;0) region) 1. If CO;11 exists, it must cover CO;0 2. CO;11 must be 0.06 um x 0.06 um 3. CO;11 must be exactly the same as CO;0. 4. CO;11 must be fully covered by SRM (50;0) and SRAMDMY;0 (186;0) 5. Square CO;0 in SRAM must cover CO;11 in 50;0 region   
// CO;11 (30;11) is a must for CO mask tape-out in SRAM
  (((SRAMDMY AND SRM) NOT RAM1TDMY) INTERACT COi) NOT INTERACT COPUSH
// 1.If CO;11 exists, it must cover CO;0
  COPUSH NOT COi
// 2.CO;11 must be 0.06um x 0.06um
  NOT RECTANGLE COPUSH == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
// 3.CO;11 must be exactly the same as CO;0.
  CO_COPUSH = COi INTERACT COPUSH
  CO_COPUSH XOR COPUSH
// 4.CO;11 must be fully covered by SRM(50;0) and SRAMDMY(186;0)
  COPUSH NOT SRM
  COPUSH NOT SRAMDMY
// 5. Square CO must be covered by CO;11
  CO_SRAM = COi INSIDE SRM
  SQUARE_CO = RECTANGLE CO_SRAM == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  SQUARE_CO NOT COPUSH
}

SRAM.R.17 { @ SRAMDMY;0 (186;0) and SRM (50;0) must fully cover OD, CO, VIA1   
  ODi CUT SRAMDMY
  COi CUT SRAMDMY
  VIA1i CUT SRAMDMY
  ODi CUT SRM
  COi CUT SRM
  VIA1i CUT SRM
}
SRAM.R.19 { @ SRAM dummy layers can exist only in SRM (50;0) region. And in logic region, no SRAM dummy layer can be used. SRAM dummy layers are listed below : DMMYOD1~16, DUMMYPO1~7, SRM;1~2, NPreDOSRM, SRAMDMY;0~1, CO;11, CO2, DPSRM, PRSRM, SRM_LOP;12~14, LV_LOP, HCDP_LOP, 8TTP_LOP and 10TTP_LOP   
  A = ((((((((((((((DUMMYOD1 OR DUMMYOD2) OR DUMMYOD3) OR DUMMYOD4) OR DUMMYOD5) OR DUMMYOD6) OR DUMMYOD7) OR DUMMYOD8) OR DUMMYOD9) OR DUMMYOD10) OR DUMMYOD11) OR DUMMYOD12) OR DUMMYOD13) OR DUMMYOD14) OR DUMMYOD15) OR DUMMYOD16
  A NOT SRM
  B = (((((DUMMYPO1 OR DUMMYPO2) OR DUMMYPO3) OR DUMMYPO4) OR DUMMYPO5) OR DUMMYPO6) OR DUMMYPO7
  B NOT SRM
  C = (((((((((((((SRMN OR SRMP) OR NPreDOSRM) OR SRAMDMY_PAS) OR COPUSH) OR CO2) OR DPSRM) OR PRSRM) OR SRMLOP12) OR SRMLOP13) OR SRMLOP14) OR LVLOP) OR HCDPLOP) OR TPLOP_8T) OR TPLOP_10T
  C NOT SRM
}
SRAM.R.20 { @ Inside of SRAM array, SRM (50;0), SRAMDMY;0 (186;0) can't have any holes in them   
  HOLES SRM INNER
  HOLES SRAMDMY INNER
}
SRAM.R.21 { @ SRM (50;0) and SRAMDMY;0 (186;0) must be drawn identically (Except RAM1TDMY (160;0) region)   
  SRM XOR (SRAMDMY NOT RAM1TDMY)
}



SRAM_R22_24L = ((((((SRMLOP12 OR SRMLOP13) OR SRMLOP14) OR LVLOP) OR HCDPLOP) OR TPLOP_8T) OR TPLOP_10T) OR DPSRM

SRAM.R.22:DPSRM { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  DPSRM OUTSIDE PRSRM

}
SRAM.R.22:SRMLOP12 { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  SRMLOP12 OUTSIDE PRSRM

}
SRAM.R.22:SRMLOP13 { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  SRMLOP13 OUTSIDE PRSRM

}
SRAM.R.22:SRMLOP14 { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  SRMLOP14 OUTSIDE PRSRM

}
SRAM.R.22:LVLOP { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  LVLOP OUTSIDE PRSRM

}
SRAM.R.22:HCDPLOP { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  HCDPLOP OUTSIDE PRSRM

}
SRAM.R.22:TPLOP_8T { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  TPLOP_8T OUTSIDE PRSRM

}
SRAM.R.22:TPLOP_10T { @ (80;x) must overlap PRSRM (80;11). x = 0, 12~18   
  TPLOP_10T OUTSIDE PRSRM

}

// SRAM.R.22 is checked by SRAM.R.22:DPSRM
// SRAM.R.22 is checked by SRAM.R.22:SRMLOP12
// SRAM.R.22 is checked by SRAM.R.22:SRMLOP13
// SRAM.R.22 is checked by SRAM.R.22:SRMLOP14
// SRAM.R.22 is checked by SRAM.R.22:LVLOP
// SRAM.R.22 is checked by SRAM.R.22:HCDPLOP
// SRAM.R.22 is checked by SRAM.R.22:TPLOP_8T
// SRAM.R.22 is checked by SRAM.R.22:TPLOP_10T

SRAM.R.23 { @ if PRSRM (80;11) interacts (80;x). It must be fully covered by (80;x). x = 0, 12~18   
  PRSRM_Check = PRSRM INTERACT SRAM_R22_24L
  PRSRM_Check NOT SRAM_R22_24L
}

SRAM.R.24:DPSRM { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  DPSRM_C = DPSRM INTERACT SRM
  SRM_C = SRM INTERACT DPSRM
  DPSRM_C XOR SRM_C
}

SRAM.R.24:SRMLOP12 { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  SRMLOP12_C = SRMLOP12 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP12
  SRMLOP12_C XOR SRM_C
}

SRAM.R.24:SRMLOP13 { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  SRMLOP13_C = SRMLOP13 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP13
  SRMLOP13_C XOR SRM_C
}

SRAM.R.24:SRMLOP14 { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  SRMLOP14_C = SRMLOP14 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP14
  SRMLOP14_C XOR SRM_C
}


SRAM.R.24:HCDPLOP { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  HCDPLOP_C = HCDPLOP INTERACT SRM
  SRM_C = SRM INTERACT HCDPLOP
  HCDPLOP_C XOR SRM_C
}


SRAM.R.24:TPLOP_10T { @ (80;x) interact SRM (50;0) must be identical to SRM;0 (50;0), except SRM_LV (80;15) and SRM_8TTP (80;17), x = 0, 12~18   
  TPLOP_10T_C = TPLOP_10T INTERACT SRM
  SRM_C = SRM INTERACT TPLOP_10T
  TPLOP_10T_C XOR SRM_C
}


// SRAM.R.24 is checked by SRAM.R.24:DPSRM
// SRAM.R.24 is checked by SRAM.R.24:SRMLOP12
// SRAM.R.24 is checked by SRAM.R.24:SRMLOP13
// SRAM.R.24 is checked by SRAM.R.24:SRMLOP14
// SRAM.R.24 is checked by SRAM.R.24:HCDPLOP
// SRAM.R.24 is checked by SRAM.R.24:TPLOP_10T

SRAM.R.25:DPSRM { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  DPSRM INTERACT SRMLOP12

  DPSRM INTERACT SRMLOP13

  DPSRM INTERACT SRMLOP14

  DPSRM INTERACT LVLOP

  DPSRM INTERACT HCDPLOP

  DPSRM INTERACT TPLOP_8T

  DPSRM INTERACT TPLOP_10T

}
SRAM.R.25:SRMLOP12 { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  SRMLOP12 INTERACT SRMLOP13

  SRMLOP12 INTERACT SRMLOP14

  SRMLOP12 INTERACT LVLOP

  SRMLOP12 INTERACT HCDPLOP

  SRMLOP12 INTERACT TPLOP_8T

  SRMLOP12 INTERACT TPLOP_10T

}
SRAM.R.25:SRMLOP13 { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  SRMLOP13 INTERACT SRMLOP14

  SRMLOP13 INTERACT LVLOP

  SRMLOP13 INTERACT HCDPLOP

  SRMLOP13 INTERACT TPLOP_8T

  SRMLOP13 INTERACT TPLOP_10T

}
SRAM.R.25:SRMLOP14 { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  SRMLOP14 INTERACT LVLOP

  SRMLOP14 INTERACT HCDPLOP

  SRMLOP14 INTERACT TPLOP_8T

  SRMLOP14 INTERACT TPLOP_10T

}
SRAM.R.25:LVLOP { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  LVLOP INTERACT HCDPLOP


  LVLOP INTERACT TPLOP_10T

}
SRAM.R.25:HCDPLOP { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  HCDPLOP INTERACT TPLOP_8T

  HCDPLOP INTERACT TPLOP_10T

}
SRAM.R.25:TPLOP_8T { @ (80;x) can't interact each other, x = 0, 12~18. Only SRM_LV (80;15) interacting with SRM_8TTP (80;17) is allowed   

  TPLOP_8T INTERACT TPLOP_10T

}

// SRAM.R.25 is checked by SRAM.R.25:DPSRM
// SRAM.R.25 is checked by SRAM.R.25:SRMLOP12
// SRAM.R.25 is checked by SRAM.R.25:SRMLOP13
// SRAM.R.25 is checked by SRAM.R.25:SRMLOP14
// SRAM.R.25 is checked by SRAM.R.25:LVLOP
// SRAM.R.25 is checked by SRAM.R.25:HCDPLOP
// SRAM.R.25 is checked by SRAM.R.25:TPLOP_8T

SRAM.R.26 { @ SRM;0 (50;0) must cover NMOS gate and PMOS gate at the same time. DRC will check the following 2 conditions at the same time. (1) {SRM NOT INTERACT (NP AND GATE)} (2) {SRM NOT INTERACT (PP AND GATE)}   
  (SRM NOT INTERACT (NPi AND GATEi)) OR (SRM NOT INTERACT (PPi AND GATEi))
}

#IFDEF GS
SRAM.R.27 { @ For GS, SRM;0(50;0) must include both SRM;1(50;1) and SRM;2(50;2).
  SRM NOT INTERACT SRMN
  SRM NOT INTERACT SRMP
}
#ELSE
SRAM.R.28 { @ For LP/LPG, {SRM;0(50;0) AND SRM_HD(80;14)} must include both SRM;1(50;1) and SRM;2(50;2).
  (SRM AND SRMLOP14) NOT INTERACT SRMN
  (SRM AND SRMLOP14) NOT INTERACT SRMP
}
#IFDEF LPG
SRAM.R.29 { @ For LPG, {SRM;0(50;0) AND DPSRM(80;0)} must include both SRM;1(50;1) and SRM;2(50;2).
  (SRM AND DPSRM) NOT INTERACT SRMN
  (SRM AND DPSRM) NOT INTERACT SRMP
}
#ENDIF
#ENDIF

SRAM.R.31 { @ When M1 or M2 width > ^SRAM_R_31_W um, more than one VIA1 is required.
            @ 2 vias spacing should be <= ^SRAM_R_31_S1 um or 4 vias spacing should be <= ^SRAM_R_31_S2 um
  VIA1_EXDi = VIA1i NOT VIA_EXD
  M1Wide_R31_VIA1 = (M1i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_31_W      // 0.3
  M2Wide_R31_VIA1 = (M2i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_31_W      // 0.3
  M2OvpM1_W = ((M1Wide_R31_VIA1 AND M2i) OR (M2Wide_R31_VIA1 AND M1i)) NOT OUTSIDE SRAMDMY
  Checked_VIA1_W = VIA1_EXDi NOT OUTSIDE M2OvpM1_W
  M1_effect = M1i INTERACT M2OvpM1_W
  M2_effect = M2i INTERACT M2OvpM1_W
  effect_M2OvpM1_ = M1_effect AND M2_effect
  effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W
  effect_VIA = VIA1_EXDi INTERACT effect_M2OvpM1

  V1Merged_A = SIZE effect_VIA BY SRAM_R_31_S1/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
  V1Merged_B = SIZE V1Merged_A BY (SRAM_R_31_S2 - SRAM_R_31_S1)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
  V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
  V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
  V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
  V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R

  GMergeW = V1Merged_A2 OR V1Merged_B4
  GVIA_W = Checked_VIA1_W INTERACT GMergeW
  GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
  (Checked_VIA1_W OUTSIDE GOOD_AREA_W) NOT OUTSIDE SRAMDMY
}

SRAM.R.32:M1 { @ At least two VIAx must be used for a connection that is <= ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W). (It is allowed to use one VIAx for a connection that is > ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W).)
  M1Wide_R32_VIA1 = (M1i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_32_W      // 0.3
  Branch1 = ((SIZE M1Wide_R32_VIA1 BY SRAM_R_32_D + GRID) NOT M1Wide_R32_VIA1) AND M1i
  Branch1HasVia = (Branch1 INTERACT M1Wide_R32_VIA1) INTERACT VIA1i
  Branch1Edge = M1Wide_R32_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY SRAM_R_32_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2i) INTERACT VIA1i > 1
  BranchSingleVia = (VIA1i NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1i) INTERACT BranchSingleVia) INTERACT VIA1i == 1
  ((BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD) NOT OUTSIDE SRAMDMY
}

SRAM.R.32:M2 { @ At least two VIAx must be used for a connection that is <= ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W). (It is allowed to use one VIAx for a connection that is > ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W)).
  M2Wide_R32_VIA1 = (M2i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_32_W      // 0.3
  Branch1 = ((SIZE M2Wide_R32_VIA1 BY SRAM_R_32_D + GRID) NOT M2Wide_R32_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R32_VIA1) INTERACT VIA1i
  Branch1Edge = M2Wide_R32_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY SRAM_R_32_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1i) INTERACT VIA1i > 1
  BranchSingleVia = (VIA1i NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1i INTERACT BranchSingleVia) AND M2i) INTERACT BranchSingleVia) INTERACT VIA1i == 1
  ((BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD) NOT OUTSIDE SRAMDMY
}

// SRAM.R.32 is checked by SRAM.R.32:M1 and SRAM.R.32:M2

SRAM.R.33:DPSRM { @ (80;0) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  DPSRM NOT ENCLOSE COPUSH       // sram 0.589 cell must have 30;11
  DPSRM NOT ENCLOSE SRM          // sram 0.589 cell must have 50;0
  DPSRM NOT ENCLOSE NPreDOSRM    // sram 0.589 cell must have 50;21
  DPSRM NOT ENCLOSE DUMMYOD1     // sram 0.589 cell must have 82;1
  DPSRM NOT ENCLOSE DUMMYOD2     // sram 0.589 cell must have 82;2
  DPSRM NOT ENCLOSE DUMMYOD9     // sram 0.589 cell must have 82;9
  DPSRM NOT ENCLOSE DUMMYOD10    // sram 0.589 cell must have 82;10
  DPSRM NOT ENCLOSE DUMMYOD11    // sram 0.589 cell must have 82;11
  DPSRM NOT ENCLOSE DUMMYOD12    // sram 0.589 cell must have 82;12
  DPSRM NOT ENCLOSE DUMMYOD16    // sram 0.589 cell must have 82;16
  DPSRM NOT ENCLOSE DUMMYPO1     // sram 0.589 cell must have 83;1
  DPSRM NOT ENCLOSE DUMMYPO2     // sram 0.589 cell must have 83;2
  DPSRM NOT ENCLOSE DUMMYPO3     // sram 0.589 cell must have 83;3
  DPSRM NOT ENCLOSE DUMMYPO4     // sram 0.589 cell must have 83;4
  DPSRM NOT ENCLOSE DUMMYPO5     // sram 0.589 cell must have 83;5
  DPSRM NOT ENCLOSE DUMMYPO7     // sram 0.589 cell must have 83;7
  DPSRM NOT ENCLOSE SRAMDMY      // sram 0.589 cell must have 186;0
  DPSRM NOT ENCLOSE SRAMDMY_PAS  // sram 0.589 cell must have 186;1
  DPSRM NOT ENCLOSE CO2          // sram 0.589 cell must have 100;0
}
SRAM.R.33:SRMLOP14 { @ (80;14) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  SRMLOP14 NOT ENCLOSE COPUSH       // sram 0.299 cell must have 30;11
  SRMLOP14 NOT ENCLOSE SRM          // sram 0.299 cell must have 50;0
  SRMLOP14 NOT ENCLOSE NPreDOSRM    // sram 0.299 cell must have 50;21
  SRMLOP14 NOT ENCLOSE DUMMYOD1     // sram 0.299 cell must have 82;1
  SRMLOP14 NOT ENCLOSE DUMMYOD2     // sram 0.299 cell must have 82;2
  SRMLOP14 NOT ENCLOSE DUMMYOD9     // sram 0.299 cell must have 82;9
  SRMLOP14 NOT ENCLOSE DUMMYOD10    // sram 0.299 cell must have 82;10
  SRMLOP14 NOT ENCLOSE DUMMYOD11    // sram 0.299 cell must have 82;11
  SRMLOP14 NOT ENCLOSE DUMMYOD12    // sram 0.299 cell must have 82;12
  SRMLOP14 NOT ENCLOSE DUMMYOD16    // sram 0.299 cell must have 82;16
  SRMLOP14 NOT ENCLOSE DUMMYPO1     // sram 0.299 cell must have 83;1
  SRMLOP14 NOT ENCLOSE DUMMYPO2     // sram 0.299 cell must have 83;2
  SRMLOP14 NOT ENCLOSE DUMMYPO3     // sram 0.299 cell must have 83;3
  SRMLOP14 NOT ENCLOSE DUMMYPO4     // sram 0.299 cell must have 83;4
  SRMLOP14 NOT ENCLOSE DUMMYPO5     // sram 0.299 cell must have 83;5
  SRMLOP14 NOT ENCLOSE DUMMYPO7     // sram 0.299 cell must have 83;7
  SRMLOP14 NOT ENCLOSE SRAMDMY      // sram 0.299 cell must have 186;0
  SRMLOP14 NOT ENCLOSE SRAMDMY_PAS  // sram 0.299 cell must have 186;1
  SRMLOP14 NOT ENCLOSE CO2          // sram 0.299 cell must have 100;0
}
SRAM.R.33:HCDPLOP { @ (80;16) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  HCDPLOP NOT ENCLOSE COPUSH       // sram DP_0.741 cell must have 30;11
  HCDPLOP NOT ENCLOSE SRM          // sram DP_0.741 cell must have 50;0
  HCDPLOP NOT ENCLOSE NPreDOSRM    // sram DP_0.741 cell must have 50;21
  HCDPLOP NOT ENCLOSE DUMMYOD1     // sram DP_0.741 cell must have 82;1
  HCDPLOP NOT ENCLOSE DUMMYOD2     // sram DP_0.741 cell must have 82;2
  HCDPLOP NOT ENCLOSE DUMMYOD9     // sram DP_0.741 cell must have 82;9
  HCDPLOP NOT ENCLOSE DUMMYOD10    // sram DP_0.741 cell must have 82;10
  HCDPLOP NOT ENCLOSE DUMMYOD11    // sram DP_0.741 cell must have 82;11
  HCDPLOP NOT ENCLOSE DUMMYOD12    // sram DP_0.741 cell must have 82;12
  HCDPLOP NOT ENCLOSE DUMMYOD16    // sram DP_0.741 cell must have 82;16
  HCDPLOP NOT ENCLOSE DUMMYPO1     // sram DP_0.741 cell must have 83;1
  HCDPLOP NOT ENCLOSE DUMMYPO2     // sram DP_0.741 cell must have 83;2
  HCDPLOP NOT ENCLOSE DUMMYPO3     // sram DP_0.741 cell must have 83;3
  HCDPLOP NOT ENCLOSE DUMMYPO4     // sram DP_0.741 cell must have 83;4
  HCDPLOP NOT ENCLOSE DUMMYPO5     // sram DP_0.741 cell must have 83;5
  HCDPLOP NOT ENCLOSE DUMMYPO7     // sram DP_0.741 cell must have 83;7
  HCDPLOP NOT ENCLOSE SRAMDMY      // sram DP_0.741 cell must have 186;0
  HCDPLOP NOT ENCLOSE SRAMDMY_PAS  // sram DP_0.741 cell must have 186;1
  HCDPLOP NOT ENCLOSE CO2          // sram DP_0.741 cell must have 100;0
}

// SRAM.R.33 is checked by SRAM.R.33:DPSRM, SRAM.R.33:SRMLOP14, and SRAM.R.33:HCDPLOP

SRAM.R.34:DPSRM { @ (80;0) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  DPSRM AND SRMRP                // sram 0.589 cell must not have 50;5
  DPSRM AND SRM_HS               // sram 0.589 cell must not have 50;7
  DPSRM AND DUMMYOD15            // sram 0.589 cell must not have 82;15
  DPSRM AND DUMMYPO6             // sram 0.589 cell must not have 83;6
  DPSRM AND SRAMDMY_PERI_LP         // sram 0.589 cell must not have 186;4
  DPSRM AND SRAMDMY_PERI_G       // sram 0.589 cell must not have 186;5
}
SRAM.R.34:SRMLOP13 { @ (80;13) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)

  SRMLOP13 AND SRMRP                // sram 0.374 cell must not have 50;5
  SRMLOP13 AND SRM_HS               // sram 0.374 cell must not have 50;7
  SRMLOP13 AND DUMMYOD15            // sram 0.374 cell must not have 82;15
  SRMLOP13 AND DUMMYPO6             // sram 0.374 cell must not have 83;6
  SRMLOP13 AND SRAMDMY_PERI_LP         // sram 0.374 cell must not have 186;4
  SRMLOP13 AND SRAMDMY_PERI_G       // sram 0.374 cell must not have 186;5
}
SRAM.R.34:SRMLOP14 { @ (80;14) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  SRMLOP14 AND SRMRP                // sram 0.299 cell must not have 50;5
  SRMLOP14 AND SRM_HS               // sram 0.299 cell must not have 50;7
  SRMLOP14 AND DUMMYOD15            // sram 0.299 cell must not have 82;15
  SRMLOP14 AND DUMMYPO6             // sram 0.299 cell must not have 83;6
  SRMLOP14 AND SRAMDMY_PERI_LP         // sram 0.299 cell must not have 186;4
  SRMLOP14 AND SRAMDMY_PERI_G       // sram 0.299 cell must not have 186;5
}
SRAM.R.34:HCDPLOP { @ (80;16) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  HCDPLOP AND SRMRP                // sram DP_0.741 cell must not have 50;5
  HCDPLOP AND SRM_HS               // sram DP_0.741 cell must not have 50;7
  HCDPLOP AND DUMMYOD15            // sram DP_0.741 cell must not have 82;15
  HCDPLOP AND DUMMYPO6             // sram DP_0.741 cell must not have 83;6
  HCDPLOP AND SRAMDMY_PERI_LP      // sram DP_0.741 cell must not have 186;4
  HCDPLOP AND SRAMDMY_PERI_G       // sram DP_0.741 cell must not have 186;5
}

// SRAM.R.34 is checked by SRAM.R.34:DPSRM
// SRAM.R.34 is checked by SRAM.R.34:SRMLOP13
// SRAM.R.34 is checked by SRAM.R.34:SRMLOP14
// SRAM.R.34 is checked by SRAM.R.34:HCDPLOP

SRAM.R.35:DPSRM { @ (80;0) must fully cover (82;Y).  Y=3,4,5,6,7,8
  DPSRM NOT ENCLOSE DUMMYOD3     // sram 0.589 cell must have 82;3
  DPSRM NOT ENCLOSE DUMMYOD4     // sram 0.589 cell must have 82;4
  DPSRM NOT ENCLOSE DUMMYOD5     // sram 0.589 cell must have 82;5
  DPSRM NOT ENCLOSE DUMMYOD6     // sram 0.589 cell must have 82;6
  DPSRM NOT ENCLOSE DUMMYOD7     // sram 0.589 cell must have 82;7
  DPSRM NOT ENCLOSE DUMMYOD8     // sram 0.589 cell must have 82;8
}
SRAM.R.35:SRMLOP13 { @ (80;13) must fully cover (82;Y).  Y=3,4,5,6,7,8
  SRMLOP13 NOT ENCLOSE DUMMYOD3     // sram 0.374 cell must have 82;3
  SRMLOP13 NOT ENCLOSE DUMMYOD4     // sram 0.374 cell must have 82;4
  SRMLOP13 NOT ENCLOSE DUMMYOD5     // sram 0.374 cell must have 82;5
  SRMLOP13 NOT ENCLOSE DUMMYOD6     // sram 0.374 cell must have 82;6
  SRMLOP13 NOT ENCLOSE DUMMYOD7     // sram 0.374 cell must have 82;7
  SRMLOP13 NOT ENCLOSE DUMMYOD8     // sram 0.374 cell must have 82;8
}
SRAM.R.35:SRMLOP14 { @ (80;14) must fully cover (82;Y).  Y=3,4,5,6,7,8
  SRMLOP14 NOT ENCLOSE DUMMYOD3     // sram 0.299 cell must have 82;3
  SRMLOP14 NOT ENCLOSE DUMMYOD4     // sram 0.299 cell must have 82;4
  SRMLOP14 NOT ENCLOSE DUMMYOD5     // sram 0.299 cell must have 82;5
  SRMLOP14 NOT ENCLOSE DUMMYOD6     // sram 0.299 cell must have 82;6
  SRMLOP14 NOT ENCLOSE DUMMYOD7     // sram 0.299 cell must have 82;7
  SRMLOP14 NOT ENCLOSE DUMMYOD8     // sram 0.299 cell must have 82;8
}

// SRAM.R.35 is checked by SRAM.R.35:DPSRM, SRAM.R.35:SRMLOP13, and SRAM.R.35:SRMLOP14

SRAM.R.36 { @ (80;16) must not have (82;Y). Y=3,4,5,6,7,8
  HCDPLOP AND DUMMYOD3     // sram DP_0.741 cell must not have 82;3
  HCDPLOP AND DUMMYOD4     // sram DP_0.741 cell must not have 82;4
  HCDPLOP AND DUMMYOD5     // sram DP_0.741 cell must not have 82;5
  HCDPLOP AND DUMMYOD6     // sram DP_0.741 cell must not have 82;6
  HCDPLOP AND DUMMYOD7     // sram DP_0.741 cell must not have 82;7
  HCDPLOP AND DUMMYOD8     // sram DP_0.741 cell must not have 82;8
}

SRAM.R.37 { @ (50;6) can not be used in (50;0) region
  ROM AND SRM
}

SRAM.R.38:DPSRM { @ (80;0) must fully cover (82;13) and (82;14)
  DPSRM NOT ENCLOSE DUMMYOD13    // sram 0.589 cell must have 82;13
  DPSRM NOT ENCLOSE DUMMYOD14    // sram 0.589 cell must have 82;14
}
SRAM.R.38:SRMLOP { @ (80;14) must fully cover (82;13) and (82;14)
  SRMLOP14 NOT ENCLOSE DUMMYOD13    // sram 0.299 cell must have 82;13
  SRMLOP14 NOT ENCLOSE DUMMYOD14    // sram 0.299 cell must have 82;14
}
SRAM.R.38:HCDPLOP { @ (80;16) must fully cover (82;13) and (82;14)
  HCDPLOP NOT ENCLOSE DUMMYOD13    // sram DP_0.741 cell must have 82;13
  HCDPLOP NOT ENCLOSE DUMMYOD14    // sram DP_0.741 cell must have 82;14
}

// SRAM.R.38 is checked by SRAM.R.38:DPSRM, SRAM.R.38:SRMLOP, and SRAM.R.38:HCDPLOP

SRAM.R.39 { @ (80;13) must not have (82;13) and (82;14)
  SRMLOP13 AND DUMMYOD13    // sram 0.374 cell must have 82;13
  SRMLOP13 AND DUMMYOD14    // sram 0.374 cell must have 82;14
}

SRAM.R.40 { @ (80;13) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=3,4,5,7
  SRMLOP13 NOT ENCLOSE COPUSH       // sram 0.374 cell must have 30;11
  SRMLOP13 NOT ENCLOSE SRM          // sram 0.374 cell must have 50;0
  SRMLOP13 NOT ENCLOSE NPreDOSRM    // sram 0.374 cell must have 50;21
  SRMLOP13 NOT ENCLOSE DUMMYOD1     // sram 0.374 cell must have 82;1
  SRMLOP13 NOT ENCLOSE DUMMYOD2     // sram 0.374 cell must have 82;2
  SRMLOP13 NOT ENCLOSE DUMMYOD9     // sram 0.374 cell must have 82;9
  SRMLOP13 NOT ENCLOSE DUMMYOD10    // sram 0.374 cell must have 82;10
  SRMLOP13 NOT ENCLOSE DUMMYOD11    // sram 0.374 cell must have 82;11
  SRMLOP13 NOT ENCLOSE DUMMYOD12    // sram 0.374 cell must have 82;12
  SRMLOP13 NOT ENCLOSE DUMMYOD16    // sram 0.374 cell must have 82;16
  SRMLOP13 NOT ENCLOSE DUMMYPO3     // sram 0.374 cell must have 83;3
  SRMLOP13 NOT ENCLOSE DUMMYPO4     // sram 0.374 cell must have 83;4
  SRMLOP13 NOT ENCLOSE DUMMYPO5     // sram 0.374 cell must have 83;5
  SRMLOP13 NOT ENCLOSE DUMMYPO7     // sram 0.374 cell must have 83;7
  SRMLOP13 NOT ENCLOSE SRAMDMY      // sram 0.374 cell must have 186;0
  SRMLOP13 NOT ENCLOSE SRAMDMY_PAS  // sram 0.374 cell must have 186;1
  SRMLOP13 NOT ENCLOSE CO2          // sram 0.374 cell must have 100;0
}

SRAM.R.41 { @ NMOS gate in SRM (50;0) must be fully covered by (50;21) (Except RODMY(49;0) region)
  (((GATEi AND SRM) AND NPi ) NOT NPreDOSRM) NOT RODMY
}

SRAM.R.42 { @ BTC in NW in one unit cell must be a pair, except DPSRM (80;0), SRM_HCDP (80;16), and SRM_10TTP (80;18) cells. DRC only checks: {{{{BTC AND NW} NOT {{DPSRM OR SRM_HCDP} OR SRM_10TTP}} SIZING 0.05 um} INTERACT BTC} = 2   
  X = (BTC AND NWi) NOT ((DPSRM OR HCDPLOP) OR TPLOP_10T)
  Y = SIZE X BY 0.05
  Y INTERACT BTC != 2

}

SRAM.WARN.1 { @ Warning: It is important to add different redundancies according to different memory densities, if the total SRAM area for only N40GL (Vnom = 0.8V usage) in one chip is > 3,231,000 um2 (e.g. 8Mb of N40GL 0.374 um2 cell), or if the total SRAM area for all cells (including N40GL 0.8V usage) in one chip is > 5,168,000 um2 (e.g. 16Mb of 0.299 um2 cell). Please refer to T-000-CL-RP-002, TSMC EMBEDDED SRAM REDUNDANCY IMPLEMENTATION RULE AND ECC GUIDELINE, for the details. DRC only flags the total SRM (50;0) area in one chip > 5,168,000 um2   
  DENSITY SRM > SRAM_WARN_1 INSIDE OF LAYER CHIPx
  [AREA(SRM)] RDB SRAM.WARN.1.rep
}
SRAM.WARN.2 { @ Warning: It is important to add ECC (Error Correcting-Code), if the total SRAM area for all cells in one chip is > 10,336,000 um2 (e.g. 32Mb of 0.299 um2 cell). Please refer to T-000-CL-RP-002, TSMC EMBEDDED SRAM REDUNDANCY IMPLEMENTATION RULE AND ECC GUIDELINE, for the details. DRC only flags the total SRM (50;0) area in one chip > 10,336,000 um2. For ECC implementation, please consult TSMC QR based on product operation spec   
  DENSITY SRM > SRAM_WARN_2 INSIDE OF LAYER CHIPx
  [AREA(SRM)] RDB SRAM.WARN.2.rep
}



//NPre CHECKS
//============

NPre.W.1 { @ Width >= ^NPre_W_1
  INT NPreDOSRM < NPre_W_1 ABUT < 90 SINGULAR REGION
}
NPre.S.1 { @ Space >= ^NPre_S_1
  EXT NPreDOSRM < NPre_S_1 ABUT < 90 SINGULAR REGION
}
NPre.S.2 { @ Space to P+ACTIVE (non-butted) >= ^NPre_S_2
  EXT NPreDOSRM PACT < NPre_S_2 ABUT < 90 > 0 SINGULAR REGION
}

// NPre.S.3 is checked by NPre.S.2 and NPre.S.4

NPre.S.4 { @ Space to PW STRAP (non-butted) >= ^NPre_S_4
  EXT NPreDOSRM PSTP < NPre_S_4 ABUT < 90 > 0 SINGULAR REGION
}
NPre.S.5 { @ {NPre edge on OD} space to PMOS GATE >= ^NPre_S_5
  A = NPreDOSRM INSIDE EDGE OD
  EXT GATEP_W A < NPre_S_5 ABUT < 90 OPPOSITE REGION
}
NPre.S.7 { @ Space to P-type unsilicided OD/PO resistor >= ^NPre_S_7
  EXT NPreDOSRM ODPO_RES_RPO_PP  < NPre_S_7 ABUT < 90 SINGULAR REGION
}
NPre.EX.4 { @ {NPre edge on OD} extension on NMOS GATE in SRM (50;0), except RODMY (49;0) >= ^NPre_EX_4
  A = NPreDOSRM INSIDE EDGE OD
  B = ((GATEi AND SRM) AND NPi ) NOT RODMY
  ENC B A < NPre_EX_4 ABUT < 90 OPPOSITE REGION
}
NPre.O.1 { @ Overlap of OD >= ^NPre_O_1
  INT OD NPreDOSRM < NPre_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NPre.A.1 { @ Area >= ^NPre_A_1
  AREA NPreDOSRM < NPre_A_1
}
NPre.A.2 { @ Enclosed area >= ^NPre_A_2
  A = HOLES NPreDOSRM INNER
  B = A NOT NPreDOSRM
  AREA B < NPre_A_2
}
NPre.R.2 { @ Overlap of PP is not allowed
  NPreDOSRM AND PP
}
NPre.L.1 { @ 45-degree edge length >= ^NPre_L_1
  NPre_45ANGLE = NPreDOSRM ANGLE == 45
  LENGTH NPre_45ANGLE < NPre_L_1
}


// WLD CHECKS
//============

OD_PERI = ODi AND SRAMDMY_PERI
CO_PERI = COi NOT OUTSIDE SRAMDMY_PERI

WLD.R.2 { @ {CO AND SRAMDMY (186;4/5)} space to PO >= 0.035 
  EXT CO_PERI POi < WLD_R_2 ABUT < 90 SINGULAR REGION
}

COOD_PERI = CO_PERI NOT OUTSIDE OD_PERI
CONNECT COOD_PERI OD_PERI
WLD.R.3 { @ CO space on the same OD [inside SRAMDMY (186;4 & 186;5)] >= 0.1
  EXT COOD_PERI < WLD_R_3 ABUT < 90 CONNECTED SINGULAR REGION
}

WLD.R.6 { @ SRAMDMY (186;4/5) edge cut CO is not allowed   
  CO_PERI CUT SRAMDMY_PERI_LP
  CO_PERI CUT SRAMDMY_PERI_G
}

WLD.R.7 { @ SRAMDMY;0 (186;0) SIZING 100 um must cover SRAMDMY;5 (186;5) or SRAMDMY;4 (186;4)   
  S = SIZE SRAMDMY BY WLD_R_7
  SRAMDMY_PERI_LP NOT S
  SRAMDMY_PERI_G NOT S
}

WLDR8_GATE = GATEi NOT OUTSIDE SRAMDMY_PERI
WLDR8_GATE_W = POi COIN INSIDE EDGE WLDR8_GATE
WLDR8_GATE_W_V = EXPAND EDGE (ANGLE WLDR8_GATE_W == 90) INSIDE BY GRID
WLDR8_GATE_W_H = EXPAND EDGE (ANGLE WLDR8_GATE_W == 0) INSIDE BY GRID
WLDR8_V = CHIP INTERACT WLDR8_GATE_W_V
WLDR8_H = CHIP INTERACT WLDR8_GATE_W_H

WLDR8_V_BAD = WLDR8_V INTERACT POR7_GATE_W_H
WLDR8_H_BAD = WLDR8_H INTERACT POR7_GATE_W_V


WLD.R.8:V { @ Gate direction on the WL driver must be same as gate on the SRAM (Unique direction)
  WLDR8_GATE_W_V AND WLDR8_V_BAD
}

WLD.R.8:H { @ Gate direction on the WL driver must be same as gate on the SRAM (Unique direction)
  WLDR8_GATE_W_H AND WLDR8_H_BAD
}

// WLD.R.8 is checked by WLD.R.8:V and WLD.R.8:H

WLD.R.9 { @ At least 2 COs are required at both source and drain side on WL driver(186;4/5) region
  SD_C = (NSDi OR PSDi) AND SRAMDMY_PERI
  SD_C NOT INTERACT COi >= WLD_R_9
}



//HVD_N CHECKS
//============

HVD_NGATE_25 = HVD_NGATE AND OD25
HVD_PGATE_25 = HVD_PGATE AND OD25
18V_GATE_L   = HV_GATE_L INSIDE EDGE OD18
25V_GATE_L   = HV_GATE_L INSIDE EDGE OD25
HVD_NMOS_SOURCE = SD NOT INTERACT HVD_N
HVD_PMOS_SOURCE = SD NOT INTERACT HVD_P

HVDN_ON_GATE = HVD_NGATE_25 AND HVD_N
HVDN_L = HVDN_ON_GATE COIN INSIDE EDGE 25V_GATE_L
EXPAND_RIGION_N = EXPAND EDGE HVDN_L BY HVD_N25_S_7

HVDP_ON_GATE = HVD_PGATE_25 AND HVD_P
HVDP_L = HVDP_ON_GATE COIN INSIDE EDGE 25V_GATE_L
EXPAND_RIGION_P_tmp = EXPAND EDGE HVDP_L BY HVD_P25_S_7
EXPAND_RIGION_P = (EXPAND EDGE (EXPAND_RIGION_P_tmp COIN INSIDE EDGE HVD_P) BY HVD_P25_S_8) OR EXPAND_RIGION_P_tmp

GATE_HVDN25 = (GATE INTERACT OD25) INTERACT HVD_N
GATE_HVDP25 = (GATE INTERACT OD25) INTERACT HVD_P


HVD_N_25V_GATE_W = 25V_GATE_W COIN EDGE (GATE INTERACT HVD_N)

HVD_P_25V_GATE_W = 25V_GATE_W COIN EDGE (GATE INTERACT HVD_P)

HVD_NGATE_18 = HVD_NGATE AND OD18
HVD_PGATE_18 = HVD_PGATE AND OD18
HVDN_ON_GATE18 = HVD_NGATE_18 AND HVD_N
HVDN_L18 = HVDN_ON_GATE18 COIN INSIDE EDGE 18V_GATE_L
EXPAND_RIGION_N18 = EXPAND EDGE HVDN_L18 BY HVD_N18_S_7

HVDP_ON_GATE18 = HVD_PGATE_18 AND HVD_P
HVDP_L18 = HVDP_ON_GATE18 COIN INSIDE EDGE 18V_GATE_L
EXPAND_RIGION_P_tmp18 = EXPAND EDGE HVDP_L18 BY HVD_P18_S_7
EXPAND_RIGION_P18 = (EXPAND EDGE (EXPAND_RIGION_P_tmp18 COIN INSIDE EDGE HVD_P) BY HVD_P18_S_8) OR EXPAND_RIGION_P_tmp18

GATE_HVDN18 = (GATE INTERACT OD18) INTERACT HVD_N
GATE_HVDP18 = (GATE INTERACT OD18) INTERACT HVD_P

HVD_N_18V_GATE_W = 18V_GATE_W COIN EDGE (GATE INTERACT HVD_N)
HVD_P_18V_GATE_W = 18V_GATE_W COIN EDGE (GATE INTERACT HVD_P)

SD_EDGE_pre = (OD NOT SR_POLY) INTERACT GATE > 1

HVDS12_GATE = GATEi INTERACT (HVD_N OR HVD_P)
HVDS12_GATE_W = POi COIN INSIDE EDGE HVDS12_GATE
HVDS12_GATE_V = HVDS12_GATE INTERACT (EXPAND EDGE (ANGLE HVDS12_GATE_W == 90) INSIDE BY GRID)
HVDS12_GATE_H = HVDS12_GATE INTERACT (EXPAND EDGE (ANGLE HVDS12_GATE_W == 0) INSIDE BY GRID)

HVD_N25.W.1__HVD_N18.W.1 { @ Width >= 0.47 
  INT HVD_N < HVD_N25_W_1 ABUT < 90 SINGULAR REGION
}
#IFDEF HVMOS_25
HVD_N25.W.2 { @ Channel width of {Gate INTERACT HVD_N} >= ^HVD_N25_W_2
  LENGTH HVD_N_25V_GATE_W < HVD_N25_W_2
}
// HVD_N25.W.2.S is checked by HVD_N25.W.2
#ENDIF
#IFDEF HVMOS_18
HVD_N18.W.2 { @ Channel width of {Gate INTERACT HVD_N} for SPICE accuracy >= 0.67 
  LENGTH HVD_N_18V_GATE_W < HVD_N18_W_2
}
#ENDIF
HVD_N25.S.1__HVD_N18.S.1 { @ Space >= 0.47 
  EXT HVD_N < HVD_N25_S_1 ABUT < 90 SINGULAR REGION
}
HVD_N25.S.2__HVD_N18.S.2 { @ Space of 2 HVD_N with different potentials >= 1.37 
  A = STAMP HVD_N BY NSDc
  EXT A < HVD_N25_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
  B = HVD_N NOT INTERACT NSDc
  EXT B HVD_N < HVD_N25_S_2 ABUT < 90 SINGULAR REGION SPACE
}
HVD_N25.S.3__HVD_N18.S.3 { @ Space to NW >= 1.6 
  EXT HVD_N NWEL < HVD_N25_S_3 ABUT < 90 SINGULAR REGION
}
HVD_N25.S.4__HVD_N18.S.4 { @ Space to PW STRAP (overlap is not allowed) >= 0.3 
  EXT HVD_N PSTP < HVD_N25_S_4 ABUT < 90 SINGULAR REGION
  HVD_N AND PSTP
}
HVD_N25.S.5__HVD_N18.S.5 { @ Space to N+ ACTIVE >= 0.6 
  EXT HVD_N NACT < HVD_N25_S_5 ABUT < 90 SINGULAR REGION
}
HVD_N25.S.6__HVD_N18.S.6 { @ Space to DNW (overlap is not allowed) >= 3 
  EXT HVD_N DNW < HVD_N25_S_6 ABUT < 90 SINGULAR REGION
  HVD_N AND DNW
}
#IFDEF HVMOS_25
HVD_N25.S.7 { @ {CO INSIDE PO} space to {OD AND HVD_N} in PO end-cap direction. {CO INSIDE PO} can't overlap HVD_N >= 0.52 
  CO_PO = CO INSIDE POLY
  CO_PO AND EXPAND_RIGION_N
  CO_PO AND HVD_N
}
HVD_N25.S.8 { @ Gate space in drain direction for a multi-finger HVNMOS device. DRC checks: {{Space of {Gate INTERACT HVD_N}} INSIDE HVD_N} in one OD = 1.26 
  DRAIN_EDGE_pre = HVD_N_25V_GATE_W INSIDE EDGE HVD_N
  DRAIN_EDGE = DRAIN_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre
  EXT DRAIN_EDGE < HVD_N25_S_8 ABUT < 90 REGION 
  A = EXPAND EDGE DRAIN_EDGE OUTSIDE BY HVD_N25_S_8/2
  HVD_NMOS_DRAIN INTERACT A > 1
}
HVD_N25.S.9 { @ Gate space in source direction for a multi-finger HVNMOS device. DRC checks: {{Space of {Gate INTERACT HVD_N}} OUTSIDE HVD_N} in one OD = 0.22 
  SOURCE_EDGE_pre = HVD_N_25V_GATE_W NOT INSIDE EDGE HVD_N
  SOURCE_EDGE = SOURCE_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre 
  EXT SOURCE_EDGE < HVD_N25_S_9 ABUT < 90 REGION 
  A = EXPAND EDGE SOURCE_EDGE OUTSIDE BY HVD_N25_S_9/2
  HVD_NMOS_SOURCE INTERACT A > 1
}
HVD_N25.S.10 { @ {Gate INTERACT HVD_N} space to {NW OR NT_N}. {Gate INTERACT HVD_N} can't overlap {NW OR NT_N} >= 2.0 
  EXT GATE_HVDN25 (NWi OR NTNi) < HVD_N25_S_10 ABUT < 90 SINGULAR REGION
  GATE_HVDN25 AND (NWi OR NTNi)
}
HVD_N25.S.11 { @ {CO INSIDE drain side OD} space to {HVD GATE OVERLAP OD_25} [inside HVD_N] >= ^HVD_N25_S_11
  CO_HV_DRAIN = CO INSIDE HVD_NMOS_DRAIN
  EXT CO_HV_DRAIN GATE_HVDN25 < HVD_N25_S_11 ABUT < 90 SINGULAR REGION 
}
// HVD_N25.S.11.S is checked by HVD_N25.S.11

#ENDIF
#IFDEF HVMOS_18
HVD_N18.S.7 { @ {CO INSIDE PO} space to {OD AND HVD_N} in PO end-cap direction. {CO INSIDE PO} can't overlap HVD_N >= 0.52 
  CO_PO = CO INSIDE POLY
  CO_PO AND EXPAND_RIGION_N18
  CO_PO AND HVD_N
}
HVD_N18.S.8 { @ Gate space in drain direction for a multi-finger HVNMOS device. DRC checks: {{Space of {Gate INTERACT HVD_N}} INSIDE HVD_N} in one OD = 1.26 
  DRAIN_EDGE_pre = HVD_N_18V_GATE_W INSIDE EDGE HVD_N
  DRAIN_EDGE = DRAIN_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre
  EXT DRAIN_EDGE < HVD_N18_S_8 ABUT < 90 REGION 
  A = EXPAND EDGE DRAIN_EDGE OUTSIDE BY HVD_N18_S_8/2
  HVD_NMOS_DRAIN INTERACT A > 1
}
HVD_N18.S.9 { @ Gate space in source direction for a multi-finger HVNMOS device. DRC checks: {{Space of {Gate INTERACT HVD_N}} OUTSIDE HVD_N} in one OD = 0.22 
  SOURCE_EDGE_pre = HVD_N_18V_GATE_W NOT INSIDE EDGE HVD_N
  SOURCE_EDGE = SOURCE_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre
  EXT SOURCE_EDGE < HVD_N18_S_9 ABUT < 90 REGION 
  A = EXPAND EDGE SOURCE_EDGE OUTSIDE BY HVD_N18_S_9/2
  HVD_NMOS_SOURCE INTERACT A > 1
}
HVD_N18.S.10 { @ {Gate INTERACT HVD_N} space to {NW OR NT_N}. {Gate INTERACT HVD_N} can't overlap {NW OR NT_N} >= 2.0 
  EXT GATE_HVDN18 (NWi OR NTNi) < HVD_N18_S_10 ABUT < 90 SINGULAR REGION
  GATE_HVDN18 AND (NWi OR NTNi)
}
HVD_N18.S.11 { @ {CO INSIDE drain side OD} space to {HVD GATE OVERLAP OD_18} [INSIDE HVD_N] >= 0.6 
  CO_HV_DRAIN = CO INSIDE HVD_NMOS_DRAIN
  EXT CO_HV_DRAIN GATE_HVDN18 < HVD_N18_S_11 ABUT < 90 SINGULAR REGION 
}
#ENDIF
HVD_N25.S.12__HVD_N18.S.12 { @ {PO OR OD} space to {OD INTERACT HVD_N} in PO end-cap direction for high Rs concern >= 0.6 
  X = OD INTERACT HVD_N
  X_V = ANGLE (X INTERACT HVDS12_GATE_V) == 0
  X_H = ANGLE (X INTERACT HVDS12_GATE_H) == 90
  Y = OD OR POLY
  EXT X_V Y < HVD_N25_S_12 ABUT < 90 REGION
  EXT X_H Y < HVD_N25_S_12 ABUT < 90 REGION
}
HVD_N25.S.13__HVD_N18.S.13 { @ HVD_N Space to {SR_DOD OR DOD} (overlap is not allowed) >= 0.16
  A = SRDOD OR DOD
  EXT HVD_N A < HVD_N25_S_13 ABUT < 90 SINGULAR REGION
  HVD_N AND A 
}
HVD_N25.EN.1__HVD_N18.EN.1 { @ {Gate INTERACT HVD_N} enclosure by OD2. {Gate INTERACT HVD_N} must be inside OD2 >= 2.0 
  ENC (GATE INTERACT HVD_N) OD2 < HVD_N25_EN_1 ABUT < 90 SINGULAR REGION
  (GATE INTERACT HVD_N) NOT OD2
}
HVD_N25.EX.1__HVD_N18.EX.1 { @ Extension on N+ ACTIVE (Drain side must be fully inside HVD_N) >= 0.24 
  ENC NACT HVD_N < HVD_N25_EX_1 ABUT < 90 SINGULAR REGION
  HVD_NMOS_DRAIN NOT HVD_N
}
#IFDEF HVMOS_25
HVD_N25.O.1 { @ Overlap of {I/O NMOS GATE} = ^HVD_N25_O_1
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_NMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_N25_O_1
  C = HVD_N AND HVD_NGATE
  C XOR B 
  HVD_NGATE INTERACT B > 1
}
// HVD_N25.O.1.S is checked by HVD_N25.O.1
HVD_N25.L.1 { @ Channel length of {gate interact with HVD_N} >= ^HVD_N25_L_1
  A = HV_GATE_W COIN INSIDE EDGE HVD_NGATE 
  INT A < HVD_N25_L_1 ABUT < 90 REGION
}
// HVD_N25.L.1.S is checked by HVD_N25.L.1
#ENDIF
#IFDEF HVMOS_18
HVD_N18.O.1 { @ Overlap of {I/O NMOS GATE} = 0.33 
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_NMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_N18_O_1
  C = HVD_N AND HVD_NGATE
  C XOR B 
  HVD_NGATE INTERACT B > 1
}
HVD_N18.L.1 { @ Channel length of {GATE INTERACT HVD_N} >= 0.88 
  A = HV_GATE_W COIN INSIDE EDGE HVD_NGATE 
  INT A < HVD_N18_L_1 ABUT < 90 REGION
}
#ENDIF
HVD_N25.A.1__HVD_N18.A.1 { @ Area >= 0.64 
  AREA HVD_N < HVD_N25_A_1
}
HVD_N25.A.2__HVD_N18.A.2 { @ Enclosed area >= 0.64 
  A = HOLES HVD_N INNER
  B = A NOT HVD_N
  AREA B < HVD_N25_A_2
}
HVD_N25.R.1__HVD_N18.R.1 { @ Overlap of NW is not allowed   
  HVD_N AND NWEL 
}
HVD_N25.R.2__HVD_N18.R.2 { @ HVD_N edge landing on OD without landing on GATE is not allowed   
  (HVD_N INSIDE EDGE OD) NOT INSIDE EDGE GATE
}
#IFDEF HVMOS_25
HVD_N25.R.3 { @ HVD_N must be fully inside OD_25   
  HVD_N NOT OD25 
}
#ENDIF
#IFDEF HVMOS_18
HVD_N18.R.3 { @ HVD_N must be fully inside OD_18   
  HVD_N NOT OD18
}
#ENDIF
HVD_N25.R.4__HVD_N18.R.4 { @ {(OD NOT PO) INSIDE one HVD_N} must be the same potential   
  HVD_N INTERACT NSDc > 1 BY NET 
}
HVD_N25.R.7__HVD_N18.R.7 { @ {{OD OR PO} INTERACT HVD_N} overlap of VAR, NT_N, TCDDMY, {OD AND NWDMY}, SRM, ROM, BJTDMY, RH, or POFUSE is not allowed   
  A = (ODi OR POi) INTERACT HVD_N
  A AND VARi
  A AND NTNi
  A AND TCDDMY
  A AND (OD AND NWDMY)
  A AND SRM
  A AND ROM
  A AND BJTDMY
  A AND RH
  A AND POFUSE
}
//HVD_P CHECKS
//============

HVD_P25.W.1__HVD_P18.W.1 { @ Width >= 0.47 
  INT HVD_P < HVD_P25_W_1 ABUT < 90 SINGULAR REGION
}
#IFDEF HVMOS_25
HVD_P25.W.2 { @ Channel width of {Gate INTERACT HVD_P} >= ^HVD_P25_W_2
  LENGTH HVD_P_25V_GATE_W < HVD_P25_W_2
}
// HVD_P25.W.2.S is checked by HVD_P25.W.2
#ENDIF
#IFDEF HVMOS_18
HVD_P18.W.2 { @ Channel width of {Gate INTERACT HVD_P} for SPICE accuracy >= 0.67 
  LENGTH HVD_P_18V_GATE_W < HVD_P18_W_2
}
#ENDIF
HVD_P25.S.1__HVD_P18.S.1 { @ Space >= 0.47 
  EXT HVD_P < HVD_P25_S_1 ABUT < 90 SINGULAR REGION
}
HVD_P25.S.2__HVD_P18.S.2 { @ Space of 2 HVD_P with different potentials >= 1.2 
  A = STAMP HVD_P BY PSDc 
  EXT A < HVD_P25_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
  B = HVD_P NOT INTERACT PSDc
  EXT B HVD_P < HVD_P25_S_2 ABUT < 90 SINGULAR REGION SPACE
}
HVD_P25.S.4__HVD_P18.S.4 { @ Space to NW STRAP (overlap is not allowed) >= 0.24 
  EXT HVD_P NSTP < HVD_P25_S_4 ABUT < 90 SINGULAR REGION
  HVD_P AND NSTP
}
HVD_P25.S.5__HVD_P18.S.5 { @ Space to P+ ACTIVE >= 0.48 
  EXT HVD_P PACT < HVD_P25_S_5 ABUT < 90 SINGULAR REGION
}
HVD_P25.S.6__HVD_P18.S.6 { @ {NW INTERACT HVD_P} space to NW with different potentials >= 2.0 
  NW_HVD_P = NWEL INTERACT HVD_P
  NW_HVD_Pc = STAMP NW_HVD_P BY NWi
  NW_HVD_Pn = NWEL NOT INTERACT HVD_P
  NW_HVD_Pnc = STAMP NW_HVD_Pn BY NWi
  EXT NW_HVD_Pc < HVD_P25_S_6 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED
  EXT NW_HVD_Pc NW_HVD_Pnc < HVD_P25_S_6 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED
}
#IFDEF HVMOS_25
HVD_P25.S.7__HVD_P25.S.8 { @ {CO INSIDE PO} space to {OD AND HVD_P} in PO end-cap direction. {CO INSIDE PO} can't overlap HVD_P >= 0.52 
                           @ /HVD_P25.S.8/
  CO_PO = CO INSIDE POLY
  CO_PO AND EXPAND_RIGION_P
  CO_PO AND HVD_P
}
HVD_P25.S.9 { @ Gate space in drain direction for a multi-finger HVPMOS device. DRC checks: {{Space of {Gate INTERACT HVD_P}} INSIDE HVD_P} in one OD = 1.26 
  DRAIN_EDGE_pre = HVD_P_25V_GATE_W INSIDE EDGE HVD_P
  DRAIN_EDGE = DRAIN_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre
  EXT DRAIN_EDGE < HVD_P25_S_9 ABUT < 90 REGION 
  A = EXPAND EDGE DRAIN_EDGE OUTSIDE BY HVD_P25_S_9/2
  HVD_PMOS_DRAIN INTERACT A > 1
}
HVD_P25.S.10 { @ Gate space in source direction for a multi-finger HVPMOS device. DRC checks: {{Space of {Gate INTERACT HVD_P}} OUTSIDE HVD_P} in one OD = 0.22 
  SOURCE_EDGE_pre = HVD_P_25V_GATE_W NOT INSIDE EDGE HVD_P
  SOURCE_EDGE = SOURCE_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre 
  EXT SOURCE_EDGE < HVD_P25_S_10 ABUT < 90 REGION 
  A = EXPAND EDGE SOURCE_EDGE OUTSIDE BY HVD_P25_S_10/2
  HVD_PMOS_SOURCE INTERACT A > 1
}
HVD_P25.S.11 { @ {CO INSIDE drain side OD} space to {HVD GATE OVERLAP OD_25} [inside HVD_P]	>=	^HVD_P25_S_11
  CO_HV_DRAIN = CO INSIDE HVD_PMOS_DRAIN
  EXT CO_HV_DRAIN GATE_HVDP25 < HVD_P25_S_11 ABUT < 90 SINGULAR REGION 
}
// HVD_P25.S.11.S is checked by HVD_P25.S.11
#ENDIF
#IFDEF HVMOS_18
HVD_P18.S.7__HVD_P18.S.8 { @ {CO INSIDE PO} space to {OD AND HVD_P} in PO end-cap direction. {CO INSIDE PO} can't overlap HVD_P >= 0.52 
                           @ /HVD_P18.S.8/
  CO_PO = CO INSIDE POLY
  CO_PO AND EXPAND_RIGION_P18
  CO_PO AND HVD_P
}
HVD_P18.S.9 { @ Gate space in drain direction for a multi-finger HVPMOS device. DRC checks: {{Space of {Gate INTERACT HVD_P}} INSIDE HVD_P} in one OD = 1.82 
  DRAIN_EDGE_pre = HVD_P_18V_GATE_W INSIDE EDGE HVD_P
  DRAIN_EDGE = DRAIN_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre
  EXT DRAIN_EDGE < HVD_P18_S_9 ABUT < 90 REGION 
  A = EXPAND EDGE DRAIN_EDGE OUTSIDE BY HVD_P18_S_9/2
  HVD_PMOS_DRAIN INTERACT A > 1
}
HVD_P18.S.10 { @ Gate space in source direction for a multi-finger HVPMOS device. DRC checks: {{Space of {Gate INTERACT HVD_P}} OUTSIDE HVD_P} in one OD = 0.22 
  SOURCE_EDGE_pre = HVD_P_18V_GATE_W NOT INSIDE EDGE HVD_P
  SOURCE_EDGE = SOURCE_EDGE_pre COIN OUTSIDE EDGE SD_EDGE_pre 
  EXT SOURCE_EDGE < HVD_P18_S_10 ABUT < 90 REGION 
  A = EXPAND EDGE SOURCE_EDGE OUTSIDE BY HVD_P18_S_10/2
  HVD_PMOS_SOURCE INTERACT A > 1
}
HVD_P18.S.11 { @ {CO INSIDE drain side OD} space to {HVD GATE OVERLAP OD_18} [INSIDE HVD_P] >= 0.88 
  CO_HV_DRAIN = CO INSIDE HVD_PMOS_DRAIN
  EXT CO_HV_DRAIN GATE_HVDP18 < HVD_P18_S_11 ABUT < 90 SINGULAR REGION 
}
#ENDIF
HVD_P25.S.12__HVD_P18.S.12 { @ {PO OR OD} space to {OD INTERACT HVD_P} in PO end-cap direction for high Rs concern >= 0.6 
  X = OD INTERACT HVD_P
  X_V = ANGLE (X INTERACT HVDS12_GATE_V) == 0
  X_H = ANGLE (X INTERACT HVDS12_GATE_H) == 90
  Y = OD OR POLY
  EXT X_V Y < HVD_P25_S_12 ABUT < 90 REGION
  EXT X_H Y < HVD_P25_S_12 ABUT < 90 REGION
}
HVD_P25.S.13__HVD_P18.S.13 { @ HVD_P Space to {SR_DOD OR DOD} (overlap is not allowed) >= 0.16 
  A = SRDOD OR DOD
  EXT HVD_P A < HVD_P25_S_13 ABUT < 90 SINGULAR REGION
  HVD_P AND A
}
HVD_P25.EX.1__HVD_P18.EX.1 { @ Extension on P+ ACTIVE (Drian side must be fully inside HVD_P) >= 0.24 
  ENC PACT HVD_P < HVD_P25_EX_1 ABUT < 90 SINGULAR REGION
  HVD_PMOS_DRAIN NOT HVD_P
}
HVD_P25.EN.1__HVD_P18.EN.1 { @ Enclosure by NW >= 0.6 
  ENC HVD_P NWEL < HVD_P25_EN_1 ABUT < 90 SINGULAR REGION
}
HVD_P25.EN.2__HVD_P18.EN.2 { @ Enclosure by DNW >= 0.6 
  ENC HVD_P DNW < HVD_P25_EN_2 ABUT < 90 SINGULAR REGION
}
HVD_P25.EN.3__HVD_P18.EN.3 { @ {Gate INTERACT HVD_P} enclosure by NW. {Gate INTERACT HVD_P} must be inside NW >= 2.0 
  ENC (GATE INTERACT HVD_P) NWi < HVD_P25_EN_3 ABUT < 90 SINGULAR REGION
  (GATE INTERACT HVD_P) NOT NWi
}
HVD_P25.EN.4__HVD_P18.EN.4 { @ {Gate INTERACT HVD_P} enclosure by OD2. {Gate INTERACT HVD_P} must be inside OD2 >= 2.0 
  ENC (GATE INTERACT HVD_P) OD2 < HVD_P25_EN_4 ABUT < 90 SINGULAR REGION
  (GATE INTERACT HVD_P) NOT OD2
}
#IFDEF HVMOS_25
HVD_P25.O.1 { @ Overlap of {I/O PMOS GATE} = ^HVD_P25_O_1
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_PMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_P25_O_1
  C = HVD_P AND HVD_PGATE
  C XOR B 
  HVD_PGATE INTERACT B > 1
}
// HVD_P25.O.1.S is checked by HVD_P25.O.1
HVD_P25.L.1 { @ Channel length of {gate interact with HVD_P} >= ^HVD_P25_L_1 
  A = HV_GATE_W COIN INSIDE EDGE HVD_PGATE 
  INT A < HVD_P25_L_1 ABUT < 90 REGION
}
// HVD_P25.L.1.S is checked by HVD_P25.L.1
#ENDIF
#IFDEF HVMOS_18
HVD_P18.O.1 { @ Overlap of {I/O PMOS GATE} = 0.28 
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_PMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_P18_O_1
  C = HVD_P AND HVD_PGATE
  C XOR B 
  HVD_PGATE INTERACT B > 1
}
HVD_P18.L.1 { @ Channel length of {GATE INTERACT HVD_P} >= 0.66 
  A = HV_GATE_W COIN INSIDE EDGE HVD_PGATE 
  INT A < HVD_P18_L_1 ABUT < 90 REGION
}
#ENDIF 
HVD_P25.A.1__HVD_P18.A.1 { @ Area >= 0.64 
  AREA HVD_P < HVD_P25_A_1
}
HVD_P25.A.2__HVD_P18.A.2 { @ Enclosed area >= 0.64 
  A = HOLES HVD_P INNER
  B = A NOT HVD_P
  AREA B < HVD_P25_A_2
}
HVD_P25.R.1__HVD_P18.R.1 { @ HVD_P must be inside NW   
  HVD_P NOT NWEL 
}
HVD_P25.R.2__HVD_P18.R.2 { @ HVD_P edge landing on OD without landing on GATE is not allowed   
  (HVD_P INSIDE EDGE OD) NOT INSIDE EDGE GATE
}
#IFDEF HVMOS_25
HVD_P25.R.3 { @ HVD_P must be fully inside OD_25   
  HVD_P NOT OD25 
}
#ENDIF
#IFDEF HVMOS_18
HVD_P18.R.3 { @ HVD_P must be fully inside OD_18   
  HVD_P NOT OD18
}
#ENDIF
HVD_P25.R.4__HVD_P18.R.4 { @ {(OD NOT PO) INSIDE the same HVD_P} must be the same potential   
  HVD_P INTERACT PSDc > 1 BY NET
}
HVD_P25.R.6__HVD_P18.R.6 { @ HVD_P must be inside DNW   
  HVD_P NOT DNW
}
HVD_P25.R.8__HVD_P18.R.8 { @ Only HV PMOS is allowed in {NW INTERACT HVD_P}. DRC flags: {(Gate INSIDE (NW INTERACT HVD_P)) NOT INTERACT HVD_P}   
  (GATE INSIDE (NWi INTERACT HVD_P)) NOT INTERACT HVD_P
}

HVD_P25.R.9__HVD_P18.R.9 { @ {{OD OR PO} INTERACT HVD_P} overlap of VAR, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, or POFUSE is not allowed   
  A = (ODi OR POi) INTERACT HVD_P
  A AND VARi
  A AND NTNi
  A AND TCDDMY
  A AND (OD AND NWDMY)
  A AND (NP INTERACT NWDMY)
  A AND SRM
  A AND ROM
  A AND BJTDMY
  A AND RH
  A AND POFUSE
}


//GUARD RING RULES
//=================

HVPMOS = PPOD INTERACT HVD_P
HVNMOS = NPOD INTERACT HVD_N

PSTP_HOLES = HOLES PSTP
NSTP_HOLES = HOLES NSTP
  
HVNMOS_LENGTH = HVNMOS TOUCH EDGE (HVNMOS INSIDE EDGE POLY)
HVNMOS_WIDTH = HVNMOS NOT COIN EDGE HVNMOS_LENGTH
HVPMOS_LENGTH = HVPMOS TOUCH EDGE (HVPMOS INSIDE EDGE POLY)
HVPMOS_WIDTH = HVPMOS NOT COIN EDGE HVPMOS_LENGTH


HVD_GR.R.1 { @ It is not allowed placing HV NMOS and HV PMOS inside the same guard-ring (Either P+ or N+ OD guard-ring)   
  HV_PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
  HV_PW_inside_guard_ring_pre2 = HV_PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
  HV_PW_inside_guard_ring = HV_PW_inside_guard_ring_pre1 NOT WITH EDGE HV_PW_inside_guard_ring_pre2
  HV_PPUi = (PSTPi INTERACT PSTP_HOLES) TOUCH HV_PW_inside_guard_ring
  HVNMOS_REGION_pre = (HOLES HV_PPUi) NOT HV_PPUi
  HVNMOS NOT INTERACT HVNMOS_REGION_pre
  HVNMOS_REGION = SIZE (HVNMOS INTERACT HVNMOS_REGION_pre) BY HVD_GR_R_5 INSIDE OF HVNMOS_REGION_pre STEP PP_W_1*0.7 TRUNCATE PP_W_1*0.7
  HVNMOS INTERACT (HVNMOS_REGION INTERACT NSTP)

  HV_NW_inside_guard_ring_pre1 = NWi NOT NSTPi
  HV_NW_inside_guard_ring_pre2 = HV_NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
  HV_NW_inside_guard_ring = HV_NW_inside_guard_ring_pre1 NOT WITH EDGE HV_NW_inside_guard_ring_pre2
  HV_NPUi = (NSTPi INTERACT NSTP_HOLES) TOUCH HV_NW_inside_guard_ring
  HVPMOS_REGION_pre = (HOLES HV_NPUi) NOT HV_NPUi
  HVPMOS NOT INTERACT HVPMOS_REGION_pre
  HVPMOS_REGION = SIZE (HVPMOS INTERACT HVPMOS_REGION_pre) BY HVD_GR_R_5 INSIDE OF HVPMOS_REGION_pre STEP NP_W_1*0.7 TRUNCATE NP_W_1*0.7
  HVPMOS INTERACT (HVPMOS_REGION INTERACT PSTP)
}

HVD_GR.R.5 { @ Any point inside HV NMOS source/drain {(N+ ACTIVE INTERACT (PO INTERACT HVD_N)) NOT PO} space to the nearest P+/PW guard-ring (PW STRAP) in the same PW. Any point inside HV PMOS source/drain {(P+ ACTIVE INTERACT (PO INTERACT HVD_P)) NOT PO} space to the nearest N+/NW guard-ring (NW STRAP) in the same NW <= 30 
  HV_PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
  HV_PW_inside_guard_ring_pre2 = HV_PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
  HV_PW_inside_guard_ring = HV_PW_inside_guard_ring_pre1 NOT WITH EDGE HV_PW_inside_guard_ring_pre2
  HV_PPUi = (PSTPi INTERACT PSTP_HOLES) TOUCH HV_PW_inside_guard_ring
  HV_PSTP_OS = SIZE HV_PPUi BY HVD_GR_R_5 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  HV_NACT_CHECK = (NACTi INTERACT (POi INTERACT HVD_N)) NOT POi

  HV_NW_inside_guard_ring_pre1 = NWi NOT NSTPi
  HV_NW_inside_guard_ring_pre2 = HV_NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
  HV_NW_inside_guard_ring = HV_NW_inside_guard_ring_pre1 NOT WITH EDGE HV_NW_inside_guard_ring_pre2
  HV_NPUi = (NSTPi INTERACT NSTP_HOLES) TOUCH HV_NW_inside_guard_ring
  HV_NSTP_OS = SIZE HV_NPUi BY HVD_GR_R_5 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  HV_PACT_CHECK = (PACTi INTERACT (POi INTERACT HVD_P)) NOT POi
  
  HV_NACT_CHECK NOT HV_PSTP_OS
  HV_PACT_CHECK NOT HV_NSTP_OS
}

HVD_GR.R.6 { @ {{HV N/PMOS OR HVMOS guard-ring} INTERACT RPO} is not allowed   
  HV_PSTP =  PSTP INTERACT (PSTP_HOLES ENCLOSE HVNMOS)
  HV_NSTP =  NSTP INTERACT (NSTP_HOLES ENCLOSE HVPMOS)
  HVPMOS_CK = HVPMOS OR (POLY INTERACT HVPMOS) 
  HVNMOS_CK = HVNMOS OR (POLY INTERACT HVNMOS)
  ((HVNMOS_CK OR HVPMOS_CK) OR (HV_PSTP OR HV_NSTP)) INTERACT RPO
}


//DEHVD_N CHECKS
//============


OD_DEHVD_N = OD INTERACT DEHVD_N
DPO_DEHVD_N = DPO INTERACT DEHVD_N
PO_DEHVD_N = POLY INTERACT DEHVD_N
GATE_DEHVD_N = GATE INTERACT DEHVD_N
GATE_W_DEHVD_N = (PO_DEHVD_N INSIDE EDGE DEHVD_N) COIN INSIDE EDGE GATE_DEHVD_N
DEHVD_NMOS_DRAIN = NSDi INTERACT DEHVD_N
DEHVD_NMOS_SOURCE = (NSDi INTERACT OD_DEHVD_N) NOT INTERACT DEHVD_N

DEHVD_N.L.1 { @ Channel length of {GATE INTERACT DEHVD_N} >= 0.54
  LENGTH (GATE_L TOUCH INSIDE EDGE GATE_DEHVD_N) < DEHVD_N_L_1
}
DEHVD_N.W.1 { @ Width >= 0.47
  INT DEHVD_N < DEHVD_N_W_1 ABUT < 90 SINGULAR REGION				
}
DEHVD_N.W.2 { @ Channel width of {GATE INTERACT DEHVD_N} >= 1.0
  LENGTH (GATE_W TOUCH INSIDE EDGE GATE_DEHVD_N) < DEHVD_N_W_2
}
DEHVD_N.W.3 { @ Width of {DPO INTERACT DEHVD_N} = 0.12
	NOT WITH WIDTH DPO_DEHVD_N == DEHVD_N_W_3	
}
DEHVD_N.S.1 { @ Space >= 0.47
	EXT DEHVD_N < DEHVD_N_S_1 ABUT < 90 SINGULAR REGION
}
DEHVD_N.S.2 { @ Space of two DEHVD_N with different potentials >= 1.37
  A = STAMP DEHVD_N BY NSDc
  EXT A < DEHVD_N_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
  B = DEHVD_N NOT INTERACT NSDc
  EXT B DEHVD_N < DEHVD_N_S_2 ABUT < 90 SINGULAR REGION SPACE
}
DEHVD_N.S.3 { @ Space to NW >= 1.6
  EXT DEHVD_N NWEL < DEHVD_N_S_3 ABUT < 90 SINGULAR REGION
}
DEHVD_N.S.4 { @ Space to PW STRAP (overlap is not allowed) >= 0.3
  EXT DEHVD_N PSTP < DEHVD_N_S_4 ABUT < 90 SINGULAR REGION
  DEHVD_N AND PSTP
}
DEHVD_N.S.5 { @ Space to N+ ACTIVE >= 0.6
  EXT DEHVD_N NACT < DEHVD_N_S_5 ABUT < 90 SINGULAR REGION
}
DEHVD_N.S.6 { @ Space to DNW (overlap is not allowed) >= 3.0
  EXT DEHVD_N DNW < DEHVD_N_S_6 ABUT < 90 SINGULAR REGION
  DEHVD_N AND DNW
}
DEHVD_N.S.7 { @ {GATE edge INSIDE DEHVD_N} space to {1st DPO INTERACT DEHVD_N} in drain direction = 0.12
	EXT [GATE_W_DEHVD_N] DPO_DEHVD_N < DEHVD_N_S_7 ABUT < 90 OPPOSITE
	EXT (GATE_W_DEHVD_N) DPO_DEHVD_N == DEHVD_N_S_7 ABUT < 90 OPPOSITE
}
DEHVD_N.S.8 { @ {GATE edge INSIDE DEHVD_N} space to {2nd DPO INTERACT DEHVD_N} in drain direction = 0.4
	EXT (GATE_W_DEHVD_N) DPO_DEHVD_N == DEHVD_N_S_8 ABUT < 90 OPPOSITE
}
DEHVD_N.S.9 { @ {CO INSIDE {OD AND DEHVD_N}} space to {PO INTERACT DEHVD_N} = 0.6
	A = COOD INSIDE DEHVD_N
	B = EXT GATE_W_DEHVD_N [A]	== DEHVD_N_S_9 ABUT < 90 OPPOSITE
	C = INT B <= CO_W_1 OPPOSITE REGION
	A XOR C
}
DEHVD_N.S.10 { @  {CO INSIDE {PO INTERACT DEHVD_N}} space to {OD INTERACT DEHVD_N} in PO end-cap direction >= 0.44
  CO_PO = CO INSIDE PO_DEHVD_N
  EXT CO_PO OD_DEHVD_N < DEHVD_N_S_10 ABUT < 90 SINGULAR REGION
}
DEHVD_N.S.12 { @ Gate space in drain direction for a multi-finger DENMOS device. DRC checks: {{Space of {Gate INTERACT DEHVD_N}} INSIDE DEHVD_N} on one OD = 1.26 
	A = DEHVD_NMOS_DRAIN INTERACT GATE_DEHVD_N == 2
	DRAIN_EDGE = GATE_DEHVD_N COIN OUTSIDE EDGE A
	EXT [DRAIN_EDGE] < DEHVD_N_S_12 ABUT < 90 OPPOSITE
	EXT (DRAIN_EDGE) == DEHVD_N_S_12 ABUT < 90 OPPOSITE
}
DEHVD_N.S.13 { @ Gate space in soruce direction for a multi-finger HVNMOS device >= 0.22  
	A = DEHVD_NMOS_SOURCE INTERACT GATE_DEHVD_N == 2
	SOURCE_EDGE = GATE_DEHVD_N COIN OUTSIDE EDGE A
	EXT [SOURCE_EDGE] < DEHVD_N_S_13 ABUT < 90 OPPOSITE
}
DEHVD_N.S.14 { @ {PO OR OD} space to {OD INTERACT DEHVD_N} in PO end-cap direction for high Rs concern >= 0.6
	V_GATE_DEHVD_N = GATE_DEHVD_N INTERACT (EXPAND EDGE (ANGLE GATE_W_DEHVD_N == 90) INSIDE BY GRID)
	H_GATE_DEHVD_N = GATE_DEHVD_N INTERACT (EXPAND EDGE (ANGLE GATE_W_DEHVD_N == 0) INSIDE BY GRID)
	V_OD_EDGE = ANGLE (OD_DEHVD_N INTERACT V_GATE_DEHVD_N) == 0
	H_OD_EDGE = ANGLE (OD_DEHVD_N INTERACT H_GATE_DEHVD_N) == 90
	A = POLY OR OD
	EXT A V_OD_EDGE < DEHVD_N_S_14 ABUT < 90 REGION
	EXT A H_OD_EDGE < DEHVD_N_S_14 ABUT < 90 REGION
}
DEHVD_N.S.15 { @  {Gate INTERACT DEHVD_N} space to {NW OR NT_N}. {GATE INTERACT DEHVD_N} can't overlap {NW OR NT_N} >= 2.0
  EXT GATE_DEHVD_N (NWi OR NTNi) < DEHVD_N_S_15 ABUT < 90 SINGULAR REGION
  GATE_DEHVD_N AND (NWi OR NTNi)
}
DEHVD_N.EN.1 { @ {GATE INTERACT DEHVD_N} enclosure by OD2. {GATE INTERACT DEHVD_N} must be inside OD2 >= 2.0
  ENC GATE_DEHVD_N OD2 < DEHVD_N_EN_1 ABUT < 90 SINGULAR REGION
  GATE_DEHVD_N NOT OD2
}
DEHVD_N.EX.1 { @ Extension on N+ ACTIVE (Drian side must be fully inside HVD_N) >= 0.24
  ENC NACT DEHVD_N < DEHVD_N_EX_1 ABUT < 90 SINGULAR REGION
  DEHVD_NMOS_DRAIN NOT DEHVD_N
}
DEHVD_N.EX.2 { @ {DPO INTERACT DEHVD_N} extension on OD = 0.525
	DPO_OD_DEHVD_N = DPO_DEHVD_N AND OD
	DPO_W_DEHVD_N = DPO_DEHVD_N COIN INSIDE EDGE DPO_OD_DEHVD_N
	DPO_L_DEHVD_N = DPO_DEHVD_N NOT TOUCH EDGE DPO_W_DEHVD_N
	ENC OD [DPO_L_DEHVD_N] < DEHVD_N_EX_2 ABUT < 90 OPPOSITE
	ENC OD (DPO_L_DEHVD_N) == DEHVD_N_EX_2 ABUT < 90 OPPOSITE
}
DEHVD_N.EX.3 { @ OD extension on {PO INTERACT DEHVD_N} >= 0.4
	ENC PO_DEHVD_N OD_DEHVD_N < DEHVD_N_EX_3 ABUT < 90 SINGULAR REGION
}
DEHVD_N.O.1 { @ Overlap of {I/O NMOS GATE} = 0.05
  A = EXPAND EDGE GATE_W_DEHVD_N INSIDE BY DEHVD_N_O_1
  B = DEHVD_N AND GATE_DEHVD_N
  B XOR A 
  GATE_DEHVD_N INTERACT A > 1
}
DEHVD_N.A.1 { @ Area >= 0.64
  AREA DEHVD_N < DEHVD_N_A_1
}
DEHVD_N.A.2 { @ Enclosed area >= 0.64
  A = HOLES DEHVD_N INNER
  B = A NOT DEHVD_N
  AREA B < DEHVD_N_A_2
}
DEHVD_N.R.1 { @ Overlap of NW OR PP is not allowed.
  DEHVD_N AND NWEL 
  DEHVD_N AND PP
}
DEHVD_N.R.2 { @ DEHVD_N edge landing on OD without landing on GATE is not allowed.
  (DEHVD_N INSIDE EDGE OD_DEHVD_N) NOT INSIDE EDGE GATE_DEHVD_N
}
DEHVD_N.R.3 { @ DEHVD_N must be fully inside OD_25.
  DEHVD_N NOT OD25 
}
DEHVD_N.R.4 { @ {(OD NOT PO) inside one DEHVD_N} must be same potential
  DEHVD_N INTERACT NSDc > 1 BY NET 
}
DEHVD_N.R.5 { @ For model accuracy, DENMOS with two fingers PO gate and common HV drain as a unit is must. The two fingers in a DE NMOS unit must be the same potential
	A = ILP1i AND GATE_DEHVD_N
	DEHVD_N INTERACT A > 1 BY NET
	DEHVD_NMOS_DRAIN INTERACT GATE_DEHVD_N == 1
	B = NSDc INTERACT DEHVD_NMOS_SOURCE
	C = GATE_DEHVD_N OR DEHVD_NMOS_DRAIN
	C INTERACT B > 1 BY NET
}
DEHVD_N.R.6 { @ The finger number, Nf, should be even numbers. Nf means the finger number of the GATE on one OD.
	DFM PROPERTY OD_DEHVD_N GATE_DEHVD_N OVERLAP MULTI
	[-= FMOD(COUNT(GATE_DEHVD_N),2)] == 1
}
DEHVD_N.R.7 { @ {(DEHVD_N INTERACT OD) AND PO} must be a rectangle. A concave {(DEHVD_N INTERACT OD) AND PO} is not allowed.
	A = (DEHVD_N INTERACT OD) AND POLY
	NOT RECTANGLE A ORTHOGONAL ONLY
}
DEHVD_N.R.8 { @ DEHVD_N must be interacted with DPO.
	DEHVD_N NOT INTERACT DPO
}
DEHVD_N.R.9 {	@ {(OD INTERACT DEHVD_N)} must be a rectangle.
	NOT RECTANGLE OD_DEHVD_N
}
DEHVD_N.R.10 { @ {{OD OR PO} INTERACT DEHVD_N} overlap of NW, DNW, VAR, NT_N, TCDDMY, {OD INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, OD25_33, OD25_18, OD18_15, or OD_18 is not allowed
	A = OD_DEHVD_N OR PO_DEHVD_N
	A AND NWEL
	A AND DNW
 	A AND VAR
  A AND NTN
  A AND TCDDMY
  A AND (OD INTERACT NWDMY)
  A AND SRM
  A AND ROM
  A AND BJTDMY
  A AND RH
  A AND POFUSE
	A AND OD2533
	A AND OD2518
	A AND OD1815
	A AND OD18
}


//DENMOS GUARD RING RULES
//=================
DENMOS = NPOD INTERACT DEHVD_N

DENMOS_LENGTH = DENMOS TOUCH EDGE (DENMOS INSIDE EDGE POLY)
DENMOS_WIDTH = DENMOS NOT COIN EDGE DENMOS_LENGTH

// DEHVD_NGR.R.1 is checked by DEHVD_NGR.R.1__DEHVD_NGR.R.2
// DEHVD_NGR.R.2 is checked by DEHVD_NGR.R.1__DEHVD_NGR.R.2
DEHVD_NGR.R.1__DEHVD_NGR.R.2 { @ It is not allowed to place DENMOS inside the N+ OD guard ring. Every DENMOS must be surrounded by the P+ OD guard ring as PW strap.
	DENMOS NOT INSIDE PTAP_guard_ring_hole
}
// DEHVD_NGR.R.7 is checked by DEHVD_NGR.R.7__DEHVD_NGR.R.8
// DEHVD_NGR.R.8 is checked by DEHVD_NGR.R.7__DEHVD_NGR.R.8
DEHVD_NGR.R.7__DEHVD_NGR.R.8 { @ For one-row and two-row multi-OD DENMOS in the same guard ring, the outer edge of OD at the channel width direction of each DENMOS space to the P+/PW guard ring <= 2; The OD space in channel width direction for two-row multi-OD in the same guard ring <= 4
	A = EXT [DENMOS_LENGTH] <= DEHVD_GR_R_8
	REMAIN_LENGTH = DENMOS_LENGTH NOT COIN EDGE A
	B = EXT [REMAIN_LENGTH] PSTP <= DEHVD_GR_R_7
	(REMAIN_LENGTH NOT COIN EDGE B) COIN EDGE DENMOS
}
// DEHVD_NGR.R.10 is checked by DEHVD_NGR.R.10__DEHVD_NGR.R.11
// DEHVD_NGR.R.11 is checked by DEHVD_NGR.R.10__DEHVD_NGR.R.11
DEHVD_NGR.R.10__DEHVD_NGR.R.11{ @ For one-row and two-row multi-OD DENMOS in the same guard ring, the outer edge of OD at the channel length direction of each DENMOS space to the P+/PW guard ring <= 2; The OD space in channel length direction for two-row multi-OD in the same guard ring <= 2
	A = EXT [DENMOS_WIDTH] <= DEHVD_GR_R_11
	REMAIN_WIDTH = DENMOS_WIDTH NOT COIN EDGE A
	B = EXT [REMAIN_WIDTH] PSTP <= DEHVD_GR_R_10
	(REMAIN_WIDTH NOT COIN EDGE B) COIN EDGE DENMOS
}
DEHVD_NGR.R.15 { @ It is not allowed to place DENMOS and HVPMOS/HVNMOS inside the same guard-ring
  HV_PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
  HV_PW_inside_guard_ring_pre2 = HV_PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
  HV_PW_inside_guard_ring = HV_PW_inside_guard_ring_pre1 NOT WITH EDGE HV_PW_inside_guard_ring_pre2
  HV_PPUi = (PSTPi INTERACT PSTP_HOLES) TOUCH HV_PW_inside_guard_ring
  HVNMOS_REGION_pre = (HOLES HV_PPUi) NOT HV_PPUi
  DEHVD_N NOT INTERACT HVNMOS_REGION_pre
  HVNMOS_REGION = SIZE (HVNMOS INTERACT HVNMOS_REGION_pre) BY HVD_GR_R_5 INSIDE OF HVNMOS_REGION_pre STEP PP_W_1*0.7 TRUNCATE PP_W_1*0.7
  DEHVD_N INTERACT HVNMOS_REGION
}


#IFDEF eDRAM
// CO2 CHECKS
//------------
CO2.W.1 { @ CO2 (100;0) width (maximum=minimum) = 0.06 
  NOT RECTANGLE CO2 == CO2_W_1 BY == CO2_W_1 ORTHOGONAL ONLY
}

CO2.R.1 { @ CO2 (100;0) layout must exist in the SRAM bit cell for the eDRAM process   
  SRM NOT INTERACT CO2
}

CO2.R.2 { @ BTC must overlap CO2, and CO2 must overlap BTC. CO2 (100;0) must be inside {M1 AND SRM} and BTC ((30;0 NOT 30;11) AND 50;0). The following conditions can be waived. a. Butted contact (BTC) without interacting with M1. b. The area of {CO2 NOT M1} is smaller than or equal to 0.015 x 0.005 um2 in SRM_LV (80;15). In the other SRAMs, CO2 must be fully inside M1 (the area of {CO2 NOT M1} should be equal to 0 um2)   
  Check_BTC = BTC INTERACT M1i
  Check_BTC NOT INTERACT CO2
  Check_CO2 = CO2 INTERACT (BTC INTERACT M1i)
  Check_CO2_SRM_LV = Check_CO2 AND LVLOP
  Check_CO2_OTHER = Check_CO2 NOT LVLOP
  AREA (Check_CO2_SRM_LV NOT M1i) > CO2_R_2
  Check_CO2_OTHER NOT M1i
  CO2 NOT BTC
}
#ENDIF


// ROM CHECKS
//===========
ROM_GATE_W = GATE_W NOT OUTSIDE EDGE ROM

ROM.W.1 { @ Channel Width >= ^ROM_W_1A um <= ^ROM_W_1B um
  LENGTH ROM_GATE_W < ROM_W_1A
  LENGTH ROM_GATE_W > ROM_W_1B
}
ROM.W.2 { @ Channel length == ^ROM_W_2A um, ^ROM_W_2B um
  INT ROM_GATE_W < ROM_W_2A ABUT < 90 REGION
  ROM_GATE = GATE WITH EDGE ROM_GATE_W
  ROM_GATE WITH WIDTH > ROM_W_2B
}

ROM.R.4 { @ Only SVT NMOS is allowed in the ROM region for SPICE model support.
          @ DRC flags that ROM overlaps {NW AND OD} / {HVD_N AND OD} / {VTH_N AND OD} / {VTL_N AND OD}
  ROM AND (NWEL AND OD)
  ROM AND (HVD_N AND OD)
  ROM AND (VTHN AND OD)
  ROM AND (VTLN AND OD)
}



// Analog Checks
//==============

BJT.R.1 { @ RPO needs to cover 0.3 um on the Emitter OD edge for both OD and STI sides, i.e. RPO= ((Emitter OD SIZING 0.3 um) NOT (Emitter OD SIZING -0.3 um)) = 0.6 
  X = ( SIZE EMOD BY BJT_R_1_G1 ) NOT ( SIZE EMOD BY -BJT_R_1_G1 )
  Y = RPO INTERACT EMOD
  X XOR Y
}
BJT.R.8 { @ BJTDMY enclosure of Emitter OD >= 0.13 
  A = COPY BJTDMY
  ENC EMOD A < BJT_R_8 ABUT<90 SINGULAR REGION
  EMOD NOT A
}


NWRODR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRODR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRODR1m_NWCell = NWRODR1m_NWCellIn AND NWRODR1m_NWCellOut
NWRODR1m_NWMarker = NWi AND RRuleAnalog
NWRODR1m_NW = ((( NWRODR1m_NWCell OR NWRODR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRODR1m_NWRES = ( NWRODR1m_NW AND NWRES ) AND NWDMY

NWRODR1m_NWRES_L = NWRODR1m_NWRES NOT INSIDE EDGE NWEL
NWRODR1m_NWRES_W = NWRODR1m_NWRES INSIDE EDGE NWEL
NWRODR1m_NWRES_L_ex = EXPAND EDGE NWRODR1m_NWRES_L BY 0.005
NWRODR1m_NWRES_W_ex = EXPAND EDGE NWRODR1m_NWRES_W BY 0.005
CONNECT NWRODR1m_NWRES_L_ex NWRODR1m_NWRES_W_ex

NWROD.R.1m { @ Width >= ^NWROD_R_1_W_M um, length >= ^NWROD_R_1_L_M, and square number(L/W) >= ^NWROD_R_1_S_M um for NW resistor with OD
  INT NWRODR1m_NWRES < NWROD_R_1_W_M ABUT < 90 SINGULAR REGION
  RES_L = NWRODR1m_NWRES COIN INSIDE EDGE NWRODR1m_NW
  X = PATH LENGTH RES_L < NWROD_R_1_L_M
  CHECK_RES = NWRODR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1m_NWRES STEP NW_S_1*0.7
  C = CHECK_RES NOT B
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
  NET AREA RATIO NWRODR1m_NWRES_L_ex NWRODR1m_NWRES_W_ex < NWROD_R_1_S_M
}


NWRSTIR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRSTIR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRSTIR1m_NWCell = NWRSTIR1m_NWCellIn AND NWRSTIR1m_NWCellOut
NWRSTIR1m_NWMarker = NWi AND RRuleAnalog
NWRSTIR1m_NW = ((( NWRSTIR1m_NWCell OR NWRSTIR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRSTIR1m_NWRES = ( NWRSTIR1m_NW AND NWRES_STI ) AND NWDMY

NWRSTIR1m_NWRES_L = NWRSTIR1m_NWRES NOT INSIDE EDGE NWEL
NWRSTIR1m_NWRES_W = NWRSTIR1m_NWRES INSIDE EDGE NWEL
NWRSTIR1m_NWRES_L_ex = EXPAND EDGE NWRSTIR1m_NWRES_L BY 0.005
NWRSTIR1m_NWRES_W_ex = EXPAND EDGE NWRSTIR1m_NWRES_W BY 0.005
CONNECT NWRSTIR1m_NWRES_L_ex NWRSTIR1m_NWRES_W_ex

NWRSTI.R.1m { @ Width >= ^NWRSTI_R_1_W_M um, length >= ^NWRSTI_R_1_L_M um, and square number(L/W) >= ^NWRSTI_R_1_S_M um for NW resistor under STI
  INT NWRSTIR1m_NWRES < NWRSTI_R_1_W_M ABUT < 90 SINGULAR REGION
  RES_L = NWRSTIR1m_NWRES COIN INSIDE EDGE NWRSTIR1m_NW
  X = PATH LENGTH RES_L < NWRSTI_R_1_L_M
  CHECK_RES = NWRSTIR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1m_NWRES STEP NW_S_1*0.7
  C = CHECK_RES NOT B
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
  NET AREA RATIO NWRSTIR1m_NWRES_L_ex NWRSTIR1m_NWRES_W_ex < NWRSTI_R_1_S_M
}

#ENDIF // FRONT_END

#IFDEF BACK_END

// IND CHECKS
//==========

IND.W.1 { @ M1, DM1, DM1_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M1x NOT OUTSIDE IND_REGION
  (INT A < IND_W_1 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.W.2 is checked by IND.W.2:M2
IND.W.2:M2 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M2x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.W.2 is checked by IND.W.2:M3
IND.W.2:M3 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M3x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.W.2 is checked by IND.W.2:M4
IND.W.2:M4 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M4x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.W.2 is checked by IND.W.2:M5
IND.W.2:M5 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M5x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.W.4 is checked by IND.W.4:M6
IND.W.4:M6 { @ Mz, DMz width in (INDDMY SIZING 16 um) >= 0.4 
  A = M6x NOT OUTSIDE IND_REGION
  (INT A < IND_W_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}

// IND.W.7 is checked by IND.W.7:M1
IND.W.7:M1 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M1x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
// IND.W.7 is checked by IND.W.7:M2
IND.W.7:M2 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M2x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
// IND.W.7 is checked by IND.W.7:M3
IND.W.7:M3 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M3x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
// IND.W.7 is checked by IND.W.7:M4
IND.W.7:M4 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M4x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
// IND.W.7 is checked by IND.W.7:M5
IND.W.7:M5 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M5x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
// IND.W.9 is checked by IND.W.9:M6
IND.W.9:M6 { @ Mz, DMz/Mr, DMr/Mu, DMu maximum width inside (INDDMY SIZING 22 um) (for inductor application only) <= 30.0 
  A = M6x NOT OUTSIDE IND_EXD
  (A WITH WIDTH > IND_W_9) NOT OUTSIDE IND_EXD
}

IND.W.10 { @ Maximum dimension (either width or length) of an INDDMY region <= 600.0 
  ENCLOSE RECTANGLE INDDMY_ALL GRID IND_W_10+GRID ORTHOGONAL ONLY
}

IND.S.1 { @ M1, DM1, DM1_O space in (INDDMY SIZING 16 um) >= 0.28 
  A = M1x AND IND_EXD
  (EXT A < IND_S_1 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.S.2 is checked by IND.S.2:M2
IND.S.2:M2 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M2x AND IND_EXD
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.S.2 is checked by IND.S.2:M3
IND.S.2:M3 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M3x AND IND_EXD
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.S.2 is checked by IND.S.2:M4
IND.S.2:M4 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M4x AND IND_EXD
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.S.2 is checked by IND.S.2:M5
IND.S.2:M5 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M5x AND IND_EXD
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
// IND.S.4 is checked by IND.S.4:M6
IND.S.4:M6 { @ Mz, DMz space in (INDDMY SIZING 16 um) >= 0.4 
  A =  M6x AND IND_EXD
  (EXT A < IND_S_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}

// IND.S.7 is checked by IND.S.7:M1
IND.S.7:M1 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M1x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M1x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.7 is checked by IND.S.7:M2
IND.S.7:M2 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M2x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M2x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.7 is checked by IND.S.7:M3
IND.S.7:M3 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M3x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M3x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.7 is checked by IND.S.7:M4
IND.S.7:M4 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M4x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M4x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.7 is checked by IND.S.7:M5
IND.S.7:M5 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M5x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M5x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.7 is checked by IND.S.7:M6
IND.S.7:M6 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M6x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M6x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
// IND.S.9 is checked by IND.S.9:M6
IND.S.9:M6 { @ My, DMy/Mz, DMz/Mr, DMr space in (INDDMY SIZING 16 um) [at least one metal line width > 4.5 um (W3) and the parallel metal run length > 4.5 um (L3)] >= 1.5 
  A = (M6x WITH WIDTH > IND_S_9_W) AND IND_EXD
  X = EXT A M6x < IND_S_9 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_9_L+0.001) NOT OUTSIDE IND_REGION
}
#IFNDEF IND_INTER_MET_VIA
IND.R.1 { @ In the region of (INDDMY SIZING 16 um), inter-via Vx, Vy and top via Vy (2XTM) are all not allowed. (Except TLDMY region and Vx in {LOWMEDN NOT (LOWMEDN SIZING -4 um)})   
  ((VIA1 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION
  ((VIA2 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION
  ((VIA3 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION
  ((VIA4 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION
}
#ENDIF

// IND.R.2 is checked by IND.R.2:VIA5
IND.R.2:VIA5 { @ At leastfour VIAz with space <= 1.7 um are required to connect [two Mz layers], [Mz to inter-My] or [Mz to Mx] in (INDDMY SIZING 16 um) <= 1.7 
  M6OvpM5 = (M6 AND M5) AND IND_REGION
  Check_VIA5 = VIA5_EXD NOT OUTSIDE M6OvpM5
  VIA5Merge = SIZE Check_VIA5 BY (IND_R_2/2) INSIDE OF M6OvpM5 STEP M5_S_1*0.7
  VIA5Merge2 = VIA5Merge ENCLOSE Check_VIA5 >= 4
  Good_VIA5 = Check_VIA5 AND VIA5Merge2
  GM6OvpM5 = M6OvpM5 INTERACT Good_VIA5
  Check_VIA5 OUTSIDE GM6OvpM5
}



#IFNDEF IND_INTER_MET_VIA
INDR5_M1_DN = DENSITY M1x >= 0.1 WINDOW 125 STEP 62.5 BACKUP INSIDE OF LAYER INDDMY_ALL
INDR5_M2_DN = DENSITY M2x >= 0.1 WINDOW 125 STEP 62.5 BACKUP INSIDE OF LAYER INDDMY_ALL
INDR5_M3_DN = DENSITY M3x >= 0.1 WINDOW 125 STEP 62.5 BACKUP INSIDE OF LAYER INDDMY_ALL
INDR5_M4_DN = DENSITY M4x >= 0.1 WINDOW 125 STEP 62.5 BACKUP INSIDE OF LAYER INDDMY_ALL
INDR5_M5_DN = DENSITY M5x >= 0.1 WINDOW 125 STEP 62.5 BACKUP INSIDE OF LAYER INDDMY_ALL
 INDR5_DN_BAD1 = INDDMY_ALL NOT INSIDE ( ( ( ( INDR5_M1_DN AND INDR5_M2_DN) AND INDR5_M3_DN) AND INDR5_M4_DN) AND INDR5_M5_DN) 
 INDR5_DN_BAD2 = INDDMY_ALL NOT INSIDE ( ( ( ( INDR5_M1_DN AND INDR5_M2_DN) AND INDR5_M3_DN) AND INDR5_M4_DN) AND INDR5_M5_DN) 
IND.R.5 { @ In the INDDMY identified region "a", except the inter-metal Mx or My layer (one layer only) directly below [top My, Mz, Mr or Mu], any other inter-metal layer (Mx/My) is not allowed. (e.g. for a 1P6M process with 0.9 um of M6 (Mz), then Mx of M5 is allowed, but other lower Mx metal layers are not allowed for the INDDMY identified inductor.) (Except TLDMY region and Mx in {(LOWMEDN NOT (LOWMEDN SIZING -5 um)) INTERACT VIAx bar})   
  ((M2 AND INDR5_DN_BAD1) NOT TLDMY) NOT ((M2 AND P_RING_REGION2) INTERACT P_RING_VIA1)

  ((M3 AND INDR5_DN_BAD1) NOT TLDMY) NOT ((M3 AND P_RING_REGION2) INTERACT P_RING_VIA2)

  ((M4 AND INDR5_DN_BAD1) NOT TLDMY) NOT ((M4 AND P_RING_REGION2) INTERACT P_RING_VIA3)

}
#ENDIF
// IND.R.6U can not be checked by DRC
// IND.R.7U can not be checked by DRC
// IND.R.8 is checked by RV.R.1
// IND.R.9U can not be checked by DRC

#IFDEF FULL_CHIP
IND.DN.1 { @ Maximum density of {(INDDMY OR INDDMY_MD) OR TLDMY} on a whole chip <= 5% 
  X = INDDMY_ALL OR TLDMY
  DENSITY X CHIP > IND_DN_1 INSIDE OF LAYER CHIPx PRINT IND.DN.1.density
    [ AREA(X)/AREA(CHIP) ]
}
#ENDIF

// IND.DN.2 is checked by IND.DN.2:M1
IND.DN.2:M1 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um <= 85% 
  DENSITY M1x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2:M1.density
}
// IND.DN.2 is checked by IND.DN.2:M2
IND.DN.2:M2 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um <= 85% 
  DENSITY M2x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2:M2.density
}
// IND.DN.2 is checked by IND.DN.2:M3
IND.DN.2:M3 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um <= 85% 
  DENSITY M3x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2:M3.density
}
// IND.DN.2 is checked by IND.DN.2:M4
IND.DN.2:M4 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um <= 85% 
  DENSITY M4x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2:M4.density
}
// IND.DN.2 is checked by IND.DN.2:M5
IND.DN.2:M5 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um <= 85% 
  DENSITY M5x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2:M5.density
}

CHIP_IND = CHIP INTERACT INDDMY_ALL
#IFDEF FULL_CHIP
// IND.DN.3 is checked by IND.DN.3:M1
IND.DN.3:M1 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M1x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M1.density 
	[ AREA(M1x)/AREA(CHIP) ]
}

// IND.DN.3 is checked by IND.DN.3:M2
IND.DN.3:M2 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M2x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M2.density 
	[ AREA(M2x)/AREA(CHIP) ]
}

// IND.DN.3 is checked by IND.DN.3:M3
IND.DN.3:M3 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M3x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M3.density 
	[ AREA(M3x)/AREA(CHIP) ]
}

// IND.DN.3 is checked by IND.DN.3:M4
IND.DN.3:M4 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M4x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M4.density 
	[ AREA(M4x)/AREA(CHIP) ]
}

// IND.DN.3 is checked by IND.DN.3:M5
IND.DN.3:M5 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M5x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M5.density 
	[ AREA(M5x)/AREA(CHIP) ]
}

// IND.DN.3 is checked by IND.DN.3:M6
IND.DN.3:M6 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) >= 20% 
  DENSITY M6x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3:M6.density 
	[ AREA(M6x)/AREA(CHIP) ]
}

#ENDIF
// IND.DN.5U can not be checked by DRC, since it has different value from Logic rule (40%)
// IND.R.10 is checked by related rules
// IND.R.14 is checked by related rules

#IFDEF FULL_CHIP
IND.DN.7 { @ Maximum density of INDDMY in window 1600 um x 1600 um stepping 800 um <= 14 %
  DENSITY INDDMY_ALL CHIP > IND_DN_7 WINDOW IND_DN_7_W STEP IND_DN_7_S BACKUP INSIDE OF LAYER CHIPx PRINT IND.DN.7.density 
  [AREA(INDDMY_ALL)/AREA(CHIP)]
}
#ENDIF


#IFDEF IND_INTER_MET_VIA

INT_VIA1pre = (SIZE (VIA1 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA1 = COPY INT_VIA1pre

INT_VIA2pre = (SIZE (VIA2 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA2 = INT_VIA2pre OR INT_VIA1

INT_VIA3pre = (SIZE (VIA3 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA3 = INT_VIA3pre OR INT_VIA2

INT_VIA4pre = (SIZE (VIA4 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA4 = INT_VIA4pre OR INT_VIA3



INT_DEN_CHK = COPY INT_VIA4
INT_DEN_CHKx = COPY INT_DEN_CHK

// IND.DN.6 is checked by IND.DN.6:M1
IND.DN.6:M1 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%
  DENSITY M1x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6:M1.density
  [ AREA(M1x)/AREA(INT_DEN_CHK) ]
}
// IND.DN.6 is checked by IND.DN.6:M2
IND.DN.6:M2 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%
  DENSITY M2x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6:M2.density
  [ AREA(M2x)/AREA(INT_DEN_CHK) ]
}
// IND.DN.6 is checked by IND.DN.6:M3
IND.DN.6:M3 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%
  DENSITY M3x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6:M3.density
  [ AREA(M3x)/AREA(INT_DEN_CHK) ]
}
// IND.DN.6 is checked by IND.DN.6:M4
IND.DN.6:M4 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%
  DENSITY M4x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6:M4.density
  [ AREA(M4x)/AREA(INT_DEN_CHK) ]
}

// IND.R.11 is checked by IND.R.11:VIA1
IND.R.11:VIA1 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14
  M2OvpM1 = (M2 AND M1) AND IND_REGION
  Check_VIA1 = VIA1_EXD NOT OUTSIDE M2OvpM1
  VIA1Merge = SIZE Check_VIA1 BY (IND_R_11/2) INSIDE OF M2OvpM1 STEP M1_S_1*0.7
  VIA1Merge2 = VIA1Merge ENCLOSE Check_VIA1 >= IND_R_11C
  Good_VIA1 = Check_VIA1 AND VIA1Merge2
  GM2OvpM1 = M2OvpM1 INTERACT Good_VIA1
  Check_VIA1 OUTSIDE GM2OvpM1
}
// IND.R.11 is checked by IND.R.11:VIA2
IND.R.11:VIA2 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14
  M3OvpM2 = (M3 AND M2) AND IND_REGION
  Check_VIA2 = VIA2_EXD NOT OUTSIDE M3OvpM2
  VIA2Merge = SIZE Check_VIA2 BY (IND_R_11/2) INSIDE OF M3OvpM2 STEP M2_S_1*0.7
  VIA2Merge2 = VIA2Merge ENCLOSE Check_VIA2 >= IND_R_11C
  Good_VIA2 = Check_VIA2 AND VIA2Merge2
  GM3OvpM2 = M3OvpM2 INTERACT Good_VIA2
  Check_VIA2 OUTSIDE GM3OvpM2
}
// IND.R.11 is checked by IND.R.11:VIA3
IND.R.11:VIA3 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14
  M4OvpM3 = (M4 AND M3) AND IND_REGION
  Check_VIA3 = VIA3_EXD NOT OUTSIDE M4OvpM3
  VIA3Merge = SIZE Check_VIA3 BY (IND_R_11/2) INSIDE OF M4OvpM3 STEP M3_S_1*0.7
  VIA3Merge2 = VIA3Merge ENCLOSE Check_VIA3 >= IND_R_11C
  Good_VIA3 = Check_VIA3 AND VIA3Merge2
  GM4OvpM3 = M4OvpM3 INTERACT Good_VIA3
  Check_VIA3 OUTSIDE GM4OvpM3
}
// IND.R.11 is checked by IND.R.11:VIA4
IND.R.11:VIA4 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14
  M5OvpM4 = (M5 AND M4) AND IND_REGION
  Check_VIA4 = VIA4_EXD NOT OUTSIDE M5OvpM4
  VIA4Merge = SIZE Check_VIA4 BY (IND_R_11/2) INSIDE OF M5OvpM4 STEP M4_S_1*0.7
  VIA4Merge2 = VIA4Merge ENCLOSE Check_VIA4 >= IND_R_11C
  Good_VIA4 = Check_VIA4 AND VIA4Merge2
  GM5OvpM4 = M5OvpM4 INTERACT Good_VIA4
  Check_VIA4 OUTSIDE GM5OvpM4
}

#ENDIF

IND_MD.R.18 { @ INDDMY overlap with (INDDMY_HD or INDDMY_MD) is not allowed.
	INDDMY AND INDDMY_HD
	INDDMY AND INDDMY_MD
}
IND_MD.R.19 { @ INDDMY_HD overlap with INDDMY_MD is not allowed.
	INDDMY_HD AND INDDMY_MD
}

//IND_MD.W.1 is checked by IND.W.1
//IND_MD.W.2 is checked by 'IND.W.2'
//IND_MD.W.3 is checked by 'IND.W.3'
//IND_MD.W.4 is checked by 'IND.W.4'
//IND_MD.W.5 is checked by 'IND.W.5'
//IND_MD.W.6 is checked by 'IND.W.6'
//IND_MD.W.7 is checked by 'IND.W.7'
//IND_MD.W.8 is checked by 'IND.W.8'
//IND_MD.W.9 is checked by 'IND.W.9'
//IND_MD.W.10 is checked by IND.W.10
//IND_MD.S.1 is checked by IND.S.1
//IND_MD.S.2 is checked by 'IND.S.2'
//IND_MD.S.3 is checked by 'IND.S.3'
//IND_MD.S.4 is checked by 'IND.S.4'
//IND_MD.S.5 is checked by 'IND.S.5'
//IND_MD.S.6 is checked by 'IND.S.6'
//IND_MD.S.7 is checked by 'IND.S.7'
//IND_MD.S.8 is checked by 'IND.S.8'
//IND_MD.S.9 is checked by 'IND.S.9'
//IND_MD.S.10 is checked by 'IND.S.10'
//IND_MD.R.1 is checked by IND.R.1
//IND_MD.R.2 is checked by 'IND.R.2'
//IND_MD.R.3 is checked by 'IND.R.3'
//IND_MD.R.4 is checked by 'IND.R.4'
//IND_MD.R.5 is checked by IND.R.5
//IND_MD.R.8 is checked by 'IND.R.8'
//IND_MD.R.10 is checked by 'IND.R.10'
//IND_MD.R.14 is checked by 'IND.R.14'
//IND_MD.DN.1 is checked by IND.DN.1
//IND_MD.DN.2 is checked by 'IND.DN.2'
//IND_MD.DN.3 is checked by 'IND.DN.3'
//IND_MD.DN.7 is checked by IND.DN.7

#ENDIF // BACK_END

#ENDIF // DFM_ONLY


#IFDEF DFM       // start DFM check



#IFDEF First_priority
#DEFINE CHECK_SRDODDN1_
#DEFINE CHECK_SRDPODN1_
#DEFINE CHECK_M1EN1_M1EN2_
#DEFINE CHECK_VIA1EN1_VIA1EN2_
#DEFINE CHECK_M2EN1_M2EN2_
#DEFINE CHECK_VIA2EN1_VIA2EN2_
#DEFINE CHECK_M3EN1_M3EN2_
#DEFINE CHECK_VIA3EN1_VIA3EN2_
#DEFINE CHECK_M4EN1_M4EN2_
#DEFINE CHECK_VIA4EN1_VIA4EN2_
#DEFINE CHECK_M5EN1_M5EN2_
#DEFINE CHECK_MxDN8_
#DEFINE CHECK_POS14m_
#DEFINE CHECK_POEN1m_
#DEFINE CHECK_POEN2m_
#DEFINE CHECK_POEN3m_
#DEFINE CHECK_POS5m_
#DEFINE CHECK_POS6m_
#DEFINE CHECK_POS61m_
#DEFINE CHECK_POEX1m_
#DEFINE CHECK_BJTR7_
#DEFINE CHECK_DTCDDN1_
#DEFINE CHECK_ICOVL_
#DEFINE CHECK_COR5_
#DEFINE CHECK_ROMR3_
#ENDIF // First_priority

#IFDEF Systematic
#DEFINE CHECK_POEX1_
#DEFINE CHECK_POEX2_
#DEFINE CHECK_DNWEN1_
#DEFINE CHECK_SRDODS3_
#DEFINE CHECK_SRDPOL1_
#DEFINE CHECK_SRDPOL3_
#DEFINE CHECK_POS2_
#DEFINE CHECK_POS4_1_
#DEFINE CHECK_POS5_
#DEFINE CHECK_POS6_
#DEFINE CHECK_POS17_
#DEFINE CHECK_ESDIMPEN1_
#DEFINE CHECK_COS3_
#DEFINE CHECK_COEN1_
#DEFINE CHECK_COEN11_
#DEFINE CHECK_COEN3_
#DEFINE CHECK_M1A1_
#DEFINE CHECK_M1EN1_M1EN2_
#DEFINE CHECK_M1DN6_
#DEFINE CHECK_VIA1EN1_VIA1EN2_
#DEFINE CHECK_M2EN1_M2EN2_
#DEFINE CHECK_VIA2EN1_VIA2EN2_
#DEFINE CHECK_M3EN1_M3EN2_
#DEFINE CHECK_VIA3EN1_VIA3EN2_
#DEFINE CHECK_M4EN1_M4EN2_
#DEFINE CHECK_VIA4EN1_VIA4EN2_
#DEFINE CHECK_M5EN1_M5EN2_
#DEFINE CHECK_M2A1_
#DEFINE CHECK_M3A1_
#DEFINE CHECK_M4A1_
#DEFINE CHECK_M5A1_
#DEFINE CHECK_M2DN6_

#DEFINE CHECK_M3DN6_
#DEFINE CHECK_MxDN7_M1_M2_M3_

#DEFINE CHECK_M4DN6_
#DEFINE CHECK_MxDN7_M2_M3_M4_

#DEFINE CHECK_M5DN6_
#DEFINE CHECK_MxDN7_M3_M4_M5_

#DEFINE CHECK_M6W3_
#DEFINE CHECK_MOMDN1_M1_
#DEFINE CHECK_MOMDN1_M2_
#DEFINE CHECK_MOMDN1_M3_
#DEFINE CHECK_MOMDN1_M4_
#DEFINE CHECK_MOMDN1_M5_
#DEFINE CHECK_INDDN8_
#DEFINE CHECK_INDDN9_
#DEFINE CHECK_POS14m_
#DEFINE CHECK_POEN1m_
#DEFINE CHECK_POEN2m_
#DEFINE CHECK_POEN3m_
#DEFINE CHECK_DTCDDN1_
#DEFINE CHECK_ICOVL_
#DEFINE CHECK_NWR1_
#DEFINE CHECK_COS6_
#DEFINE CHECK_DNWR6_
#ENDIF // Systematic

#IFDEF Defect
#DEFINE CHECK_ODS1_
#DEFINE CHECK_POS1_
#DEFINE CHECK_COS3_
#DEFINE CHECK_M1S1_
#DEFINE CHECK_M1A1_
#DEFINE CHECK_M1EN5_
#DEFINE CHECK_M2S1_
#DEFINE CHECK_M3S1_
#DEFINE CHECK_M4S1_
#DEFINE CHECK_M5S1_
#DEFINE CHECK_M2A1_
#DEFINE CHECK_M3A1_
#DEFINE CHECK_M4A1_
#DEFINE CHECK_M5A1_
#DEFINE CHECK_COR5_
#ENDIF // Defect

#IFDEF Parametric
#DEFINE CHECK_POEX1_
#DEFINE CHECK_POEX2_
#DEFINE CHECK_ODW1_
#DEFINE CHECK_ODDN4_
#DEFINE CHECK_ODDN5_
#DEFINE CHECK_ODDN6_
#DEFINE CHECK_ODDN7_
#DEFINE CHECK_ODDN8_
#DEFINE CHECK_ODDN9_
#DEFINE CHECK_DODR4_
#DEFINE CHECK_NWRODS3_
#DEFINE CHECK_SRDPOS1_
#DEFINE CHECK_NWRSTIEN2_
#DEFINE CHECK_POS2_
#DEFINE CHECK_POS4_1_
#DEFINE CHECK_POS5_
#DEFINE CHECK_POS6_
#DEFINE CHECK_POS17_
#DEFINE CHECK_POS18_
#DEFINE CHECK_PODN4_
#DEFINE CHECK_PODN5_
#DEFINE CHECK_PODN6_
#DEFINE CHECK_PODN7_
#DEFINE CHECK_PODN8_
#DEFINE CHECK_PODN9_
#DEFINE CHECK_COS7_
#DEFINE CHECK_COEN1_
#DEFINE CHECK_COEN11_
#DEFINE CHECK_COEN3_
#DEFINE CHECK_M1EN1_M1EN2_
#DEFINE CHECK_VIA1EN1_VIA1EN2_
#DEFINE CHECK_M2EN1_M2EN2_
#DEFINE CHECK_VIA2EN1_VIA2EN2_
#DEFINE CHECK_M3EN1_M3EN2_
#DEFINE CHECK_VIA3EN1_VIA3EN2_
#DEFINE CHECK_M4EN1_M4EN2_
#DEFINE CHECK_VIA4EN1_VIA4EN2_
#DEFINE CHECK_M5EN1_M5EN2_
#DEFINE CHECK_MOMDN1_M1_
#DEFINE CHECK_MOMDN1_M2_
#DEFINE CHECK_MOMDN1_M3_
#DEFINE CHECK_MOMDN1_M4_
#DEFINE CHECK_MOMDN1_M5_
#DEFINE CHECK_INDDN8_
#DEFINE CHECK_INDDN9_
#DEFINE CHECK_CTMW1_           // Systematic(Others) and SPICE related

#DEFINE CHECK_POS14m_
#DEFINE CHECK_POEN1m_
#DEFINE CHECK_POEN2m_
#DEFINE CHECK_POEN3m_
#DEFINE CHECK_POS5m_
#DEFINE CHECK_POS6m_
#DEFINE CHECK_POS61m_
#DEFINE CHECK_POEX1m_
#DEFINE CHECK_BJTR2_
#DEFINE CHECK_BJTR7_
#DEFINE CHECK_NWR1_
#DEFINE CHECK_NWRODR3_NWRSTIR3_
#DEFINE CHECK_NWRODR8_NWRSTIR4_
#DEFINE CHECK_RESR15_
#DEFINE CHECK_RESR16_
#DEFINE CHECK_RESR17_
#DEFINE CHECK_RESR18_
#DEFINE CHECK_RESR19_
#DEFINE CHECK_RESR20_
#DEFINE CHECK_COS6_
#DEFINE CHECK_COR5_
#DEFINE CHECK_DNWR6_
#ENDIF // Parametric

#IFDEF Required

#IFDEF CHECK_POEX2_
#IFDEF _POEX2_
POEX2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POEX2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POEX2_ODCell = POEX2_ODCellIn AND POEX2_ODCellOut
POEX2_ODMarker = ODi AND RRuleRequired
POEX2_OD = ((( POEX2_ODCell OR POEX2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

RR:AR:PO.EX.2 { @ Recommended OD extension on PO >= ^PO_EX_2_R um
  (ENC POLY POEX2_OD < PO_EX_2_R ABUT < 90 SINGULAR OPPOSITE REGION) NOT INSIDE ((LOGO OR TCDDMY) OR SRAM_REGION)
}
#ENDIF // _POEX2_
#ENDIF // CHECK_POEX2_

#IFDEF CHECK_POS5_
#IFDEF _POS5_
// PO.S.5.LP.R is checked by RR:AR:PO.S.5
// PO.S.5.GS.R is checked by RR:AR:PO.S.5
POS5_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POS5_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POS5_POCell = POS5_POCellIn AND POS5_POCellOut
POS5_POMarker = POi AND RRuleRequired
POS5_PO = ((( POS5_POCell OR POS5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS5_GateW = GATE_W COIN INSIDE EDGE POS5_PO
POS5_GateWExp = EXPAND EDGE POS5_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5_GateWExe = POS5_PO COIN INSIDE EDGE POS5_GateWExp
RR:AR:PO.S.5 { @ Recommended PO space to L-shape OD when PO and OD are in the same MOS >= ^PO_S_5_R um
  (EXT POS5_GateWExe ODi < PO_S_5_R ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _POS5_
#ENDIF // CHECK_POS5_

#IFDEF CHECK_POS6_
#IFDEF _POS6_
// PO.S.6.LP.R is checked by RR:AR:PO.S.6
// PO.S.6.GS.R is checked by RR:AR:PO.S.6
POS6_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS6_ODCell = POS6_ODCellIn AND POS6_ODCellOut
POS6_ODMarker = ODi AND RRuleRequired
POS6_OD = ((( POS6_ODCell OR POS6_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS6_OD_CHK = POS6_OD NOT TCDDMY
POS6_GateL = GATE_L COIN INSIDE EDGE POS6_OD_CHK
POS6_GateLExp = EXPAND EDGE POS6_GateL INSIDE BY GRID EXTEND BY PO_S_1
POS6_GateLExe = (POS6_OD_CHK COIN INSIDE EDGE POS6_GateLExp) TOUCH INSIDE EDGE POS6_GateL
RR:AR:PO.S.6 { @ Recommended L-shape PO Space to OD when PO and OD are in the same MOS >= ^PO_S_6_R um
  (EXT POS6_GateLExe POi < PO_S_6_R ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _POS6_
#ENDIF // CHECK_POS6_

#ENDIF // Required

#IFDEF Recommended





#IFDEF CHECK_SRDODS3_
#IFDEF _SRDODS3_
SRDODS3_SRDODCellIn = INSIDE CELL SRDOD CellsForRRuleRecommended  
SRDODS3_SRDODCellOut = NOT INSIDE CELL SRDOD ExclCellsForRRuleRecommended 
SRDODS3_SRDODCell = SRDODS3_SRDODCellIn AND SRDODS3_SRDODCellOut
SRDODS3_SRDODMarker = SRDOD AND RRuleRecommended
SRDODS3_SRDOD = ((( SRDODS3_SRDODCell OR SRDODS3_SRDODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:SR_DOD.S.3 { @ Recommended space to DPO, SR_DPO >= 0.05 
  EXT SRDODS3_SRDOD DPO < SRDOD_S_3_R ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDODS3_SRDOD SRDPO < SRDOD_S_3_R ABUT < 90 SINGULAR REGION INSIDE ALSO
}
#ENDIF // _SRDODS3_
#ENDIF // CHECK_SRDODS3_


#IFDEF CHECK_SRDPOL1_
#IFDEF _SRDPOL1_
SRDPOL1_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOL1_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOL1_SRDPOCell = SRDPOL1_SRDPOCellIn AND SRDPOL1_SRDPOCellOut
SRDPOL1_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOL1_SRDPO = ((( SRDPOL1_SRDPOCell OR SRDPOL1_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:L:SR_DPO.L.1 { @ Recommended length of SR_DPO ^SRDPO_L_1_R um
  NOT ENCLOSE RECTANGLE (SRDPO INTERACT SRDPOL1_SRDPO) SRDPO_L_1_R GRID ORTHOGONAL ONLY
}
#ENDIF // _SRDPOL1_
#ENDIF // CHECK_SRDPOL1_

#IFDEF CHECK_SRDPOL3_
#IFDEF _SRDPOL3_
SRDPOL3_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOL3_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOL3_SRDPOCell = SRDPOL3_SRDPOCellIn AND SRDPOL3_SRDPOCellOut
SRDPOL3_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOL3_SRDPO = ((( SRDPOL3_SRDPOCell OR SRDPOL3_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:L:SR_DPO.L.3 { @ Recommended maximum Length <= 10 
  ENCLOSE RECTANGLE (SRDPO INTERACT SRDPOL3_SRDPO) SRDPO_L_3_R+GRID GRID ORTHOGONAL ONLY
}
#ENDIF // _SRDPOL3_
#ENDIF // CHECK_SRDPOL3_
#IFDEF CHECK_DNWEN1_
#IFDEF _DNWEN1_
DNWEN1_DNWCellIn = INSIDE CELL DNWi CellsForRRuleRecommended  
DNWEN1_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleRecommended 
DNWEN1_DNWCell = DNWEN1_DNWCellIn AND DNWEN1_DNWCellOut
DNWEN1_DNWMarker = DNWi AND RRuleRecommended
DNWEN1_DNW = ((( DNWEN1_DNWCell OR DNWEN1_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:DNW.EN.1 { @ Enclosure by NW >= ^DNW_EN_1_R um for better noise isolation.
  ENC DNWEN1_DNW NWEL < DNW_EN_1_R ABUT < 90 SINGULAR REGION
  DNWEN1_DNW OUTSIDE EDGE NWEL
}
#ENDIF // _DNWEN1_
#ENDIF // CHECK_DNWEN1_

#IFDEF CHECK_ESDIMPEN1_
#IFDEF _ESDIMPEN1_
ESDIMPEN1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ESDIMPEN1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ESDIMPEN1_ODCell = ESDIMPEN1_ODCellIn AND ESDIMPEN1_ODCellOut
ESDIMPEN1_ODMarker = ODi AND RRuleRecommended
ESDIMPEN1_OD = ((( ESDIMPEN1_ODCell OR ESDIMPEN1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:S:ESDIMP.EN.1 { @ Recommended (OD NOT PO) enclosure of ESDIMP == ^ESDIMP_EN_1R um
  OD_NPO = ESDIMPEN1_OD NOT POLY
  OD_NPO_ESD = SIZE (OD_NPO INTERACT ESDIMP) BY -ESDIMP_EN_1R
  ESDIMP_OD = ESDIMP INTERACT OD_NPO
  XOR OD_NPO_ESD ESDIMP_OD
}
#ENDIF // _ESDIMPEN1_
#ENDIF // CHECK_ESDIMPEN1_

#IFNDEF FULL_CHIP
#IFDEF CHECK_M1DN6_
#IFDEF _M1DN6_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M1DN6_CHIP_Boundary_A = prBoundary NOT (SIZE prBoundary BY -M1_DN_6_CS_A_R)
M1DN6_CHIP_Boundary_B = prBoundary NOT (SIZE prBoundary BY -M1_DN_6_CS_B_R)
M1DN6_CHIP_Boundary_C = prBoundary NOT (SIZE prBoundary BY -M1_DN_6_CS_C_R)
#ELSE
M1DN6_CHIP_Boundary_A = CHIP_M1 NOT (SIZE CHIP_M1 BY -M1_DN_6_CS_A_R)
M1DN6_CHIP_Boundary_B = CHIP_M1 NOT (SIZE CHIP_M1 BY -M1_DN_6_CS_B_R)
M1DN6_CHIP_Boundary_C = CHIP_M1 NOT (SIZE CHIP_M1 BY -M1_DN_6_CS_C_R)
#ENDIF

RR:RE:S:M1.DN.6 { @ Recommend metal Desnsity >= ^M1_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M1_DN_6_W_A_R um x ^M1_DN_6_W_A_R um, stepping ^M1_DN_6_S_A_R um] >= ^M1_DN_6_R. This condition is applied for {IP NOT (IP SIZING - ^M1_DN_6_CS_A_R um)} region.
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M1_DN_6_W_BC_R um x ^M1_DN_6_W_BC_R um, stepping ^M1_DN_6_S_BC_R um < ^M1_DN_6_R] <= ^M1_DN_6_A_B_R um2, except merged low density windows width <= ^M1_DN_6_U_R um. This condition is applied for {IP NOT (IP SIZING - ^M1_DN_6_CS_B_R um)} region.
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M1_DN_6_W_BC_R um x ^M1_DN_6_W_BC_R um, stepping ^M1_DN_6_S_BC_R um < ^M1_DN_6_R] <= ^M1_DN_6_A_C_R um2. This condition is applied for {IP NOT (IP SIZING - ^M1_DN_6_CS_C_R um)} region.
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_6_E_A_R um for condition-A and >= ^M1_DN_6_E_BC_R um for both condition-B/condition-C
  M1_CHECK = M1x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_A_R STEP M1_DN_6_S_A_R INSIDE OF LAYER CHIP_M1 BACKUP
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M1_DN_6_E_A_R
  X = DENSITY F_A M1_CHECK CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_A_R STEP M1_DN_6_S_A_R INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6R_A.density
         [ !AREA(F_A)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  (X NOT excludeRRuleRecommended) AND M1DN6_CHIP_Boundary_A
  // Condition-B
  ERR_WIN_B = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_BC_R STEP M1_DN_6_S_BC_R INSIDE OF LAYER CHIP_M1 BACKUP
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M1_DN_6_E_BC_R
  A = DENSITY F_B M1_CHECK CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_BC_R STEP M1_DN_6_S_BC_R INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6R_BC.density
         [ !AREA(F_B)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M1_DN_6_A_B_R
  C = SIZE B BY M1_DN_6_U_R/2 UNDEROVER
  ((B INTERACT C) NOT excludeRRuleRecommended) AND M1DN6_CHIP_Boundary_B
  // Condition-C
  ((AREA B > M1_DN_6_A_C_R) NOT excludeRRuleRecommended) AND M1DN6_CHIP_Boundary_C
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _M1DN6_
#ENDIF // CHECK_M1DN6_
#ENDIF // FULL_CHIP

#IFNDEF FULL_CHIP
#IFDEF CHECK_M2DN6_
#IFDEF _M2DN6_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M2DN6_CHIP_Boundary_A = prBoundary NOT (SIZE prBoundary BY -M2_DN_6_CS_A_R)
M2DN6_CHIP_Boundary_B = prBoundary NOT (SIZE prBoundary BY -M2_DN_6_CS_B_R)
M2DN6_CHIP_Boundary_C = prBoundary NOT (SIZE prBoundary BY -M2_DN_6_CS_C_R)
#ELSE
M2DN6_CHIP_Boundary_A = CHIP_M2 NOT (SIZE CHIP_M2 BY -M2_DN_6_CS_A_R)
M2DN6_CHIP_Boundary_B = CHIP_M2 NOT (SIZE CHIP_M2 BY -M2_DN_6_CS_B_R)
M2DN6_CHIP_Boundary_C = CHIP_M2 NOT (SIZE CHIP_M2 BY -M2_DN_6_CS_C_R)
#ENDIF

RR:RE:S:M2.DN.6 { @ Recommend metal Desnsity >= ^M2_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M2_DN_6_W_A_R um x ^M2_DN_6_W_A_R um, stepping ^M2_DN_6_S_A_R um] >= ^M2_DN_6_R. This condition is applied for {IP NOT (IP SIZING - ^M2_DN_6_CS_A_R um)} region.
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M2_DN_6_W_BC_R um x ^M2_DN_6_W_BC_R um, stepping ^M2_DN_6_S_BC_R um < ^M2_DN_6_R] <= ^M2_DN_6_A_B_R um2, except merged low density windows width <= ^M2_DN_6_U_R um. This condition is applied for {IP NOT (IP SIZING - ^M2_DN_6_CS_B_R um)} region.
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M2_DN_6_W_BC_R um x ^M2_DN_6_W_BC_R um, stepping ^M2_DN_6_S_BC_R um < ^M2_DN_6_R] <= ^M2_DN_6_A_C_R um2. This condition is applied for {IP NOT (IP SIZING - ^M2_DN_6_CS_C_R um)} region.
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_6_E_A_R um for condition-A and >= ^M2_DN_6_E_BC_R um for both condition-B/condition-C
  M2_CHECK = M2x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_A_R STEP M2_DN_6_S_A_R INSIDE OF LAYER CHIP_M2 BACKUP
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M2_DN_6_E_A_R
  X = DENSITY F_A M2_CHECK CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_A_R STEP M2_DN_6_S_A_R INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6R_A.density
         [ !AREA(F_A)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  (X NOT excludeRRuleRecommended) AND M2DN6_CHIP_Boundary_A
  // Condition-B
  ERR_WIN_B = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_BC_R STEP M2_DN_6_S_BC_R INSIDE OF LAYER CHIP_M2 BACKUP
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M2_DN_6_E_BC_R
  A = DENSITY F_B M2_CHECK CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_BC_R STEP M2_DN_6_S_BC_R INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6R_BC.density
         [ !AREA(F_B)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M2_DN_6_A_B_R
  C = SIZE B BY M2_DN_6_U_R/2 UNDEROVER
  ((B INTERACT C) NOT excludeRRuleRecommended) AND M2DN6_CHIP_Boundary_B
  // Condition-C
  ((AREA B > M2_DN_6_A_C_R) NOT excludeRRuleRecommended) AND M2DN6_CHIP_Boundary_C
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _M2DN6_
#ENDIF // CHECK_M2DN6_
#ENDIF // FULL_CHIP

#IFNDEF FULL_CHIP
#IFDEF CHECK_M3DN6_
#IFDEF _M3DN6_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M3DN6_CHIP_Boundary_A = prBoundary NOT (SIZE prBoundary BY -M3_DN_6_CS_A_R)
M3DN6_CHIP_Boundary_B = prBoundary NOT (SIZE prBoundary BY -M3_DN_6_CS_B_R)
M3DN6_CHIP_Boundary_C = prBoundary NOT (SIZE prBoundary BY -M3_DN_6_CS_C_R)
#ELSE
M3DN6_CHIP_Boundary_A = CHIP_M3 NOT (SIZE CHIP_M3 BY -M3_DN_6_CS_A_R)
M3DN6_CHIP_Boundary_B = CHIP_M3 NOT (SIZE CHIP_M3 BY -M3_DN_6_CS_B_R)
M3DN6_CHIP_Boundary_C = CHIP_M3 NOT (SIZE CHIP_M3 BY -M3_DN_6_CS_C_R)
#ENDIF

RR:RE:S:M3.DN.6 { @ Recommend metal Desnsity >= ^M3_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M3_DN_6_W_A_R um x ^M3_DN_6_W_A_R um, stepping ^M3_DN_6_S_A_R um] >= ^M3_DN_6_R. This condition is applied for {IP NOT (IP SIZING - ^M3_DN_6_CS_A_R um)} region.
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M3_DN_6_W_BC_R um x ^M3_DN_6_W_BC_R um, stepping ^M3_DN_6_S_BC_R um < ^M3_DN_6_R] <= ^M3_DN_6_A_B_R um2, except merged low density windows width <= ^M3_DN_6_U_R um. This condition is applied for {IP NOT (IP SIZING - ^M3_DN_6_CS_B_R um)} region.
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M3_DN_6_W_BC_R um x ^M3_DN_6_W_BC_R um, stepping ^M3_DN_6_S_BC_R um < ^M3_DN_6_R] <= ^M3_DN_6_A_C_R um2. This condition is applied for {IP NOT (IP SIZING - ^M3_DN_6_CS_C_R um)} region.
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_6_E_A_R um for condition-A and >= ^M3_DN_6_E_BC_R um for both condition-B/condition-C
  M3_CHECK = M3x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_A_R STEP M3_DN_6_S_A_R INSIDE OF LAYER CHIP_M3 BACKUP
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M3_DN_6_E_A_R
  X = DENSITY F_A M3_CHECK CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_A_R STEP M3_DN_6_S_A_R INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6R_A.density
         [ !AREA(F_A)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  (X NOT excludeRRuleRecommended) AND M3DN6_CHIP_Boundary_A
  // Condition-B
  ERR_WIN_B = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_BC_R STEP M3_DN_6_S_BC_R INSIDE OF LAYER CHIP_M3 BACKUP
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M3_DN_6_E_BC_R
  A = DENSITY F_B M3_CHECK CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_BC_R STEP M3_DN_6_S_BC_R INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6R_BC.density
         [ !AREA(F_B)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M3_DN_6_A_B_R
  C = SIZE B BY M3_DN_6_U_R/2 UNDEROVER
  ((B INTERACT C) NOT excludeRRuleRecommended) AND M3DN6_CHIP_Boundary_B
  // Condition-C
  ((AREA B > M3_DN_6_A_C_R) NOT excludeRRuleRecommended) AND M3DN6_CHIP_Boundary_C
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _M3DN6_
#ENDIF // CHECK_M3DN6_
#ENDIF // FULL_CHIP
#IFNDEF FULL_CHIP
#IFDEF CHECK_MxDN7_M1_M2_M3_
#IFDEF _MxDN7_M1_M2_M3_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M3DN7_CHIP_Boundary = prBoundary NOT (SIZE prBoundary BY -M1_DN_7_CS_R)
#ELSE
M3DN7_CHIP_Boundary = CHIP_M3 NOT (SIZE CHIP_M3 BY -M1_DN_7_CS_R)
#ENDIF

RR:RE:S:Mx.DN.7:M1_M2_M3 { @ It is not recommended to have local density < ^M1_DN_7_R of all 3 consecutive metal layer(M1, M2, M3) over any ^M1_DN_7_W_R um x ^M1_DN_7_W_R um window (stepping ^M1_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M1, M2, or M3 to have a local density >= ^M1_DN_7_R. This condition is applied for {IP NOT (IP SIZING - ^M1_DN_7_CS_R um)} region
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_7_E_R um
  M1_CHECK = M1x NOT NEW_DEN_EXC
  M2_CHECK = M2x NOT NEW_DEN_EXC
  M3_CHECK = M3x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  ERR_WIN = DENSITY M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W_R STEP M1_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M3
  [ !~(M1_DN_7_R-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7_R-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
  F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M1_DN_7_E_R
  X = DENSITY F M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W_R STEP M1_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M3
  [ !!AREA(F)*!~(M1_DN_7_R-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7_R-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
  RDB Mx.DN.7R:M1_M2_M3.density
  (X NOT excludeRRuleRecommended) AND M3DN7_CHIP_Boundary
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _MxDN7_M1_M2_M3_
#ENDIF // CHECK_MxDN7_M1_M2_M3_
#ENDIF // FULL_CHIP

#IFNDEF FULL_CHIP
#IFDEF CHECK_M4DN6_
#IFDEF _M4DN6_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M4DN6_CHIP_Boundary_A = prBoundary NOT (SIZE prBoundary BY -M4_DN_6_CS_A_R)
M4DN6_CHIP_Boundary_B = prBoundary NOT (SIZE prBoundary BY -M4_DN_6_CS_B_R)
M4DN6_CHIP_Boundary_C = prBoundary NOT (SIZE prBoundary BY -M4_DN_6_CS_C_R)
#ELSE
M4DN6_CHIP_Boundary_A = CHIP_M4 NOT (SIZE CHIP_M4 BY -M4_DN_6_CS_A_R)
M4DN6_CHIP_Boundary_B = CHIP_M4 NOT (SIZE CHIP_M4 BY -M4_DN_6_CS_B_R)
M4DN6_CHIP_Boundary_C = CHIP_M4 NOT (SIZE CHIP_M4 BY -M4_DN_6_CS_C_R)
#ENDIF

RR:RE:S:M4.DN.6 { @ Recommend metal Desnsity >= ^M4_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M4_DN_6_W_A_R um x ^M4_DN_6_W_A_R um, stepping ^M4_DN_6_S_A_R um] >= ^M4_DN_6_R. This condition is applied for {IP NOT (IP SIZING - ^M4_DN_6_CS_A_R um)} region.
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M4_DN_6_W_BC_R um x ^M4_DN_6_W_BC_R um, stepping ^M4_DN_6_S_BC_R um < ^M4_DN_6_R] <= ^M4_DN_6_A_B_R um2, except merged low density windows width <= ^M4_DN_6_U_R um. This condition is applied for {IP NOT (IP SIZING - ^M4_DN_6_CS_B_R um)} region.
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M4_DN_6_W_BC_R um x ^M4_DN_6_W_BC_R um, stepping ^M4_DN_6_S_BC_R um < ^M4_DN_6_R] <= ^M4_DN_6_A_C_R um2. This condition is applied for {IP NOT (IP SIZING - ^M4_DN_6_CS_C_R um)} region.
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M4_DN_6_E_A_R um for condition-A and >= ^M4_DN_6_E_BC_R um for both condition-B/condition-C
  M4_CHECK = M4x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_A_R STEP M4_DN_6_S_A_R INSIDE OF LAYER CHIP_M4 BACKUP
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M4_DN_6_E_A_R
  X = DENSITY F_A M4_CHECK CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_A_R STEP M4_DN_6_S_A_R INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6R_A.density
         [ !AREA(F_A)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  (X NOT excludeRRuleRecommended) AND M4DN6_CHIP_Boundary_A
  // Condition-B
  ERR_WIN_B = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_BC_R STEP M4_DN_6_S_BC_R INSIDE OF LAYER CHIP_M4 BACKUP
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M4_DN_6_E_BC_R
  A = DENSITY F_B M4_CHECK CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_BC_R STEP M4_DN_6_S_BC_R INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6R_BC.density
         [ !AREA(F_B)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M4_DN_6_A_B_R
  C = SIZE B BY M4_DN_6_U_R/2 UNDEROVER
  ((B INTERACT C) NOT excludeRRuleRecommended) AND M4DN6_CHIP_Boundary_B
  // Condition-C
  ((AREA B > M4_DN_6_A_C_R) NOT excludeRRuleRecommended) AND M4DN6_CHIP_Boundary_C
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _M4DN6_
#ENDIF // CHECK_M4DN6_
#ENDIF // FULL_CHIP
#IFNDEF FULL_CHIP
#IFDEF CHECK_MxDN7_M2_M3_M4_
#IFDEF _MxDN7_M2_M3_M4_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M4DN7_CHIP_Boundary = prBoundary NOT (SIZE prBoundary BY -M2_DN_7_CS_R)
#ELSE
M4DN7_CHIP_Boundary = CHIP_M4 NOT (SIZE CHIP_M4 BY -M2_DN_7_CS_R)
#ENDIF

RR:RE:S:Mx.DN.7:M2_M3_M4 { @ It is not recommended to have local density < ^M2_DN_7_R of all 3 consecutive metal layer(M2, M3, M4) over any ^M2_DN_7_W_R um x ^M2_DN_7_W_R um window (stepping ^M2_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M2, M3, or M4 to have a local density >= ^M2_DN_7_R. This condition is applied for {IP NOT (IP SIZING - ^M2_DN_7_CS_R um)} region
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_7_E_R um
  M2_CHECK = M2x NOT NEW_DEN_EXC
  M3_CHECK = M3x NOT NEW_DEN_EXC
  M4_CHECK = M4x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  ERR_WIN = DENSITY M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W_R STEP M2_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M4
  [ !~(M2_DN_7_R-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7_R-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
  F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M2_DN_7_E_R
  X = DENSITY F M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W_R STEP M2_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M4
  [ !!AREA(F)*!~(M2_DN_7_R-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7_R-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
  RDB Mx.DN.7R:M2_M3_M4.density
  (X NOT excludeRRuleRecommended) AND M4DN7_CHIP_Boundary
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _MxDN7_M2_M3_M4_
#ENDIF // CHECK_MxDN7_M2_M3_M4_
#ENDIF // FULL_CHIP

#IFNDEF FULL_CHIP
#IFDEF CHECK_M5DN6_
#IFDEF _M5DN6_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M5DN6_CHIP_Boundary_A = prBoundary NOT (SIZE prBoundary BY -M5_DN_6_CS_A_R)
M5DN6_CHIP_Boundary_B = prBoundary NOT (SIZE prBoundary BY -M5_DN_6_CS_B_R)
M5DN6_CHIP_Boundary_C = prBoundary NOT (SIZE prBoundary BY -M5_DN_6_CS_C_R)
#ELSE
M5DN6_CHIP_Boundary_A = CHIP_M5 NOT (SIZE CHIP_M5 BY -M5_DN_6_CS_A_R)
M5DN6_CHIP_Boundary_B = CHIP_M5 NOT (SIZE CHIP_M5 BY -M5_DN_6_CS_B_R)
M5DN6_CHIP_Boundary_C = CHIP_M5 NOT (SIZE CHIP_M5 BY -M5_DN_6_CS_C_R)
#ENDIF

RR:RE:S:M5.DN.6 { @ Recommend metal Desnsity >= ^M5_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M5_DN_6_W_A_R um x ^M5_DN_6_W_A_R um, stepping ^M5_DN_6_S_A_R um] >= ^M5_DN_6_R. This condition is applied for {IP NOT (IP SIZING - ^M5_DN_6_CS_A_R um)} region.
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M5_DN_6_W_BC_R um x ^M5_DN_6_W_BC_R um, stepping ^M5_DN_6_S_BC_R um < ^M5_DN_6_R] <= ^M5_DN_6_A_B_R um2, except merged low density windows width <= ^M5_DN_6_U_R um. This condition is applied for {IP NOT (IP SIZING - ^M5_DN_6_CS_B_R um)} region.
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M5_DN_6_W_BC_R um x ^M5_DN_6_W_BC_R um, stepping ^M5_DN_6_S_BC_R um < ^M5_DN_6_R] <= ^M5_DN_6_A_C_R um2. This condition is applied for {IP NOT (IP SIZING - ^M5_DN_6_CS_C_R um)} region.
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M5_DN_6_E_A_R um for condition-A and >= ^M5_DN_6_E_BC_R um for both condition-B/condition-C
  M5_CHECK = M5x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_A_R STEP M5_DN_6_S_A_R INSIDE OF LAYER CHIP_M5 BACKUP
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M5_DN_6_E_A_R
  X = DENSITY F_A M5_CHECK CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_A_R STEP M5_DN_6_S_A_R INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6R_A.density
         [ !AREA(F_A)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  (X NOT excludeRRuleRecommended) AND M5DN6_CHIP_Boundary_A
  // Condition-B
  ERR_WIN_B = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_BC_R STEP M5_DN_6_S_BC_R INSIDE OF LAYER CHIP_M5 BACKUP
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M5_DN_6_E_BC_R
  A = DENSITY F_B M5_CHECK CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_BC_R STEP M5_DN_6_S_BC_R INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6R_BC.density
         [ !AREA(F_B)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M5_DN_6_A_B_R
  C = SIZE B BY M5_DN_6_U_R/2 UNDEROVER
  ((B INTERACT C) NOT excludeRRuleRecommended) AND M5DN6_CHIP_Boundary_B
  // Condition-C
  ((AREA B > M5_DN_6_A_C_R) NOT excludeRRuleRecommended) AND M5DN6_CHIP_Boundary_C
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _M5DN6_
#ENDIF // CHECK_M5DN6_
#ENDIF // FULL_CHIP
#IFNDEF FULL_CHIP
#IFDEF CHECK_MxDN7_M3_M4_M5_
#IFDEF _MxDN7_M3_M4_M5_
#IFDEF CHECK_LOW_DENSITY
#IFDEF CHECK_PRBOUNDARY_DENSITY
M5DN7_CHIP_Boundary = prBoundary NOT (SIZE prBoundary BY -M3_DN_7_CS_R)
#ELSE
M5DN7_CHIP_Boundary = CHIP_M5 NOT (SIZE CHIP_M5 BY -M3_DN_7_CS_R)
#ENDIF

RR:RE:S:Mx.DN.7:M3_M4_M5 { @ It is not recommended to have local density < ^M3_DN_7_R of all 3 consecutive metal layer(M3, M4, M5) over any ^M3_DN_7_W_R um x ^M3_DN_7_W_R um window (stepping ^M3_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M3, M4, or M5 to have a local density >= ^M3_DN_7_R. This condition is applied for {IP NOT (IP SIZING - ^M3_DN_7_CS_R um)} region
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc.
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_7_E_R um
  M3_CHECK = M3x NOT NEW_DEN_EXC
  M4_CHECK = M4x NOT NEW_DEN_EXC
  M5_CHECK = M5x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  ERR_WIN = DENSITY M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W_R STEP M3_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M5
  [ !~(M3_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7_R-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7_R-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
  F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M3_DN_7_E_R
  X = DENSITY F M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W_R STEP M3_DN_7_S_R BACKUP INSIDE OF LAYER CHIP_M5
  [ !!AREA(F)*!~(M3_DN_7_R-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7_R-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7_R-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
  RDB Mx.DN.7R:M3_M4_M5.density
  (X NOT excludeRRuleRecommended) AND M5DN7_CHIP_Boundary
}
#ENDIF // CHECK_LOW_DENSITY
#ENDIF // _MxDN7_M3_M4_M5_
#ENDIF // CHECK_MxDN7_M3_M4_M5_
#ENDIF // FULL_CHIP

#IFDEF CHECK_M6W3_
#IFDEF _M6W3_
#IFDEF MIXED_SCHEME
M6W3_M6_OLDCellIn = INSIDE CELL M6_OLD CellsForRRuleRecommended  
M6W3_M6_OLDCellOut = NOT INSIDE CELL M6_OLD ExclCellsForRRuleRecommended 
M6W3_M6_OLDCell = M6W3_M6_OLDCellIn AND M6W3_M6_OLDCellOut
M6W3_M6_OLDMarker = M6_OLD AND RRuleRecommended
M6W3_M6_OLD = ((M6W3_M6_OLDCell OR M6W3_M6_OLDMarker) NOT Block ) NOT excludeRRuleRecommended

M6W3_M6_NEWCellIn = INSIDE CELL M6_NEW CellsForRRuleRecommended  
M6W3_M6_NEWCellOut = NOT INSIDE CELL M6_NEW ExclCellsForRRuleRecommended 
M6W3_M6_NEWCell = M6W3_M6_NEWCellIn AND M6W3_M6_NEWCellOut
M6W3_M6_NEWMarker = M6_NEW AND RRuleRecommended
M6W3_M6_NEW = ((M6W3_M6_NEWCell OR M6W3_M6_NEWMarker) NOT Block ) NOT excludeRRuleRecommended

M6W3_M6 = M6W3_M6_OLD OR M6W3_M6_NEW
#ELSE
M6W3_M6CellIn = INSIDE CELL M6_NEW CellsForRRuleRecommended  
M6W3_M6CellOut = NOT INSIDE CELL M6_NEW ExclCellsForRRuleRecommended 
M6W3_M6Cell = M6W3_M6CellIn AND M6W3_M6CellOut
M6W3_M6Marker = M6_NEW AND RRuleRecommended
M6W3_M6 = ((M6W3_M6Cell OR M6W3_M6Marker) NOT Block ) NOT excludeRRuleRecommended

#ENDIF // MIXED_SCHEME
M6W3_EXT = CHIP NOT ( SIZE M5x BY (M6_W_3_S_R/2 - 0.001) OVERUNDER )
M6W3_BIG = SIZE( SIZE M6W3_EXT BY (M6_W_3_S_R/2 - 0.001) UNDEROVER ) BY M6_W_3_G_R
M6W3_CHECK = M6W3_M6 INSIDE EDGE M6W3_BIG
RR:RE:S:M6.W.3 { @ Recommended M6 width on (M5 OR DM5 with space>= ^M6_W_3_S_R x ^M6_W_3_S_R sizing ^M6_W_3_G_R) >= ^M6_W_3_R
  INT M6W3_CHECK < M6_W_3_R ABUT < 89.5 REGION
}
#ENDIF // _M6W3_
#ENDIF // CHECK_M6W3_




#IFDEF CHECK_ODS1_
#IFDEF _ODS1_
ODS1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS1_ODCell = ODS1_ODCellIn AND ODS1_ODCellOut
ODS1_ODMarker = ODi AND RRuleRecommended
ODS1_OD = ((( ODS1_ODCell OR ODS1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:OD.S.1 { @ OD space >= ^OD_S_1_R um, to reduce short possibility
  A = ODS1_OD NOT TCDDMY
  (EXT A < OD_S_1_R ABUT < 90 REGION SINGULAR) NOT INSIDE SRAM_REGION 
}
#ENDIF // _ODS1_
#ENDIF // CHECK_ODS1_

#IFDEF CHECK_POS1_
#IFDEF _POS1_
POS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS1_POCell = POS1_POCellIn AND POS1_POCellOut
POS1_POMarker = POi AND RRuleRecommended
POS1_PO = ((( POS1_POCell OR POS1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS1_PO_CHK = POS1_PO NOT TCDDMY
POS1Err = EXT [POS1_PO_CHK] < PO_S_1_R ABUT < 90
POS1ErrLong = POS1Err NOT TOUCH EDGE GATE  // exclude gate space checking
RR:RE:D:PO.S.1 { @ PO interconnect space >= ^PO_S_1_R um, to reduce short possibility
  (EXT POS1ErrLong < PO_S_1_R ABUT < 90 REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _POS1_
#ENDIF // CHECK_POS1_

#IFDEF CHECK_M1S1_
#IFDEF _M1S1_
M1S1_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S1_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S1_M1Cell = M1S1_M1CellIn AND M1S1_M1CellOut
M1S1_M1Marker = M1i AND RRuleRecommended
M1S1_M1 = ((( M1S1_M1Cell OR M1S1_M1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:M1.S.1 { @ M1 space >= ^M1_S_1_R um
  (EXT M1S1_M1 < M1_S_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _M1S1_
#ENDIF // CHECK_M1S1_

#IFDEF CHECK_M2S1_
#IFDEF _M2S1_
M2S1_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S1_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S1_M2Cell = M2S1_M2CellIn AND M2S1_M2CellOut
M2S1_M2Marker = M2i AND RRuleRecommended
M2S1_M2 = ((M2S1_M2Cell OR M2S1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M2.S.1 { @ M2 space >= ^M2_S_1_R um
  (EXT M2S1_M2 < M2_S_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _M2S1_
#ENDIF // CHECK_M2S1_

#IFDEF CHECK_M3S1_
#IFDEF _M3S1_
M3S1_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S1_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S1_M3Cell = M3S1_M3CellIn AND M3S1_M3CellOut
M3S1_M3Marker = M3i AND RRuleRecommended
M3S1_M3 = ((M3S1_M3Cell OR M3S1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M3.S.1 { @ M3 space >= ^M3_S_1_R um
  (EXT M3S1_M3 < M3_S_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _M3S1_
#ENDIF // CHECK_M3S1_

#IFDEF CHECK_M4S1_
#IFDEF _M4S1_
M4S1_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S1_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S1_M4Cell = M4S1_M4CellIn AND M4S1_M4CellOut
M4S1_M4Marker = M4i AND RRuleRecommended
M4S1_M4 = ((M4S1_M4Cell OR M4S1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M4.S.1 { @ M4 space >= ^M4_S_1_R um
  EXT M4S1_M4 < M4_S_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _M4S1_
#ENDIF // CHECK_M4S1_

#IFDEF CHECK_M5S1_
#IFDEF _M5S1_
M5S1_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5S1_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5S1_M5Cell = M5S1_M5CellIn AND M5S1_M5CellOut
M5S1_M5Marker = M5i AND RRuleRecommended
M5S1_M5 = ((M5S1_M5Cell OR M5S1_M5Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M5.S.1 { @ M5 space >= ^M5_S_1_R um
  EXT M5S1_M5 < M5_S_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _M5S1_
#ENDIF // CHECK_M5S1_


#IFDEF CHECK_ODW1_
#IFDEF _ODW1_
ODW1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODW1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODW1_ODCell = ODW1_ODCellIn AND ODW1_ODCellOut
ODW1_ODMarker = ODi AND RRuleRecommended
ODW1_OD = ((( ODW1_ODCell OR ODW1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:P:OD.W.1 { @ Recommended interconnect OD width (except MOMDMY(155;21) region and TCDDMY) >= ^OD_W_1_R um
  A = (ODW1_OD NOT POi) NOT TCDDMY
  ((INT A < OD_W_1_R ABUT < 90 SINGULAR REGION) NOT MOMDMY) NOT INSIDE SRAM_REGION
}
#ENDIF // _ODW1_
#ENDIF // CHECK_ODW1_

#IFDEF CHECK_NWRODS3_
#IFDEF _NWRODS3_
NWRODS3_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRODS3_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRODS3_NWCell = NWRODS3_NWCellIn AND NWRODS3_NWCellOut
NWRODS3_NWMarker = NWi AND RRuleRecommended
NWRODS3_NW = ((( NWRODS3_NWCell OR NWRODS3_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWROD.S.3 { @ RPO space to CO in NWEL resistor within OD for SPICE simulation accuracy == ^NWROD_S_3_R um
  A = RPO INSIDE EDGE ( NWRES AND NWRODS3_NW )
  B = EXPAND EDGE A OUTSIDE BY NWROD_S_3_R
  B AND COWR
  B NOT INTERACT COWR
}
#ENDIF // _NWRODS3_
#ENDIF // CHECK_NWRODS3_

#IFDEF CHECK_NWRSTIEN2_
#IFDEF _NWRSTIEN2_
NWRSTIEN2_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRSTIEN2_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRSTIEN2_NWCell = NWRSTIEN2_NWCellIn AND NWRSTIEN2_NWCellOut
NWRSTIEN2_NWMarker = NWi AND RRuleRecommended
NWRSTIEN2_NW = ((( NWRSTIEN2_NWCell OR NWRSTIEN2_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWRSTI.EN.2 { @ OD enclosure of CO in NWEL resistor under STI for SPICE simulation accuracy == ^NWRSTI_EN_2_R um
  A = OD INSIDE EDGE ( NWRES_STI AND NWRSTIEN2_NW )
  B = EXPAND EDGE A INSIDE BY NWRSTI_EN_2_R
  B NOT INTERACT COWR_STI
}
// NWRSTI.EN.2.R is checked by NWRSTI.EN.2 and RR:RE:P:NWRSTI.EN.2
#ENDIF // _NWRSTIEN2_
#ENDIF // CHECK_NWRSTIEN2_


#IFDEF CHECK_POS4_1_
#IFDEF _POS4_1_
// PO.S.4.1.R is checked by RR:RE:P:PO.S.4.1
POS4_1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS4_1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS4_1_ODCell = POS4_1_ODCellIn AND POS4_1_ODCellOut
POS4_1_ODMarker = ODi AND RRuleRecommended
POS4_1_OD = ((( POS4_1_ODCell OR POS4_1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS4_1_GATE  = POLY AND POS4_1_OD
RR:RE:P:PO.S.4.1 { @ Recommended gate space when the area enclosed by L-shape OD and L-shape PO < ^PO_S_4_1_A_R for PO/OD rounding effect >= ^PO_S_4_1_R
  ((EXT POS4_1_GATE < PO_S_4_1_R ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1) INTERACT POi == 1
}
#ENDIF // _POS4_1_
#ENDIF // CHECK_POS4_1_
#IFDEF CHECK_SRDPOS1_
#IFDEF _SRDPOS1_
SRDPOS1_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOS1_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOS1_SRDPOCell = SRDPOS1_SRDPOCellIn AND SRDPOS1_SRDPOCellOut
SRDPOS1_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOS1_SRDPO = ((( SRDPOS1_SRDPOCell OR SRDPOS1_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

SRDPOS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
SRDPOS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
SRDPOS1_POCell = SRDPOS1_POCellIn AND SRDPOS1_POCellOut
SRDPOS1_POMarker = POi AND RRuleRecommended
SRDPOS1_PO = ((( SRDPOS1_POCell OR SRDPOS1_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:SR_DPO.S.1 { @ Recommended space to {PO OR SR_DPO} (SR_DPO overlap with PO is not allowed) >= 0.12 
  SRDPOS1_POdx = SRDPOS1_PO OR SRDPOS1_SRDPO
  EXT SRDPOS1_SRDPO SRDPOS1_POdx < SRDPO_S_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _SRDPOS1_
#ENDIF // CHECK_SRDPOS1_


#IFDEF CHECK_POEX1_
#IFDEF _POEX1_
POEX1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POEX1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POEX1_ODCell = POEX1_ODCellIn AND POEX1_ODCellOut
POEX1_ODMarker = ODi AND RRuleRecommended
POEX1_OD = ((( POEX1_ODCell OR POEX1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:PO.EX.1 { @ Recommended PO extension on OD (end-cap) >= ^PO_EX_1_R um
  (ENC POEX1_OD POLY < PO_EX_1_R ABUT < 90 OPPOSITE SINGULAR REGION) NOT INSIDE ((LOGO OR TCDDMY) OR SRAM_REGION)
}
#ENDIF // _POEX1_
#ENDIF // CHECK_POEX1_

#IFNDEF GS
#IFDEF CHECK_POS2_
#IFDEF _POS2_
// PO.S.2.LP.R is checked by RR:RE:SP:PO.S.2
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRecommended
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
POS2_GATE  = POLY AND POS2_OD
RR:RE:SP:PO.S.2 { @ Recommended gate space in the same OD >= ^PO_S_2_R um
  (EXT POS2_GATE_W < PO_S_2_R ABUT < 90 REGION) NOT INSIDE SRAM_REGION
  ((EXT POS2_GATE < PO_S_2_R ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1) NOT INSIDE SRAM_REGION
}
#ENDIF // _POS2_
#ENDIF // CHECK_POS2_
#ENDIF // GS
// CO.EN.0.R is checked by RR:RE:SP:CO.EN.1 and RR:RE:SP:CO.EN.1.1
#IFDEF CHECK_COEN1_
#IFDEF _COEN1_
COEN1_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN1_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN1_COCell = COEN1_COCellIn AND COEN1_COCellOut
COEN1_COMarker = COi AND RRuleRecommended
COEN1_CO = ((( COEN1_COCell OR COEN1_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:CO.EN.1 { @ Recommended enclosure by OD >= ^CO_EN_1_R um
  (ENC COEN1_CO OD < CO_EN_1_R ABUT < 90 REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _COEN1_
#ENDIF // CHECK_COEN1_

#IFDEF CHECK_COEN11_
#IFDEF _COEN11_
COEN11_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN11_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN11_COCell = COEN11_COCellIn AND COEN11_COCellOut
COEN11_COMarker = COi AND RRuleRecommended
COEN11_CO = ((( COEN11_COCell OR COEN11_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:CO.EN.1.1 { @ Recommended enclosure by OD [at least two opposite sides] >= ^CO_EN_1_1_R um
  X = RECTANGLE ENCLOSURE COEN11_CO OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_1_R OPPOSITE CO_EN_1 CO_EN_1_1_R OPPOSITE
  Y = ENC [X] OD < CO_EN_1_1_R ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  (INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION) NOT INSIDE SRAM_REGION   // adjacent narrow sides
}
#ENDIF // _COEN11_
#ENDIF // CHECK_COEN11_

#IFDEF CHECK_COEN3_
#IFDEF _COEN3_
COEN3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN3_COCell = COEN3_COCellIn AND COEN3_COCellOut
COEN3_COMarker = COi AND RRuleRecommended
COEN3_CO = ((( COEN3_COCell OR COEN3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:CO.EN.3 { @ Recommended enclosure by PO [at least two opposite sides] >= ^CO_EN_3_R um
  X = RECTANGLE ENCLOSURE COEN3_CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 CO_EN_3_R OPPOSITE CO_EN_2 CO_EN_3_R OPPOSITE
  Y = ENC [X] POLY < CO_EN_3_R ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  (INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION) NOT INSIDE SRAM_REGION   // adjacent narrow sides
}
#ENDIF // _COEN3_
#ENDIF // CHECK_COEN3_



#IFDEF CHECK_COS3_
#IFDEF _COS3_
COS3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COS3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COS3_COCell = COS3_COCellIn AND COS3_COCellOut
COS3_COMarker = COi AND RRuleRecommended
COS3_CO = ((( COS3_COCell OR COS3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SD:CO.S.3 { @ Recommended space to gate to reduce the short possibility caused by particle >= ^CO_S_3_R
  (EXT (COS3_CO AND ODi) GATE < CO_S_3_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _COS3_
#ENDIF // CHECK_COS3_



#IFDEF CHECK_M1EN1_M1EN2_
#IFDEF _M1EN1_M1EN2_
// M1.EN.0.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
// M1.EN.1.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
// M1.EN.2.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
M1EN1_M1EN2_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN1_M1EN2_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN1_M1EN2_COCell = M1EN1_M1EN2_COCellIn AND M1EN1_M1EN2_COCellOut
M1EN1_M1EN2_COMarker = COi AND RRuleRecommended
M1EN1_M1EN2_CO = ((( M1EN1_M1EN2_COCell OR M1EN1_M1EN2_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:FP:M1.EN.1__M1.EN.2 { @ Enclosure of CO at least two opposite sides ^M1_EN_2_R um/Enclosure of CO ^M1_EN_1_R um
  A = RECTANGLE ENCLOSURE M1EN1_M1EN2_CO M1s ABUT > 0 < 90 GOOD 0 M1_EN_2_R OPPOSITE 0 M1_EN_2_R OPPOSITE
  (ENC A M1s < M1_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE (SRAM_EXCLUDE OR SRAM_REGION)
}
#ENDIF // _M1EN1_M1EN2_
#ENDIF // CHECK_M1EN1_M1EN2_


#IFDEF CHECK_VIA1EN1_VIA1EN2_
#IFDEF _VIA1EN1_VIA1EN2_
// VIA1.EN.0.R is checked by RR:RE:FP:VIA1.EN.1__VIA1.EN.2
// VIA1.EN.1.R is checked by RR:RE:FP:VIA1.EN.1__VIA1.EN.2
// VIA1.EN.2.R is checked by RR:RE:FP:VIA1.EN.1__VIA1.EN.2
VIA1EN1_VIA1EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIA1EN1_VIA1EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIA1EN1_VIA1EN2_VIA1Cell = VIA1EN1_VIA1EN2_VIA1CellIn AND VIA1EN1_VIA1EN2_VIA1CellOut
VIA1EN1_VIA1EN2_VIA1Marker = VIA1i AND RRuleRecommended
VIA1EN1_VIA1EN2_VIA1 = ((( VIA1EN1_VIA1EN2_VIA1Cell OR VIA1EN1_VIA1EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA1.EN.1__VIA1.EN.2 { @ Enclosure of VIA1 at least two opposite sides ^VIA1_EN_2_R um/Enclosure of VIA1 ^VIA1_EN_1_R um
  A = RECTANGLE ENCLOSURE VIA1EN1_VIA1EN2_VIA1 M1 ABUT < 90 SINGULAR GOOD 0 VIA1_EN_2_R OPPOSITE 0 VIA1_EN_2_R OPPOSITE
  (ENC A M1 < VIA1_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _VIA1EN1_VIA1EN2_
#ENDIF // CHECK_VIA1EN1_VIA1EN2_

#IFDEF CHECK_M2EN1_M2EN2_
#IFDEF _M2EN1_M2EN2_
// M2.EN.0.R is checked by RR:RE:FP:M2.EN.1__M2.EN.2
// M2.EN.1.R is checked by RR:RE:FP:M2.EN.1__M2.EN.2
// M2.EN.2.R is checked by RR:RE:FP:M2.EN.1__M2.EN.2
M2EN1_M2EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
M2EN1_M2EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
M2EN1_M2EN2_VIA1Cell = M2EN1_M2EN2_VIA1CellIn AND M2EN1_M2EN2_VIA1CellOut
M2EN1_M2EN2_VIA1Marker = VIA1i AND RRuleRecommended
M2EN1_M2EN2_VIA1 = ((( M2EN1_M2EN2_VIA1Cell OR M2EN1_M2EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M2.EN.1__M2.EN.2 { @ Enclosure of VIA1 at least two opposite sides ^M2_EN_2_R um/Enclosure of VIA1 ^M2_EN_1_R um
  A = RECTANGLE ENCLOSURE M2EN1_M2EN2_VIA1 M2 ABUT < 90 SINGULAR GOOD 0 M2_EN_2_R OPPOSITE 0 M2_EN_2_R OPPOSITE
  (ENC A M2 < M2_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _M2EN1_M2EN2_
#ENDIF // CHECK_M2EN1_M2EN2_


#IFDEF CHECK_VIA2EN1_VIA2EN2_
#IFDEF _VIA2EN1_VIA2EN2_
// VIA2.EN.0.R is checked by RR:RE:FP:VIA2.EN.1__VIA2.EN.2
// VIA2.EN.1.R is checked by RR:RE:FP:VIA2.EN.1__VIA2.EN.2
// VIA2.EN.2.R is checked by RR:RE:FP:VIA2.EN.1__VIA2.EN.2
VIA2EN1_VIA2EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
VIA2EN1_VIA2EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
VIA2EN1_VIA2EN2_VIA2Cell = VIA2EN1_VIA2EN2_VIA2CellIn AND VIA2EN1_VIA2EN2_VIA2CellOut
VIA2EN1_VIA2EN2_VIA2Marker = VIA2i AND RRuleRecommended
VIA2EN1_VIA2EN2_VIA2 = ((( VIA2EN1_VIA2EN2_VIA2Cell OR VIA2EN1_VIA2EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA2.EN.1__VIA2.EN.2 { @ Enclosure of VIA2 at least two opposite sides ^VIA2_EN_2_R um/Enclosure of VIA2 ^VIA2_EN_1_R um
  A = RECTANGLE ENCLOSURE VIA2EN1_VIA2EN2_VIA2 M2 ABUT < 90 SINGULAR GOOD 0 VIA2_EN_2_R OPPOSITE 0 VIA2_EN_2_R OPPOSITE
  (ENC A M2 < VIA2_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _VIA2EN1_VIA2EN2_
#ENDIF // CHECK_VIA2EN1_VIA2EN2_

#IFDEF CHECK_M3EN1_M3EN2_
#IFDEF _M3EN1_M3EN2_
// M3.EN.0.R is checked by RR:RE:FP:M3.EN.1__M3.EN.2
// M3.EN.1.R is checked by RR:RE:FP:M3.EN.1__M3.EN.2
// M3.EN.2.R is checked by RR:RE:FP:M3.EN.1__M3.EN.2
M3EN1_M3EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
M3EN1_M3EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
M3EN1_M3EN2_VIA2Cell = M3EN1_M3EN2_VIA2CellIn AND M3EN1_M3EN2_VIA2CellOut
M3EN1_M3EN2_VIA2Marker = VIA2i AND RRuleRecommended
M3EN1_M3EN2_VIA2 = ((( M3EN1_M3EN2_VIA2Cell OR M3EN1_M3EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M3.EN.1__M3.EN.2 { @ Enclosure of VIA2 at least two opposite sides ^M3_EN_2_R um/Enclosure of VIA2 ^M3_EN_1_R um
  A = RECTANGLE ENCLOSURE M3EN1_M3EN2_VIA2 M3 ABUT < 90 SINGULAR GOOD 0 M3_EN_2_R OPPOSITE 0 M3_EN_2_R OPPOSITE
  (ENC A M3 < M3_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
#ENDIF // _M3EN1_M3EN2_
#ENDIF // CHECK_M3EN1_M3EN2_


#IFDEF CHECK_VIA3EN1_VIA3EN2_
#IFDEF _VIA3EN1_VIA3EN2_
// VIA3.EN.0.R is checked by RR:RE:FP:VIA3.EN.1__VIA3.EN.2
// VIA3.EN.1.R is checked by RR:RE:FP:VIA3.EN.1__VIA3.EN.2
// VIA3.EN.2.R is checked by RR:RE:FP:VIA3.EN.1__VIA3.EN.2
VIA3EN1_VIA3EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
VIA3EN1_VIA3EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
VIA3EN1_VIA3EN2_VIA3Cell = VIA3EN1_VIA3EN2_VIA3CellIn AND VIA3EN1_VIA3EN2_VIA3CellOut
VIA3EN1_VIA3EN2_VIA3Marker = VIA3i AND RRuleRecommended
VIA3EN1_VIA3EN2_VIA3 = ((VIA3EN1_VIA3EN2_VIA3Cell OR VIA3EN1_VIA3EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA3.EN.1__VIA3.EN.2 { @ Enclosure of VIA3 at least two opposite sides ^VIA3_EN_2_R um/Enclosure of VIA3 ^VIA3_EN_1_R um
  A = RECTANGLE ENCLOSURE VIA3EN1_VIA3EN2_VIA3 M3 ABUT < 90 SINGULAR GOOD 0 VIA3_EN_2_R OPPOSITE 0 VIA3_EN_2_R OPPOSITE
  ENC A M3 < VIA3_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _VIA3EN1_VIA3EN2_
#ENDIF // CHECK_VIA3EN1_VIA3EN2_

#IFDEF CHECK_M4EN1_M4EN2_
#IFDEF _M4EN1_M4EN2_
// M4.EN.0.R is checked by RR:RE:FP:M4.EN.1__M4.EN.2
// M4.EN.1.R is checked by RR:RE:FP:M4.EN.1__M4.EN.2
// M4.EN.2.R is checked by RR:RE:FP:M4.EN.1__M4.EN.2
M4EN1_M4EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
M4EN1_M4EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
M4EN1_M4EN2_VIA3Cell = M4EN1_M4EN2_VIA3CellIn AND M4EN1_M4EN2_VIA3CellOut
M4EN1_M4EN2_VIA3Marker = VIA3i AND RRuleRecommended
M4EN1_M4EN2_VIA3 = ((M4EN1_M4EN2_VIA3Cell OR M4EN1_M4EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M4.EN.1__M4.EN.2 { @ Enclosure of VIA3 at least two opposite sides ^M4_EN_2_R um/Enclosure of VIA3 ^M4_EN_1_R um
  A = RECTANGLE ENCLOSURE M4EN1_M4EN2_VIA3 M4 ABUT < 90 SINGULAR GOOD 0 M4_EN_2_R OPPOSITE 0 M4_EN_2_R OPPOSITE
  ENC A M4 < M4_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _M4EN1_M4EN2_
#ENDIF // CHECK_M4EN1_M4EN2_


#IFDEF CHECK_VIA4EN1_VIA4EN2_
#IFDEF _VIA4EN1_VIA4EN2_
// VIA4.EN.0.R is checked by RR:RE:FP:VIA4.EN.1__VIA4.EN.2
// VIA4.EN.1.R is checked by RR:RE:FP:VIA4.EN.1__VIA4.EN.2
// VIA4.EN.2.R is checked by RR:RE:FP:VIA4.EN.1__VIA4.EN.2
VIA4EN1_VIA4EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
VIA4EN1_VIA4EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
VIA4EN1_VIA4EN2_VIA4Cell = VIA4EN1_VIA4EN2_VIA4CellIn AND VIA4EN1_VIA4EN2_VIA4CellOut
VIA4EN1_VIA4EN2_VIA4Marker = VIA4i AND RRuleRecommended
VIA4EN1_VIA4EN2_VIA4 = ((VIA4EN1_VIA4EN2_VIA4Cell OR VIA4EN1_VIA4EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA4.EN.1__VIA4.EN.2 { @ Enclosure of VIA4 at least two opposite sides ^VIA4_EN_2_R um/Enclosure of VIA4 ^VIA4_EN_1_R um
  A = RECTANGLE ENCLOSURE VIA4EN1_VIA4EN2_VIA4 M4 ABUT < 90 SINGULAR GOOD 0 VIA4_EN_2_R OPPOSITE 0 VIA4_EN_2_R OPPOSITE
  ENC A M4 < VIA4_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _VIA4EN1_VIA4EN2_
#ENDIF // CHECK_VIA4EN1_VIA4EN2_

#IFDEF CHECK_M5EN1_M5EN2_
#IFDEF _M5EN1_M5EN2_
// M5.EN.0.R is checked by RR:RE:FP:M5.EN.1__M5.EN.2
// M5.EN.1.R is checked by RR:RE:FP:M5.EN.1__M5.EN.2
// M5.EN.2.R is checked by RR:RE:FP:M5.EN.1__M5.EN.2
M5EN1_M5EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
M5EN1_M5EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
M5EN1_M5EN2_VIA4Cell = M5EN1_M5EN2_VIA4CellIn AND M5EN1_M5EN2_VIA4CellOut
M5EN1_M5EN2_VIA4Marker = VIA4i AND RRuleRecommended
M5EN1_M5EN2_VIA4 = ((M5EN1_M5EN2_VIA4Cell OR M5EN1_M5EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M5.EN.1__M5.EN.2 { @ Enclosure of VIA4 at least two opposite sides ^M5_EN_2_R um/Enclosure of VIA4 ^M5_EN_1_R um
  A = RECTANGLE ENCLOSURE M5EN1_M5EN2_VIA4 M5 ABUT < 90 SINGULAR GOOD 0 M5_EN_2_R OPPOSITE 0 M5_EN_2_R OPPOSITE
  ENC A M5 < M5_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF // _M5EN1_M5EN2_
#ENDIF // CHECK_M5EN1_M5EN2_


#IFDEF CHECK_MOMDN1_M1_
#IFDEF _MOMDN1_M1_
RR:RE:SP:MOM.DN.1:M1 { @ Recommend metal density inside {MOMDMY_n SIZING 10 um}. (For M1/Mx layers) >= 30% 
  X = SIZE MOMDMY_1 BY 10
  Y = DENSITY M1x CHIP < MOM_DN_1_R INSIDE OF LAYER X [ AREA(M1x)/AREA(CHIP) ] PRINT MOM.DN.1.M1.density
  Y NOT excludeRRuleRecommended
}
#ENDIF // _MOMDN1_M1_
#ENDIF // CHECK_MOMDN1_M1_

#IFDEF CHECK_MOMDN1_M2_
#IFDEF _MOMDN1_M2_
RR:RE:SP:MOM.DN.1:M2 { @ Recommend metal density inside {MOMDMY_n SIZING 10 um}. (For M1/Mx layers) >= 30% 
  X = SIZE MOMDMY_2 BY 10
  Y = DENSITY M2x CHIP < MOM_DN_1_R INSIDE OF LAYER X [ AREA(M2x)/AREA(CHIP) ] PRINT MOM.DN.1.M2.density
  Y NOT excludeRRuleRecommended
}
#ENDIF // _MOMDN1_M2_
#ENDIF // CHECK_MOMDN1_M2_

#IFDEF CHECK_MOMDN1_M3_
#IFDEF _MOMDN1_M3_
RR:RE:SP:MOM.DN.1:M3 { @ Recommend metal density inside {MOMDMY_n SIZING 10 um}. (For M1/Mx layers) >= 30% 
  X = SIZE MOMDMY_3 BY 10
  Y = DENSITY M3x CHIP < MOM_DN_1_R INSIDE OF LAYER X [ AREA(M3x)/AREA(CHIP) ] PRINT MOM.DN.1.M3.density
  Y NOT excludeRRuleRecommended
}
#ENDIF // _MOMDN1_M3_
#ENDIF // CHECK_MOMDN1_M3_

#IFDEF CHECK_MOMDN1_M4_
#IFDEF _MOMDN1_M4_
RR:RE:SP:MOM.DN.1:M4 { @ Recommend metal density inside {MOMDMY_n SIZING 10 um}. (For M1/Mx layers) >= 30% 
  X = SIZE MOMDMY_4 BY 10
  Y = DENSITY M4x CHIP < MOM_DN_1_R INSIDE OF LAYER X [ AREA(M4x)/AREA(CHIP) ] PRINT MOM.DN.1.M4.density
  Y NOT excludeRRuleRecommended
}
#ENDIF // _MOMDN1_M4_
#ENDIF // CHECK_MOMDN1_M4_

#IFDEF CHECK_MOMDN1_M5_
#IFDEF _MOMDN1_M5_
RR:RE:SP:MOM.DN.1:M5 { @ Recommend metal density inside {MOMDMY_n SIZING 10 um}. (For M1/Mx layers) >= 30% 
  X = SIZE MOMDMY_5 BY 10
  Y = DENSITY M5x CHIP < MOM_DN_1_R INSIDE OF LAYER X [ AREA(M5x)/AREA(CHIP) ] PRINT MOM.DN.1.M5.density
  Y NOT excludeRRuleRecommended
}
#ENDIF // _MOMDN1_M5_
#ENDIF // CHECK_MOMDN1_M5_

#IFDEF CHECK_INDDN8_
#IFDEF _INDDN8_
RR:RE:SP:IND.DN.8 { @ Recommend {(OD OR DOD) OR SR_DOD} density inside INDDMY >= 20% 
  DENSITY ALL_OD CHIP < IND_DN_8_R INSIDE OF LAYER INDDMY_ALL [ AREA(ALL_OD)/AREA(CHIP) ] PRINT IND.DN.8.density
}
//IND_MD.DN.8.R is checked by RR:RE:SP:IND.DN.8
#ENDIF // _INDDN8_
#ENDIF // CHECK_INDDN8_

#IFDEF CHECK_INDDN9_
#IFDEF _INDDN9_
RR:RE:SP:IND.DN.9 { @ Recommend {(PO OR DPO) OR SR_DPO} density inside INDDMY >= 15% 
  DENSITY ALL_POLY CHIP < IND_DN_9_R INSIDE OF LAYER INDDMY_ALL [ AREA(ALL_POLY)/AREA(CHIP) ] PRINT IND.DN.9.density
}
//IND_MD.DN.9.R is checked by RR:RE:SP:IND.DN.9
#ENDIF // _INDDN9_
#ENDIF // CHECK_INDDN9_

#IFDEF FULL_CHIP
#IFDEF CHECK_DTCDDN1_
#IFDEF _DTCDDN1_
RR:RE:DTCD.DN.1 { @ Density of Dummy TCD (2mmx2mm is one unit) >= 70 %
  ALL_WIN = DENSITY CHIP == DTCD_DN_1_WR*DTCD_DN_1_WR WINDOW DTCD_DN_1_WR STEP DTCD_DN_1_WR INSIDE OF LAYER CHIPx [AREA(CHIP)]
  BAD_WIN = DENSITY TCDDMY == 0 WINDOW DTCD_DN_1_WR STEP DTCD_DN_1_WR INSIDE OF LAYER ALL_WIN PRINT DTCD.DN.1.NO_TCDDMY
  GOOD_WIN = ALL_WIN NOT BAD_WIN
  ERR = DENSITY GOOD_WIN INSIDE OF LAYER ALL_WIN < DTCD_DN_1_R PRINT DTCD.DN.1.density
  ERR AND BAD_WIN
}
#ENDIF // _DTCDDN1_
#ENDIF // CHECK_DTCDDN1_
#ENDIF // FULL_CHIP




#ENDIF // End of Recommended

#IFDEF Analog

#IFDEF CHECK_POS14m_
#IFDEF _POS14m_
// PO.S.14.GSm.R is checked by RR:AN:PO.S.14m
// PO.S.14.LPm.R is checked by RR:AN:PO.S.14m
POS14m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS14m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS14m_POCell = POS14m_POCellIn AND POS14m_POCellOut
POS14m_POMarker = POi AND RRuleAnalog
POS14m_PO = ((( POS14m_POCell OR POS14m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS14m_GATE = ( GATE_NP AND POS14m_PO ) NOT OD2
POS14m_NW = OD2 OR (NWEL OR NTN)
RR:AN:PO.S.14m { @ Gate space to ( OD2 OR (NW OR NT_N) ) in Core NMOS >= ^PO_S_14_MR um
  EXT POS14m_GATE POS14m_NW < PO_S_14_MR ABUT < 90 SINGULAR REGION
}
#ENDIF // _POS14m_
#ENDIF // CHECK_POS14m_

#IFDEF CHECK_POEN1m_
#IFDEF _POEN1m_
// PO.EN.1.GSm.R is checked by RR:AN:PO.EN.1m
// PO.EN.1.LPm.R is checked by RR:AN:PO.EN.1m
POEN1m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN1m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN1m_POCell = POEN1m_POCellIn AND POEN1m_POCellOut
POEN1m_POMarker = POi AND RRuleAnalog
POEN1m_PO = ((( POEN1m_POCell OR POEN1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN1m_GATE = ( GATE_PP AND POEN1m_PO ) NOT OD2
#IFDEF GS
POEN1m_NW = (NWEL NOT OD2) NOT NTN
RR:AN:PO.EN.1m { @ Gate enclosure by ( (NW NOT OD2) NOT NT_N) in Core PMOS >= ^PO_EN_1_MR um
  ENC POEN1m_GATE POEN1m_NW < PO_EN_1_MR ABUT < 90 SINGULAR REGION
}
#ELSE
POEN1m_NW = NWEL NOT NTN
RR:AN:PO.EN.1m { @ Gate enclosure by (NW NOT NT_N) in Core PMOS >= ^PO_EN_1_MR um
  ENC POEN1m_GATE POEN1m_NW < PO_EN_1_MR ABUT < 90 SINGULAR REGION
}
#ENDIF // GS
#ENDIF // _POEN1m_
#ENDIF // CHECK_POEN1m_

#IFDEF CHECK_POEN2m_
#IFDEF _POEN2m_
// PO.EN.2.GSm.R is checked by RR:AN:PO.EN.2m
// PO.EN.2.LPm.R is checked by RR:AN:PO.EN.2m
POEN2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN2m_POCell = POEN2m_POCellIn AND POEN2m_POCellOut
POEN2m_POMarker = POi AND RRuleAnalog
POEN2m_PO = ((( POEN2m_POCell OR POEN2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN2m_GATE = ( GATE_NP AND POEN2m_PO ) AND OD2
POEN2m_NW = OD2 NOT ( NWEL OR NTN)
RR:AN:PO.EN.2m { @ Gate enclosure by ( OD2 NOT (NW OR NT_N) ) in IO NMOS >= ^PO_EN_2_MR um
  ENC POEN2m_GATE POEN2m_NW < PO_EN_2_MR ABUT < 90 SINGULAR REGION
}
#ENDIF // _POEN2m_
#ENDIF // CHECK_POEN2m_

#IFDEF CHECK_POEN3m_
#IFDEF _POEN3m_
// PO.EN.3.GSm.R is checked by RR:AN:PO.EN.3m
// PO.EN.3.LPm.R is checked by RR:AN:PO.EN.3m
POEN3m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN3m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN3m_POCell = POEN3m_POCellIn AND POEN3m_POCellOut
POEN3m_POMarker = POi AND RRuleAnalog
POEN3m_PO = ((( POEN3m_POCell OR POEN3m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN3m_GATE = ( GATE_PP AND POEN3m_PO ) AND OD2
#IFDEF GS
POEN3m_NW = (NWEL AND OD2) NOT NTN
RR:AN:PO.EN.3m { @ Gate enclosure by (( NW AND OD2) NOT NT_N) in IO PMOS >= ^PO_EN_3_MR um
  ENC POEN3m_GATE POEN3m_NW < PO_EN_3_MR ABUT < 90 SINGULAR REGION
}
#ELSE
POEN3m_NW = NWEL NOT NTN
RR:AN:PO.EN.3m { @ Gate enclosure by (NW NOT NT_N) in IO PMOS >= ^PO_EN_3_MR um
  ENC POEN3m_GATE POEN3m_NW < PO_EN_3_MR ABUT < 90 SINGULAR REGION
}
#ENDIF // GS
#ENDIF // _POEN3m_
#ENDIF // CHECK_POEN3m_

#IFDEF CHECK_POS5m_
#IFDEF _POS5m_
POS5m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS5m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS5m_POCell = POS5m_POCellIn AND POS5m_POCellOut
POS5m_POMarker = POi AND RRuleAnalog
POS5m_PO = ((( POS5m_POCell OR POS5m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS5m_GateW = GATE_W COIN INSIDE EDGE POS5m_PO
POS5m_GateWExp = EXPAND EDGE POS5m_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5m_GateWExe = POS5m_PO COIN INSIDE EDGE POS5m_GateWExp
RR:AN:PO.S.5m { @ Recommended PO space to L-shape OD when PO and OD are in the same MOS >= ^PO_S_5_MR um
  EXT POS5m_GateWExe ODi < PO_S_5_MR ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS5m_
#ENDIF // CHECK_POS5m_

#IFDEF CHECK_POS6m_
#IFDEF _POS6m_
POS6m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POS6m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POS6m_ODCell = POS6m_ODCellIn AND POS6m_ODCellOut
POS6m_ODMarker = ODi AND RRuleAnalog
POS6m_OD = ((( POS6m_ODCell OR POS6m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS6m_GateL = GATE_L COIN INSIDE EDGE POS6m_OD
POS6m_GateLExp = EXPAND EDGE POS6m_GateL INSIDE BY GRID EXTEND BY PO_S_1
POS6m_GateLExe = (POS6m_OD COIN INSIDE EDGE POS6m_GateLExp) TOUCH INSIDE EDGE POS6m_GateL
RR:AN:PO.S.6m { @ Recommended L-shape PO space to OD when PO and OD are in the same MOS >= 0.1 
  EXT POS6m_GateLExe POi < PO_S_6_MR ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS6m_
#ENDIF // CHECK_POS6m_

#IFDEF CHECK_POS61m_
#IFDEF _POS61m_
POS61m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POS61m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POS61m_ODCell = POS61m_ODCellIn AND POS61m_ODCellOut
POS61m_ODMarker = ODi AND RRuleAnalog
POS61m_OD = ((( POS61m_ODCell OR POS61m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:PO.S.6.1m { @ Recommended L-shape PO space to OD when PO and OD are in the same MOS [channel width < 0.3 um and L-shape PO length > 0.1 um (L)] (Figure XXX) >= 0.18 
  POS61m_Gate = (GATE AND POS61m_OD) WITH EDGE (LENGTH GATE_W < PO_S_6_1_W_MR)
  POS61m_GateL = GATE_L COIN INSIDE EDGE POS61m_Gate
  POS61m_GateL1 =  EXPAND EDGE POS61m_GateL INSIDE BY GRID EXTEND BY PO_S_6_1_L_MR+GRID
  POS61m_GateL2 =  EXPAND EDGE POS61m_GateL INSIDE BY GRID EXTEND BY PO_S_6_1_L_MR
  L_GATE_L = POS61m_GateL1 NOT POS61m_GateL2
  L_GATE_L1E = (POS61m_GateL1 TOUCH EDGE GATE_L) TOUCH EDGE OD
  L_GATE_LE = L_GATE_L COIN EDGE L_GATE_L1E
  B = EXT L_GATE_LE [FPO1] <= PO_S_6_1_MR ABUT < 90 OPPOSITE
  EXT B OD < PO_S_6_1_MR ABUT < 90 OPPOSITE REGION
  U_PO = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH > PO_S_6_1_L_MR <= PO_S_6_1_L_MR*2
  X = EXT U_PO POS61m_OD < PO_S_6_1_MR OPPOSITE REGION
  ((SIZE X BY 0.001) INTERACT GATE == 2) INTERACT POS61m_Gate
}
#ENDIF // _POS61m_
#ENDIF // CHECK_POS61m_

#IFDEF CHECK_POEX1m_
#IFDEF _POEX1m_
POEX1m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POEX1m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POEX1m_ODCell = POEX1m_ODCellIn AND POEX1m_ODCellOut
POEX1m_ODMarker = ODi AND RRuleAnalog
POEX1m_OD = ((( POEX1m_ODCell OR POEX1m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:PO.EX.1m { @ Recommended PO extension on OD (end-cap) >= ^PO_EX_1_MR um
  (ENC POEX1m_OD POLY < PO_EX_1_MR ABUT > 0 < 90 OPPOSITE SINGULAR REGION) NOT INSIDE LOGO
}
#ENDIF // _POEX1m_
#ENDIF // CHECK_POEX1m_


#IFDEF CHECK_BJTR2_
#IFDEF _BJTR2_
// BJT.R.2.R is checked by RR:AN:BJT.R.2
RR:AN:BJT.R.2 { @ OD( Emitter size ) is ^BJT_R_2_S_R x ^BJT_R_2_S_R, ^BJT_R_2_M_R x ^BJT_R_2_M_R, ^BJT_R_2_B_R x ^BJT_R_2_B_R
  X = NOT RECTANGLE EMOD == BJT_R_2_S_R BY == BJT_R_2_S_R
  Y = NOT RECTANGLE X == BJT_R_2_M_R BY == BJT_R_2_M_R
  (NOT RECTANGLE Y == BJT_R_2_B_R BY == BJT_R_2_B_R) NOT INSIDE excludeRRuleAnalog
}
#ENDIF // _BJTR2_
#ENDIF // CHECK_BJTR2_


#IFDEF CHECK_BJTR7_
#IFDEF _BJTR7_
// BJT.R.7.R is checked by RR:AN:BJT.R.7
RR:AN:BJT.R.7 { @ BJTDMY overlap of NT_N, PO, VTH_N, VTH_P, VTL_N, VTL_P, VAR and SRM is not recommended
  (BJTDMY AND NTN ) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND POLY) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTHN) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTHP) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTLN) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTLP) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VAR ) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND SRM ) NOT INSIDE excludeRRuleAnalog
}
#ENDIF // _BJTR7_
#ENDIF // CHECK_BJTR7_
// AN.R.86mgU is uncheckable.
// AN.R.50mgU is uncheckable.
// FPAD.R.1m.RU is uncheckable.
#IFDEF _ANR17_
// AN.R.17mg is checked by RR:AN:AN.R.17mg
ANR17mg_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
ANR17mg_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
ANR17mg_POCell = ANR17mg_POCellIn AND ANR17mg_POCellOut
ANR17mg_POMarker = POi AND RRuleAnalog
ANR17mg_PO = ((( ANR17mg_POCell OR ANR17mg_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

ANR17mg_PORES = ANR17mg_PO AND PO_RES_RPO
RR:AN:AN.R.17mg { @ Place unsilicided PO resistor or MOM (without ground shielding) on an N-well for better noise immunity. A P+ PO resistor is recommended for overall performance   
  ANR17mg_PORES NOT NWEL
  ANR17mg_PORES NOT PP
}
#ENDIF // _ANR17_

#IFDEF _ANR20_
// AN.R.20mg is checked by RR:AN:AN.R.20mg
ANR20mg_VARCellIn = INSIDE CELL VARi CellsForRRuleAnalog  
ANR20mg_VARCellOut = NOT INSIDE CELL VARi ExclCellsForRRuleAnalog 
ANR20mg_VARCell = ANR20mg_VARCellIn AND ANR20mg_VARCellOut
ANR20mg_VARMarker = VARi AND RRuleAnalog
ANR20mg_VAR = ((ANR20mg_VARCell OR ANR20mg_VARMarker) NOT Block ) NOT excludeRRuleAnalog

ANR20mg_VAROD = ANR20mg_VAR AND OD
RR:AN:AN.R.20mg { @ Use OD2 MOS varactor is recommended.
  ANR20mg_VAROD NOT OD2
}
#ENDIF // _ANR20_


#ENDIF // Analog

#IFDEF Guideline

#IFDEF CHECK_NWR1_
#IFDEF _NWR1_
// NW.R.1g is checked by RR:GL:NW.R.1
NWR1_NWCellIn = INSIDE CELL NWi CellsForRRuleGuideline  
NWR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleGuideline 
NWR1_NWCell = NWR1_NWCellIn AND NWR1_NWCellOut
NWR1_NWMarker = NWi AND RRuleGuideline
NWR1_NW = ((( NWR1_NWCell OR NWR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:NW.R.1 { @ Recommend not using unintentional floating well to avoid unstable device performance. DRC flags {NW OUTSIDE {N+OD INTERACT CO}}   
  (((NWi OUTSIDE (NPODi INTERACT COi)) NOT (LOGO OR TCDDMY)) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW
}
#ENDIF // _NWR1_
#ENDIF // CHECK_NWR1_

#IFDEF CHECK_DNWR6_
#IFDEF _DNWR6_
// DNW.R.6gU is checked by RR:GL:DNW.R.6
DNWR6_DNWCellIn = INSIDE CELL DNWi CellsForRRuleGuideline  
DNWR6_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleGuideline 
DNWR6_DNWCell = DNWR6_DNWCellIn AND DNWR6_DNWCellOut
DNWR6_DNWMarker = DNWi AND RRuleGuideline
DNWR6_DNW = ((( DNWR6_DNWCell OR DNWR6_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:DNW.R.6 { @ Recommended not to use floating RW
  ((RWi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT DNWR6_DNW
}
#ENDIF // _DNWR6_
#ENDIF // CHECK_DNWR6_

#IFDEF CHECK_NWRODR3_NWRSTIR3_
#IFDEF _NWRODR3_NWRSTIR3_
// NWROD.R.3g is checked by RR:GL:NWROD.R.3__NWRSTI.R.3
// NWRSTI.R.3g is checked by RR:GL:NWROD.R.3__NWRSTI.R.3
NWRODR3_NWDMYCellIn = INSIDE CELL NWDMY CellsForRRuleGuideline  
NWRODR3_NWDMYCellOut = NOT INSIDE CELL NWDMY ExclCellsForRRuleGuideline 
NWRODR3_NWDMYCell = NWRODR3_NWDMYCellIn AND NWRODR3_NWDMYCellOut
NWRODR3_NWDMYMarker = NWDMY AND RRuleGuideline
NWRODR3_NWDMY = ((( NWRODR3_NWDMYCell OR NWRODR3_NWDMYMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:NWROD.R.3__NWRSTI.R.3 { @ Recommended to use rectangle shape resistor
  NWRES_BODY = RNWEL AND (NWDMY INTERACT NWRODR3_NWDMY)
  NOT RECTANGLE NWRES_BODY ORTHOGONAL ONLY
}
#ENDIF // _NWRODR3_NWRSTIR3_
#ENDIF // CHECK_NWRODR3_NWRSTIR3_

#IFDEF CHECK_NWRODR8_NWRSTIR4_
#IFDEF _NWRODR8_NWRSTIR4_
// NWROD.R.8g is checked by RR:GL:NWROD.R.8__NWRSTI.R.4
// NWRSTI.R.4g is checked by RR:GL:NWROD.R.8__NWRSTI.R.4
NWRODR8_NWDMYCellIn = INSIDE CELL NWDMY CellsForRRuleGuideline  
NWRODR8_NWDMYCellOut = NOT INSIDE CELL NWDMY ExclCellsForRRuleGuideline 
NWRODR8_NWDMYCell = NWRODR8_NWDMYCellIn AND NWRODR8_NWDMYCellOut
NWRODR8_NWDMYMarker = NWDMY AND RRuleGuideline
NWRODR8_NWDMY = ((( NWRODR8_NWDMYCell OR NWRODR8_NWDMYMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:NWROD.R.8__NWRSTI.R.4 { @ Recommended: NWDMY intersecting NWROD/NWRSTI forms two or more NWs.
  NWRES_BODY = RNWEL AND (NWDMY INTERACT NWRODR8_NWDMY)
  A = (RNWEL INTERACT NWRES_BODY) NOT NWRES_BODY
  NWRES_BODY NOT INTERACT A >= 2
}
#ENDIF // _NWRODR8_NWRSTIR4_
#ENDIF // CHECK_NWRODR8_NWRSTIR4_

#IFDEF CHECK_RESR15_
#IFDEF _RESR15_
// RES.R.15g is checked by RR:GL:RES.R.15
RESR15_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR15_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR15_RHCell = RESR15_RHCellIn AND RESR15_RHCellOut
RESR15_RHMarker = RH AND RRuleGuideline
RESR15_RH = ((( RESR15_RHCell OR RESR15_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.15 { @ Recommended to use rectangle shape resistor for SPICE simulation accuracy
  (NOT RECTANGLE OD_RES_RPO) INTERACT RESR15_RH
  (NOT RECTANGLE PO_RES_RPO) INTERACT RESR15_RH
}
#ENDIF // _RESR15_
#ENDIF // CHECK_RESR15_

#IFDEF CHECK_RESR16_
#IFDEF _RESR16_
// RES.R.16g is checked by RR:GL:RES.R.16
RESR16_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR16_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR16_RHCell = RESR16_RHCellIn AND RESR16_RHCellOut
RESR16_RHMarker = RH AND RRuleGuideline
RESR16_RH = ((( RESR16_RHCell OR RESR16_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.16 { @ {RPDMY AND {{OD INTERACT CO} AND RPO}} is recommended being identical to {RH AND {{OD INTERACT CO} AND RPO}}, except BJTDMY
  A = ((RPDMY INTERACT RESR16_RH) AND ((OD INTERACT CO) AND RPO)) XOR ((RH INTERACT RESR16_RH) AND ((OD INTERACT CO) AND RPO))
  A NOT BJTDMY
}
#ENDIF // _RESR16_
#ENDIF // CHECK_RESR16_

#IFDEF CHECK_RESR17_
#IFDEF _RESR17_
// RES.R.17g is checked by RR:GL:RES.R.17
RESR17_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR17_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR17_RHCell = RESR17_RHCellIn AND RESR17_RHCellOut
RESR17_RHMarker = RH AND RRuleGuideline
RESR17_RH = ((( RESR17_RHCell OR RESR17_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.17 { @ {RPDMY AND {{PO INTERACT CO} AND RPO}} is recommended being identical to {RH AND {{PO INTERACT CO} AND RPO}}
  ((RPDMY INTERACT RESR17_RH) AND ((POLY INTERACT CO) AND RPO)) XOR ((RH INTERACT RESR17_RH) AND ((POLY INTERACT CO) AND RPO))
}
#ENDIF // _RESR17_
#ENDIF // CHECK_RESR17_

#IFDEF CHECK_RESR18_
#IFDEF _RESR18_
// RES.R.18g is checked by RR:GL:RES.R.18
RESR18_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR18_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR18_RHCell = RESR18_RHCellIn AND RESR18_RHCellOut
RESR18_RHMarker = RH AND RRuleGuideline
RESR18_RH = ((( RESR18_RHCell OR RESR18_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.18 { @ Recommended: RPDMY intersecting {(OD AND RH) NOT INTERACT RPO} forms two or more ODs.
  A = (OD AND RH) NOT INTERACT RPO
  B = (A INTERACT RPDMY) NOT RPDMY
  ((RPDMY INTERACT RESR18_RH) INTERACT A) NOT INTERACT B >= 2
}
#ENDIF // _RESR18_
#ENDIF // CHECK_RESR18_

#IFDEF CHECK_RESR19_
#IFDEF _RESR19_
// RES.R.19g is checked by RR:GL:RES.R.19
RESR19_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR19_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR19_RHCell = RESR19_RHCellIn AND RESR19_RHCellOut
RESR19_RHMarker = RH AND RRuleGuideline
RESR19_RH = ((( RESR19_RHCell OR RESR19_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.19 { @ Recommended: RPDMY intersecting {(PO AND RH) NOT INTERACT RPO} forms two or more POs.
  A = (POLY AND RH) NOT INTERACT RPO
  B = (A INTERACT RPDMY) NOT RPDMY
  ((RPDMY INTERACT RESR19_RH) INTERACT A) NOT INTERACT B >= 2
}
#ENDIF // _RESR19_
#ENDIF // CHECK_RESR19_

#IFDEF CHECK_RESR20_
#IFDEF _RESR20_
// RES.R.20g is checked by RR:GL:RES.R.20
RESR20_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR20_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR20_RHCell = RESR20_RHCellIn AND RESR20_RHCellOut
RESR20_RHMarker = RH AND RRuleGuideline
RESR20_RH = ((( RESR20_RHCell OR RESR20_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RES.R.20 { @ {CO BUTTED ((RPDMY AND RH) NOT INTERACT RPO)} is recommended.
  A = (RPDMY AND RESR20_RH) NOT INTERACT RPO
  B = A INSIDE EDGE OD
  C = A INSIDE EDGE POLY
  B NOT TOUCH OUTSIDE EDGE CO
  C NOT TOUCH OUTSIDE EDGE CO
}
#ENDIF // _RESR20_
#ENDIF // CHECK_RESR20_

#IFDEF CHECK_COS6_
#IFDEF _COS6_
// CO.S.6g is checked by RR:GL:CO.S.6
COS6_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
COS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
COS6_ODCell = COS6_ODCellIn AND COS6_ODCellOut
COS6_ODMarker = ODi AND RRuleGuideline
COS6_OD = ((( COS6_ODCell OR COS6_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:CO.S.6 { @ Recommended to put contacts at both source side and butted well pickup.
  BUTT_SOUR = SD INTERACT (BUTT_PSTP OR BUTT_NSTP)
  (BUTT_PSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_NSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_SOUR INTERACT COS6_OD ) NOT INTERACT COi
}
#ENDIF // _COS6_
#ENDIF // CHECK_COS6_

#IFDEF CHECK_COR5_
#IFDEF _COR5_
// CO.R.5g is checked by RR:GL:CO.R.5
COR5_COCellIn = INSIDE CELL COi CellsForRRuleGuideline  
COR5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleGuideline 
COR5_COCell = COR5_COCellIn AND COR5_COCellOut
COR5_COMarker = COi AND RRuleGuideline
COR5_CO = ((( COR5_COCell OR COR5_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:CO.R.5 { @ Recommended to use redundant CO to avoid high Rc whenever layout allows.
  (((FPO1 AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE SRAM_REGION
  (((SD AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE SRAM_REGION
  (((DSTP AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE SRAM_REGION
}
#ENDIF // _COR5_
#ENDIF // CHECK_COR5_



#ENDIF //Guideline


#IFDEF Recommended

#IFDEF CHECK_POS17_
#IFDEF _POS17_
POS17_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS17_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS17_POCell = POS17_POCellIn AND POS17_POCellOut
POS17_POMarker = POi AND RRuleRecommended
POS17_PO = ((( POS17_POCell OR POS17_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:PO.S.17 { @ Recommended Gate edge [channel length = 0.04 um, channel width <= 0.2 um] space to {(PO OR SR_DPO) OR DPO} [width >= 0.12 um] [projection in S/D direction], and Gate edge parallel run length (individual projection) in the same gate >= 0.1 um, for poly gate CDU control >= 0.16 
  GATE_CHK = ((GATE AND POS17_PO) WITH EDGE (LENGTH GATE_L == PO_S_17_R_GL)) WITH EDGE (LENGTH GATE_W <= PO_S_17_R_GW )
  GATE_W_CHK = GATE_W COIN INSIDE EDGE GATE_CHK
  POLY_CHECK = WITH WIDTH ALL_POLY >= PO_S_17_R_W
  X = EXT [GATE_W_CHK] POLY_CHECK < PO_S_17_R OPPOSITE
  LENGTH X >= PO_S_17_R_L
}
#ENDIF // _POS17_
#ENDIF // CHECK_POS17_

#IFDEF GS
#IFDEF CHECK_POS18_
#IFDEF _POS18_
// PO.S.18.GS.R is checked by RR:RE:PO.S.18
POS18_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS18_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS18_POCell = POS18_POCellIn AND POS18_POCellOut
POS18_POMarker = POi AND RRuleRecommended
POS18_PO = ((( POS18_POCell OR POS18_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:PO.S.18 { @ Recommend to add 2nd poly away from 1st poly [for channel length < 0.08 um] (DRC only check 1st poly space to gate <= 0.2 um and width < 0.08 um) = 0.14~0.2 
  GATE_CHK = ((GATE NOT TCDDMY) AND POS18_PO) WITH EDGE (LENGTH GATE_L < PO_S_18_R_GL)
  GATE_W_CHK = GATE_W COIN INSIDE EDGE GATE_CHK
  X = EXT GATE_W_CHK [ALL_POLY] <= PO_S_18_R_S OPPOSITE
  Y = INT X [ALL_POLY] < PO_S_18_R_W OPPOSITE
  EXT [Y] ALL_POLY < PO_S_18_R_1 OPPOSITE
  A = EXT [Y] ALL_POLY <= PO_S_18_R_2 OPPOSITE
  Y NOT COIN INSIDE EDGE A
}
#ENDIF // _POS18_
#ENDIF // CHECK_POS18_
#ENDIF // GS

#IFDEF CHECK_M1EN5_
#IFDEF _M1EN5_
M1EN5_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN5_COCell = M1EN5_COCellIn AND M1EN5_COCellOut
M1EN5_COMarker = COi AND RRuleRecommended
M1EN5_CO = ((( M1EN5_COCell OR M1EN5_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:M1.EN.5 { @ Enclosure of CO [metal width >= 0.11, space < 0.08] >= 0.015 (This check does not include two or more COs in the metal intersection)
  X = M1s WITH WIDTH >= M1_EN_5_R_W
  sus_co = M1EN5_CO NOT OUTSIDE X
  sus_M1 = M1i INTERACT sus_co
  sus_M1_OD = (sus_M1 AND (OD NOT POLY)) ENCLOSE COi == 1
  sus_M1_PO = (sus_M1 AND POLY) ENCLOSE COi == 1
  check_co = sus_co AND (sus_M1_OD OR sus_M1_PO)
  G1 = EXT [X] M1s < M1_EN_5_R_S OPPOSITE MEASURE ALL
  G2 = (EXT X M1s < M1_EN_5_R_S OPPOSITE REGION MEASURE ALL) NOT M1s
  check_edge = EXT G1 [G2] < M1_EN_5_R OPPOSITE ABUT < 90
  (EXT check_co check_edge < M1_EN_5_R ABUT < 90 REGION OPPOSITE) NOT INSIDE SRAM_REGION
}
#ENDIF // _M1EN5_
#ENDIF // CHECK_M1EN5_

M1A1_M1CellIn = INSIDE CELL M1i_R CellsForRRuleRecommended  
M1A1_M1CellOut = NOT INSIDE CELL M1i_R ExclCellsForRRuleRecommended 
M1A1_M1Cell = M1A1_M1CellIn AND M1A1_M1CellOut
M1A1_M1Marker = M1i_R AND RRuleRecommended
M1A1_M1 = ((M1A1_M1Cell OR M1A1_M1Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF CHECK_M1A1_
#IFDEF _M1A1_
RR:RE:M1.A.1 { @ Recommended area >= 0.0351
  (AREA M1A1_M1 < M1_A_1_R) NOT INSIDE SRAM_REGION
}
#ENDIF // _M1A1_
#ENDIF // CHECK_M1A1_
M2A1_M2CellIn = INSIDE CELL M2i_R CellsForRRuleRecommended  
M2A1_M2CellOut = NOT INSIDE CELL M2i_R ExclCellsForRRuleRecommended 
M2A1_M2Cell = M2A1_M2CellIn AND M2A1_M2CellOut
M2A1_M2Marker = M2i_R AND RRuleRecommended
M2A1_M2 = ((M2A1_M2Cell OR M2A1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF CHECK_M2A1_
#IFDEF _M2A1_
RR:RE:M2.A.1 { @ Recommended area >= 0.0351
  (AREA M2A1_M2 < M2_A_1_R) NOT INSIDE SRAM_REGION
}
#ENDIF // _M2A1_
#ENDIF // CHECK_M2A1_
M3A1_M3CellIn = INSIDE CELL M3i_R CellsForRRuleRecommended  
M3A1_M3CellOut = NOT INSIDE CELL M3i_R ExclCellsForRRuleRecommended 
M3A1_M3Cell = M3A1_M3CellIn AND M3A1_M3CellOut
M3A1_M3Marker = M3i_R AND RRuleRecommended
M3A1_M3 = ((M3A1_M3Cell OR M3A1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF CHECK_M3A1_
#IFDEF _M3A1_
RR:RE:M3.A.1 { @ Recommended area >= 0.0351
  (AREA M3A1_M3 < M3_A_1_R) NOT INSIDE SRAM_REGION
}
#ENDIF // _M3A1_
#ENDIF // CHECK_M3A1_
M4A1_M4CellIn = INSIDE CELL M4i_R CellsForRRuleRecommended  
M4A1_M4CellOut = NOT INSIDE CELL M4i_R ExclCellsForRRuleRecommended 
M4A1_M4Cell = M4A1_M4CellIn AND M4A1_M4CellOut
M4A1_M4Marker = M4i_R AND RRuleRecommended
M4A1_M4 = ((M4A1_M4Cell OR M4A1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF CHECK_M4A1_
#IFDEF _M4A1_
RR:RE:M4.A.1 { @ Recommended area >= 0.0351
  AREA M4A1_M4 < M4_A_1_R
}
#ENDIF // _M4A1_
#ENDIF // CHECK_M4A1_
M5A1_M5CellIn = INSIDE CELL M5i_R CellsForRRuleRecommended  
M5A1_M5CellOut = NOT INSIDE CELL M5i_R ExclCellsForRRuleRecommended 
M5A1_M5Cell = M5A1_M5CellIn AND M5A1_M5CellOut
M5A1_M5Marker = M5i_R AND RRuleRecommended
M5A1_M5 = ((M5A1_M5Cell OR M5A1_M5Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF CHECK_M5A1_
#IFDEF _M5A1_
RR:RE:M5.A.1 { @ Recommended area >= 0.0351
  AREA M5A1_M5 < M5_A_1_R
}
#ENDIF // _M5A1_
#ENDIF // CHECK_M5A1_


#ENDIF
#ENDIF


#IFDEF DFM
#IFDEF Recommended
#IFDEF Parametric
#DEFINE DFM_SANITY
#ENDIF
#ENDIF
#ENDIF

#IFDEF SANITY_CHECKER_FOR_PDE_AND_CO_PLACEMENT
#DEFINE DFM_SANITY
#DEFINE _ODDN4_
#DEFINE _ODDN5_
#DEFINE _ODDN6_
#DEFINE _ODDN7_
#DEFINE _ODDN8_
#DEFINE _ODDN9_
#DEFINE _DODR4_
#DEFINE _PODN4_
#DEFINE _PODN5_
#DEFINE _PODN6_
#DEFINE _PODN7_
#DEFINE _PODN8_
#DEFINE _PODN9_
#DEFINE _COS7_
#ENDIF

#IFDEF DFM_SANITY

#IFDEF CHECK_ODDN4_
#IFDEF _ODDN4_
RR:RE:OD.DN.4 { @ It is not recommended the gate interact with the region of {(OD local density < 10%) SIZING 20 um}. The definition of the gate is as follows: {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 20 umx20 um, stepping 10 um) >= 10% 
  X = DENSITY ALL_OD < OD_DN_4_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB OD.DN.4R.rep
      [AREA(ALL_OD)/AREA()]
  SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF // _ODDN4_
#ENDIF // CHECK_ODDN4_

#IFDEF CHECK_ODDN5_
#IFDEF _ODDN5_
RR:RE:OD.DN.5 { @ It is not recommended the gate interact with the region of {(OD local density > 70%) SIZING 20 um}. The definition of the gate is as follows: {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 20 umx20 um, stepping 10 um) <= 70% 
  X = DENSITY ALL_OD > OD_DN_5_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB OD.DN.5R.rep
      [AREA(ALL_OD)/AREA()]
  SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF // _ODDN5_
#ENDIF // CHECK_ODDN5_

#IFDEF CHECK_ODDN6_
#IFDEF _ODDN6_
RR:RE:OD.DN.6 { @ It is not recommended the gate interact with the region of {(OD local density < 20%) SIZING 100 um}. The definition of the gate is as follows: {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 50 umx50 um, stepping 25 um) >= 20% 
  X = DENSITY ALL_OD < OD_DN_6_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB OD.DN.6R.rep
      [AREA(ALL_OD)/AREA()]
  SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF // _ODDN6_
#ENDIF // CHECK_ODDN6_

#IFDEF CHECK_ODDN7_
#IFDEF _ODDN7_
RR:RE:OD.DN.7 { @ It is not recommended the gate interact with the region of {(OD local density > 70%) SIZING 100 um}. The definition of the gate is as follows: {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 50 umx50 um, stepping 25 um) <= 70% 
  X = DENSITY ALL_OD > OD_DN_7_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB OD.DN.7R.rep
      [AREA(ALL_OD)/AREA()]
  SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF // _ODDN7_
#ENDIF // CHECK_ODDN7_

#IFDEF CHECK_ODDN8_
#IFDEF _ODDN8_
RR:RE:OD.DN.8 { @ It is not recommended the unsalicided poly resistor interact with the region of {(OD local density < 20%) SIZING 100 um}. The definition of the unsalicided poly resistor is as follows: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 200 umx200 um, stepping 100 um) >= 20% 
  X = DENSITY ALL_OD < OD_DN_8_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB OD.DN.8R.rep
     [AREA(ALL_OD)/AREA()]
  SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF // _ODDN8_
#ENDIF // CHECK_ODDN8_

#IFDEF CHECK_ODDN9_
#IFDEF _ODDN9_
RR:RE:OD.DN.9 { @ It is not recommended the unsalicided poly resistor interact with the region of {(OD local density > 60%) SIZING 100 um}. The definition of the unsalicided poly resistor is as follows: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density is as follows: {OD OR DOD OR SR_DOD} local density (window 200 umx200 um, stepping 100 um) <= 60% 
  X = DENSITY ALL_OD > OD_DN_9_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB OD.DN.9R.rep
     [AREA(ALL_OD)/AREA()]
  SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF
#ENDIF // CHECK_ODDN9_

#IFDEF CHECK_DODR4_
#IFDEF _DODR4_
DODR4_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
DODR4_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
DODR4_POCell = DODR4_POCellIn AND DODR4_POCellOut
DODR4_POMarker = POi AND RRuleRecommended
DODR4_PO = ((( DODR4_POCell OR DODR4_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:DOD.R.4 { @ It is important to use TSMC DOD/DPO utility to insert the SR_DOD and SR_DPO properly surrounding your IP and circuit, and then do post-simulation carefully before chip implementation. DRC will flag the empty rectangle area larger than 1.8x1.8 um2 inside {(GATE SIZE 2.8) NOT (((OD OR DOD) OR SR_DOD) SIZE 0.12) NOT ((PO SIZE 0.05) OR ((DPO OR SR_DPO) SIZE 0.03)) NOT ((NW SIZE 0.08) NOT (NW SIZE -0.08))} (Except TCDDMY and SEALRING_ALL (162;2)) <= 1.8x1.8 um2 
  X = ((((((SIZE (GATEi AND DODR4_PO) BY 2.8) NOT (SIZE ALL_OD BY 0.12)) NOT ((SIZE POi BY 0.05) OR (SIZE (DPO OR SRDPO) BY 0.03))) NOT ( (SIZE NWi BY 0.08) NOT (SIZE NWi BY -0.08))) NOT TCDDMY) AND CHIP) NOT SEALRING_EXCLUDE
  WITH WIDTH X >= DOD_R_4_R
}
#ENDIF // _DODR4_
#ENDIF // CHECK_DODR4_

#IFDEF CHECK_PODN4_
#IFDEF _PODN4_
RR:RE:PO.DN.4 { @ It is not recommended the gate interact with the region of {(PO local density < 5%) SIZING 20 um}. The definition of gate is as follows: 1. Channel length <= 0.05 um2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 20 umx20 um, stepping 10 um) >= 5% 
  X = DENSITY ALL_POLY < PO_DN_4_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB PO.DN.4R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_GATE_005 INTERACT (X SIZE BY 20)
}
#ENDIF // _PODN4_
#ENDIF // CHECK_PODN4_

#IFDEF CHECK_PODN5_
#IFDEF _PODN5_
RR:RE:PO.DN.5 { @ It is not recommended the gate interact with the region of {(PO local density > 35%) SIZING 20 um}. The definition of gate is as follows: 1. Channel length <= 0.05 um2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 20 umx20 um, stepping 10 um) <= 35% 
  X = DENSITY ALL_POLY > PO_DN_5_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB PO.DN.5R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_GATE_005 INTERACT (X SIZE BY 20)
}
#ENDIF // _PODN5_
#ENDIF // CHECK_PODN5_

#IFDEF CHECK_PODN6_
#IFDEF _PODN6_
RR:RE:PO.DN.6 { @ It is not recommended the gate interact with the region of {(PO local density < 15%) SIZING 100 um}. The definition of gate is as follows: 1. Channel length <= 0.05 um2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 50 umx50 um, stepping 25 um) >= 15% 
  X = DENSITY ALL_POLY < PO_DN_6_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB PO.DN.6R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_GATE_005 INTERACT (X SIZE BY 100)
}
#ENDIF
#ENDIF // CHECK_PODN6_

#IFDEF CHECK_PODN7_
#IFDEF _PODN7_
RR:RE:PO.DN.7 { @ It is not recommended the gate interact with the region of {(PO local density > 35%) SIZING 100 um}. The definition of gate is as follows: 1. Channel length <= 0.05 um2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 50 umx50 um, stepping 25 um) <= 35% 
  X = DENSITY ALL_POLY > PO_DN_7_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB PO.DN.7R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_GATE_005 INTERACT (X SIZE BY 100)
}
#ENDIF // _PODN7_
#ENDIF // CHECK_PODN7_

#IFDEF CHECK_PODN8_
#IFDEF _PODN8_
RR:RE:PO.DN.8 { @ It is not recommended the unsalicided poly resistor interact with the region of {(PO local density < 15%) SIZING 100 um}. The definition of unsalicided poly resistor is as follows: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 200 umx200 um, stepping 100 um) >= 15% 
  X = DENSITY ALL_POLY < PO_DN_8_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB PO.DN.8R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF // _PODN8_
#ENDIF // CHECK_PODN8_

#IFDEF CHECK_PODN9_
#IFDEF _PODN9_
RR:RE:PO.DN.9 { @ It is not recommended the unsalicided poly resistor interact with the region of {(PO local density > 40%) SIZING 100 um}. The definition of unsalicided poly resistor is as follows: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region PO local density is as follows: {(PO OR DPO) OR SR_DPO} local density (window 200 umx200 um, stepping 100 um) <= 40% 
  X = DENSITY ALL_POLY > PO_DN_9_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB PO.DN.9R.rep
      [AREA(ALL_POLY)/AREA()]
  SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF // _PODN9_
#ENDIF // CHECK_PODN9_

#IFDEF CHECK_COS7_
#IFDEF _COS7_
// CO.S.7.R is checked by RR:RE:CO.S.7
// CO.S.7.a.R is checked by RR:RE:CO.S.7
COS7_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
COS7_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
COS7_POCell = COS7_POCellIn AND COS7_POCellOut
COS7_POMarker = POi AND RRuleRecommended
COS7_PO = ((( COS7_POCell OR COS7_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:CO.S.7 { @ Recommended maximum effective CO space in Source/Drain <= 0.29
  SD_CHK  = (SD INTERACT (CO OR DSTP)) NOT INTERACT ((HVD_N OR HVD_P) OR DEHVD_N)
  DACT_CHK  = DACT ENCLOSE CO
  GATE_W_COS7   = LENGTH (GATE_W INSIDE EDGE DACT_CHK) >= CO_S_7_R_W
  #IFDEF GS
  GATE_CHK_COS7 = ((GATE AND COS7_PO) WITH EDGE GATE_W_COS7) NOT (SRESD OR SDI)
  #ELSE
  GATE_CHK_COS7 = ((GATE AND COS7_PO) WITH EDGE GATE_W_COS7) NOT SDI
  #ENDIF
  GATE_W_CHK_COS7  = (GATE_W_COS7 COIN INSIDE EDGE GATE_CHK_COS7) COIN OUTSIDE EDGE SD_CHK
  SD_CHK_COS7 = SD_CHK WITH EDGE GATE_W_CHK_COS7
  CO_CHK_COS7 = CO AND SD_CHK_COS7
	CO_IN_GATE_W_COS7 = ENC CO_CHK_COS7 [SD_CHK_COS7] <= CO_S_7_R_S OPPOSITE EXCLUDE SHIELDED 4
  A = GATE_W_CHK_COS7 NOT COIN OUTSIDE EDGE CO_IN_GATE_W_COS7
  LENGTH A > CO_S_7_R

  HVD_SD_CHK  = (SD INTERACT (CO OR DSTP)) INTERACT (HVD_N OR HVD_P)
  HVD_GATE_W_CHK_COS7  = (GATE_W_COS7 COIN INSIDE EDGE GATE_CHK_COS7) COIN OUTSIDE EDGE HVD_SD_CHK
  HVD_SD_CHK_COS7 = HVD_SD_CHK WITH EDGE HVD_GATE_W_CHK_COS7
	HVD_CO_CHK_COS7 = CO AND HVD_SD_CHK_COS7
  HVD_CO_IN_GATE_W_COS7 = ENC HVD_CO_CHK_COS7 [HVD_SD_CHK_COS7] <= HVD_CO_S_7_R_S OPPOSITE EXCLUDE SHIELDED 4
  B = HVD_GATE_W_CHK_COS7 NOT COIN OUTSIDE EDGE HVD_CO_IN_GATE_W_COS7
	LENGTH B > CO_S_7_R
  
	DEHVDN_SD_CHK  = (SD INTERACT (CO OR DSTP)) INTERACT DEHVD_N
  DEHVDN_GATE_W_CHK_COS7  = (GATE_W_COS7 COIN INSIDE EDGE GATE_CHK_COS7) COIN OUTSIDE EDGE DEHVDN_SD_CHK
  DEHVDN_SD_CHK_COS7 = DEHVDN_SD_CHK WITH EDGE DEHVDN_GATE_W_CHK_COS7
	DEHVDN_CO_CHK_COS7 = CO AND DEHVDN_SD_CHK_COS7
  DEHVDN_CO_IN_GATE_W_COS7 = ENC DEHVDN_CO_CHK_COS7 [DEHVDN_SD_CHK_COS7] == DEHVD_N_S_9 OPPOSITE EXCLUDE SHIELDED 4
  C = DEHVDN_GATE_W_CHK_COS7 NOT COIN OUTSIDE EDGE DEHVDN_CO_IN_GATE_W_COS7
	LENGTH C > CO_S_7_R
}
#ENDIF // _COS7_
#ENDIF // CHECK_COS7_

#ENDIF // DFM_SANITY


#IFDEF DFM
#IFDEF Recommended
#IFDEF First_priority
#IFDEF FULL_CHIP
OD_PO = ODi OR POi
MOS_R1 = OD_PO INTERACT (GATE NOT INTERACT ((TCDDMY OR CDUDMY) OR CSRDMY))
MOS_R2 = SIZE OD_PO BY SRDOD_DN_1_R_S2
MOS_R3 = SIZE MOS_R1 BY SRDOD_DN_1_R_S1
MOS_R4 = MOS_R3 NOT MOS_R2
MOS_AREA = (MOS_R4 NOT SRAMDMY) NOT OD2

#IFDEF CHECK_SRDODDN1_
#IFDEF _SRDODDN1_
RR:RE:SR_DOD.DN.1 { @ Recommended minimum SR_DOD density inside {((((((OD OR PO) INTERACT GATE) SIZING 2.5 um) NOT ((OD OR PO) SIZING 0.4 um)) NOT SRAMDMY;0) NOT OD2)} (The GATE doesn't include the regions covered by layer TCDDMY, CSRDMY, CDUDMY) >= 8% 
  SRDOD_AREA = SRDOD AND MOS_AREA
  ERR = DENSITY SRDOD_AREA MOS_AREA < SRDOD_DN_1_R INSIDE OF LAYER CHIPx PRINT SR_DOD.DN.1.density
    [AREA(SRDOD_AREA)/AREA(MOS_AREA)]
  ERR AND MOS_AREA
}
#ENDIF // _SRDODDN1_
#ENDIF // CHECK_SRDODDN1_

#IFDEF CHECK_SRDPODN1_
#IFDEF _SRDPODN1_
RR:RE:SR_DPO.DN.1 { @ Recommended minimum SR_DPO density inside {((((((OD OR PO) INTERACT GATE) SIZING 2.5 um) NOT ((OD OR PO) SIZING 0.4 um)) NOT SRAMDMY;0) NOT OD2)} (The GATE doesn't include the regions covered by layer TCDDMY, CSRDMY, CDUDMY) >= 4% 
  SRDPO_AREA = SRDPO AND MOS_AREA
  ERR = DENSITY SRDPO_AREA MOS_AREA < SRDPO_DN_1_R INSIDE OF LAYER CHIPx PRINT SR_DPO.DN.1.density
    [AREA(SRDPO_AREA)/AREA(MOS_AREA)]
  ERR AND MOS_AREA
}
#ENDIF // _SRDPODN1_
#ENDIF // CHECK_SRDPODN1_

#IFDEF CHECK_MxDN8_
#IFDEF _MxDN8_
M2_ISLAND = RECTANGLE M2i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M2_SPACE = EXT M2_ISLAND M2i == Mx_DN_8_S OPPOSITE REGION
M2_LONG = (M2_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M2_AREA = M2_ISLAND INTERACT M2_LONG >= 2
M2_COUNT = EXTENTS M2_AREA CENTERS 0.1
M3_ISLAND = RECTANGLE M3i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M3_SPACE = EXT M3_ISLAND M3i == Mx_DN_8_S OPPOSITE REGION
M3_LONG = (M3_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M3_AREA = M3_ISLAND INTERACT M3_LONG >= 2
M3_COUNT = EXTENTS M3_AREA CENTERS 0.1
M4_ISLAND = RECTANGLE M4i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M4_SPACE = EXT M4_ISLAND M4i == Mx_DN_8_S OPPOSITE REGION
M4_LONG = (M4_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M4_AREA = M4_ISLAND INTERACT M4_LONG >= 2
M4_COUNT = EXTENTS M4_AREA CENTERS 0.1
M5_ISLAND = RECTANGLE M5i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M5_SPACE = EXT M5_ISLAND M5i == Mx_DN_8_S OPPOSITE REGION
M5_LONG = (M5_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M5_AREA = M5_ISLAND INTERACT M5_LONG >= 2
M5_COUNT = EXTENTS M5_AREA CENTERS 0.1
RR:RE:Mx.DN.8 { @ Total Mx island (for all Mx layers) density<6.5E+4 ea/mm2 in whole chip.
@ The definition of counts of small Mx island:
@ 1. Mx width == 0.07um
@ 2. Mx length <= 0.52um
@ 3. Mx has two segments with space == 0.07um with the parallel run length (0.209 <= parallel run length<0.52)
  DENSITY M2_COUNT M3_COUNT M4_COUNT M5_COUNT >= Mx_DN_8 INSIDE OF LAYER CHIPx PRINT Mx.DN.8.density
  [(AREA(M2_COUNT) + AREA(M3_COUNT) + AREA(M4_COUNT) + AREA(M5_COUNT) )*100/AREA()]
}
#ENDIF // _MxDN8_
#ENDIF // CHECK_MxDN8_

#IFDEF CHECK_ROMR3_
#IFDEF _ROMR3_
RR:RE:ROM.R.3 { @ Each ROM cell must be covered by ROM(50;6). DRC only flags no ROM(50;6) in the chip. But if there is no ROM cell in the chip, the violation can be waived.
  CHIPx NOT INTERACT ROM
}
#ENDIF // _ROMR3_
#ENDIF // CHECK_ROMR3_

#ENDIF
#ENDIF // First_priority
#ENDIF // Recommended
#ENDIF // DFM


#IFDEF DFM
#DEFINE ICOVL
#ENDIF

#IFDEF ICOVL
#IFDEF CHECK_ICOVL_

OVL_PO_OD = ICOVL NOT INTERACT COi
OVL_CO_PO = ICOVL INTERACT COi

#IFDEF TSMC_ROTATE
CHIP_X = ANGLE CHIPx == 90
CHIP_Y = ANGLE CHIPx == 0
#ELSE
CHIP_X = ANGLE CHIPx == 0
CHIP_Y = ANGLE CHIPx == 90
#ENDIF

#IFNDEF HALF_NODE
#IFNDEF GS
CHIP_X1 = LENGTH CHIP_X > 12880
CHIP_X2 = LENGTH CHIP_X > 8560 <= 12880
CHIP_Y1 = LENGTH CHIP_Y > 16420
CHIP_Y2 = LENGTH CHIP_Y > 10920 <= 16420
#ELSE
CHIP_X1 = LENGTH CHIP_X > 14310
CHIP_X2 = LENGTH CHIP_X > 9510 <= 14310
CHIP_Y1 = LENGTH CHIP_Y > 18240
CHIP_Y2 = LENGTH CHIP_Y > 12130 <= 18240
#ENDIF // GS
#ELSE
CHIP_X1 = LENGTH CHIP_X > 14310
CHIP_X2 = LENGTH CHIP_X > 9510 <= 14310
CHIP_Y1 = LENGTH CHIP_Y > 18240
CHIP_Y2 = LENGTH CHIP_Y > 12130 <= 18240
#ENDIF // HALF_NODE

CHIP_1x1 = (CHIPx WITH EDGE CHIP_X1) WITH EDGE CHIP_Y1
CHIP_1x2 = (CHIPx WITH EDGE CHIP_X1) WITH EDGE CHIP_Y2
CHIP_2x1 = (CHIPx WITH EDGE CHIP_X2) WITH EDGE CHIP_Y1
CHIP_2x2 = (CHIPx WITH EDGE CHIP_X2) WITH EDGE CHIP_Y2

RR:RE:ICOVL.S.1 { @ Recommend OVL_PO_OD space to OVL_CO_PO >= 40 
  EXT OVL_PO_OD OVL_CO_PO < ICOVL_S_1 ABUT<90 SINGULAR REGION
}

RR:RE:ICOVL.S.2 { @ Recommend space between 2 OVL_PO_ODs or 2 OVL_CO_POs >= 2000 
  EXT OVL_PO_OD < ICOVL_S_2 ABUT < 90 SINGULAR REGION
  EXT OVL_CO_PO < ICOVL_S_2 ABUT < 90 SINGULAR REGION
}

RR:RE:ICOVL.S.3 { @ Recommend ICOVL (CAD layer no.: 165;3) space to {(OD OR PO) OR CO} >= 2 
  EXT ICOVL ODi < ICOVL_S_3 ABUT<90 SINGULAR REGION
  ODi CUT ICOVL
  EXT ICOVL POi < ICOVL_S_3 ABUT<90 SINGULAR REGION
  POi CUT ICOVL
  EXT ICOVL COi < ICOVL_S_3 ABUT<90 SINGULAR REGION
  COi CUT ICOVL
}

RR:RE:ICOVL.S.4 { @ Recommend enclosed OD space inside OVL_PO_OD (maximum = minimum) = 1.1 
  A = HOLES (ODi INSIDE OVL_PO_OD)
  B = ODi INSIDE A
  OVL_PO_OD NOT INTERACT B
  NOT WITH WIDTH (A NOT B) == ICOVL_S_4
}

RR:RE:ICOVL.S.5 { @ Recommend space between 2 COs for OVL_CO_PO [in the same ring] = 0.1 
  A = COi INSIDE OVL_CO_PO
  EXT A < ICOVL_S_5 ABUT<90 SINGULAR REGION
  B = SIZE A BY ICOVL_S_5/2 OVERUNDER
  OVL_CO_PO NOT INTERACT B == 1
  NOT WITH WIDTH (B NOT A) == ICOVL_S_5
  C = HOLES B
  B NOT INTERACT C == 1
}

RR:RE:ICOVL.W.1 { @ Recommend width of PO ring inside ICOVL (maximum = minimum) = 1.1 
  A = POi INSIDE ICOVL
  NOT WITH WIDTH A == ICOVL_W_1
}

RR:RE:ICOVL.W.2 { @ Recommend width of M1 ring inside OVL_CO_PO (maximum = minimum) = 1.1 
  A = (M1i INSIDE OVL_CO_PO) INTERACT COi
  NOT WITH WIDTH A == ICOVL_W_2
}

RR:RE:ICOVL.W.3 { @ Recommend width of CO inside OVL_CO_PO (maximum = minimum) = 0.17 
  A = COi INSIDE OVL_CO_PO
  NOT RECTANGLE A == ICOVL_W_3 BY == ICOVL_W_3 ORTHOGONAL ONLY
}

RR:RE:ICOVL.W.4 { @ Recommend width of {OD INTERACT PO} inside OVL_PO_OD (maximum = minimum) = 16.5 
  A = (ODi INSIDE OVL_PO_OD ) INTERACT POi
  NOT RECTANGLE A == ICOVL_W_4 BY == ICOVL_W_4 ORTHOGONAL ONLY
}

RR:RE:ICOVL.W.5 { @ Recommend PO hole width inside OVL_CO_PO (maximum = minimum) = 16.5 
  A = POi INSIDE OVL_CO_PO
  B = HOLES A
  NOT RECTANGLE B == ICOVL_W_5 BY == ICOVL_W_5 ORTHOGONAL ONLY
}

RR:RE:ICOVL.EN.1 { @ Recommend {OD INTERACT PO} enclosure by PO inside OVL_PO_OD (maximum = minimum) = 3.3 
  A = (ODi INSIDE OVL_PO_OD) INTERACT POi
  B = POi INSIDE OVL_PO_OD
  ENC B A < ICOVL_EN_1 ABUT<90 SINGULAR REGION
  (SIZE A BY -ICOVL_EN_1) NOT COIN INSIDE EDGE B
}

RR:RE:ICOVL.EN.2 { @ Recommend M1 ring enclosure by PO ring inside OVL_CO_PO (maximum = minimum) = 3.92 
  A = POi INSIDE OVL_CO_PO
  B = (M1i INSIDE OVL_CO_PO) INTERACT COi
  EXT B A < ICOVL_EN_2 ABUT<90 SINGULAR REGION
  C = HOLES A
  (SIZE C BY -ICOVL_EN_2) NOT COIN INSIDE EDGE B
}

#IFDEF FULL_CHIP
RR:RE:ICOVL.R.7 { @ Recommend at least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 die   
  CHIP_1x1 NOT INTERACT OVL_PO_OD >= ICOVL_R_7
  CHIP_1x1 NOT INTERACT OVL_CO_PO >= ICOVL_R_7
}

RR:RE:ICOVL.R.8 { @ Recommend at least 4 OVL_PO_ODs and 4 OVL_CO_POs for 1X2 die or 2X1 die   
  CHIP_1x2 NOT INTERACT OVL_PO_OD >= ICOVL_R_8
  CHIP_1x2 NOT INTERACT OVL_CO_PO >= ICOVL_R_8
  CHIP_2x1 NOT INTERACT OVL_PO_OD >= ICOVL_R_8
  CHIP_2x1 NOT INTERACT OVL_CO_PO >= ICOVL_R_8
}

RR:RE:ICOVL.R.9 { @ Recommend only one polygon is allowed in one chip for 1X1 die by {OVL_PO_OD SIZING +6500 um}   
  CHIP_1x1 INTERACT (SIZE OVL_PO_OD BY ICOVL_R_9) > 1

}

RR:RE:ICOVL.R.10 { @ Recommend only one polygon is allowed in one chip for 1X1 die by {OVL_CO_PO SIZING +6500 um}   
  CHIP_1x1 INTERACT (SIZE OVL_CO_PO BY ICOVL_R_10) > 1
}

RR:RE:ICOVL.R.11 { @ Recommend only one polygon is allowed in one chip 1X2 die or 2X1 die by {OVL_PO_OD SIZING +8000 um}   
  CHIP_1x2 INTERACT (SIZE OVL_PO_OD BY ICOVL_R_11) > 1
  CHIP_2x1 INTERACT (SIZE OVL_PO_OD BY ICOVL_R_11) > 1
}

RR:RE:ICOVL.R.12 { @ Recommend only one polygon is allowed in one chip 1X2 die or 2X1 die by {OVL_CO_PO SIZING +8000 um}   
  CHIP_1x2 INTERACT (SIZE OVL_CO_PO BY ICOVL_R_12) > 1
  CHIP_2x1 INTERACT (SIZE OVL_CO_PO BY ICOVL_R_12) > 1
}

RR:RE:ICOVL.R.13 { @ Recommend empty space between 2 OVL_PO_ODs for 1X1 die. DRC flags: {((Chip NOT OVL_PO_OD) SIZING -8000 um) SIZING +8000 um} <= 16000 
  SIZE (CHIP_1x1 NOT OVL_PO_OD) BY ICOVL_R_13/2 UNDEROVER
}

RR:RE:ICOVL.R.14 { @ Recommend empty space between 2 OVL_CO_POs for 1X1 die. DRC flags: {((Chip NOT OVL_CO_PO) SIZING -8000 um) SIZING +8000 um} <= 16000 
  SIZE (CHIP_1x1 NOT OVL_CO_PO) BY ICOVL_R_14/2 UNDEROVER
}

RR:RE:ICOVL.R.15 { @ Recommend empty space between 2 OVL_PO_ODs for 1X2 die or 2X1 die. DRC flags: {((Chip NOT OVL_PO_OD) SIZING -6500 um) SIZING +6500 um} <= 13000 
  SIZE (CHIP_1x2 NOT OVL_PO_OD) BY ICOVL_R_15/2 UNDEROVER
  SIZE (CHIP_2x1 NOT OVL_PO_OD) BY ICOVL_R_15/2 UNDEROVER
}

RR:RE:ICOVL.R.16 { @ Recommend empty space between 2 OVL_CO_POs for 1X2 die or 2X1 die. DRC flags: {((Chip NOT OVL_CO_PO) SIZING -6500 um) SIZING +6500 um} <= 13000 
  SIZE (CHIP_1x2 NOT OVL_CO_PO) BY ICOVL_R_16/2 UNDEROVER
  SIZE (CHIP_2x1 NOT OVL_CO_PO) BY ICOVL_R_16/2 UNDEROVER
}

RR:RE:ICOVL.R.17 { @ Recommend density of {(OVL_PO_OD SIZING +16500 um) SIZING -15500 um} for 1X1 die >= 25% 
  A = SIZE (SIZE OVL_PO_OD BY ICOVL_R_17_S1) BY -ICOVL_R_17_S2
  DENSITY A < ICOVL_R_17 INSIDE OF LAYER CHIP_1x1 PRINT ICOVL.R.17.density
}

RR:RE:ICOVL.R.18 { @ Recommend density of {(OVL_CO_PO SIZING +16500 um) SIZING -15500 um} for 1X1 die >= 25% 
  A = SIZE (SIZE OVL_CO_PO BY ICOVL_R_18_S1) BY -ICOVL_R_18_S2
  DENSITY A < ICOVL_R_18 INSIDE OF LAYER CHIP_1x1 PRINT ICOVL.R.18.density
}

RR:RE:ICOVL.R.19 { @ Recommend density of {(OVL_PO_OD SIZING +13000 um) SIZING -10000 um} for 1X2 die or 2X1 die >= 25% 
  A = SIZE (SIZE OVL_PO_OD BY ICOVL_R_19_S1) BY -ICOVL_R_19_S2
  B = CHIP_1x2 OR CHIP_2x1
  DENSITY A < ICOVL_R_19 INSIDE OF LAYER B PRINT ICOVL.R.19.density
}

RR:RE:ICOVL.R.20 { @ Recommend density of {(OVL_CO_PO SIZING +13000 um) SIZING -10000 um} for 1X2 die or 2X1 die >= 25% 
  A = SIZE (SIZE OVL_CO_PO BY ICOVL_R_20_S1) BY -ICOVL_R_20_S2
  B = CHIP_1x2 OR CHIP_2x1
  DENSITY A < ICOVL_R_20 INSIDE OF LAYER B PRINT ICOVL.R.20.density
}
RR:RE:ICOVL.R.21 { @ Recommend at least 1 OVL_PO_OD fully inside {Chip SIZING -2380 um} for 2X2 die   
  A = SIZE CHIP_2x2 BY -ICOVL_R_21_S
  B = OVL_PO_OD INSIDE A
  A NOT INTERACT B >= ICOVL_R_21
}

RR:RE:ICOVL.R.22 { @ Recommend at least 1 OVL_CO_PO fully inside {Chip SIZING -2380 um} for 2X2 die   
  A = SIZE CHIP_2x2 BY -ICOVL_R_22_S
  B = OVL_CO_PO INSIDE A
  A NOT INTERACT B >= ICOVL_R_22
}
#ENDIF // FULL_CHIP
#ENDIF // CHECK_ICOVL_
#ENDIF // ICOVL











//****************************************************************************************************
//* CALIBRE DRC COMMAND FILE - CN40_6M_4X1Z_ULP_PATCH.14_2a (07/31/2020)
//* FOR TSMC 40 NM CMOS LOGIC EXTREME HIGH AND LOW VT 1P6M PROCESS WITH 4X1Z METAL OPTION 
//* DRC COMMAND FILE DOCUMENT: T-N40-CL-DR-023-C1 VER 1.4_2a
//* DESIGN RULE DOCUMENT: T-N40-CL-DR-023 VER 1.4_2
//****************************************************************************************************

//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************

//****************************************************************************
//
//  NOTICE: (Read Me First!)
// 
//   *** Warning: This DRC file CN40_6M_4X1Z_ULP_PATCH.14_2a can not be run alone! ***
//
//   This DRC file CN40_6M_4X1Z_ULP_PATCH.14_2a needs to be combined with
//   the DRC file of generic process (T-N45-CL-DR-001) to get the complete 
//   DRC file. A syntax error will be reported by Calibre DRC tool when 
//   CN40_6M_4X1Z_ULP_PATCH.14_2a is run alone. Please be sure to complete the following procedures for 
//   correct usage of this DRC deck.
//
//   Procedures:
// 
//   1. Please download the latest N45 logic DRC deck from TSMC-online. 
//      Suppose 6 metal layer process with 4X1Z METAL OPTION has been chosen,
//      then the generic DRC command file needed is CLN45_6M_4X1Z.26a (version may be varied!).
//     
//   2. Read the '3_UserGuide.txt' in the DRC deck package for correct generic usage.
//
//   3. Use the unix command 'cat' to create this DRC file
//      (assuming % is the unix prompt):
//
//      %cat CLN45_6M_4X1Z.26a CN40_6M_4X1Z_ULP_PATCH.14_2a > CLN45_6M_4X1Z+CN40_6M_4X1Z_ULP_PATCH.14_2a
//
//   As a result, CLN45_6M_4X1Z.26a+CN40_6M_4X1Z_ULP_PATCH.14_2a is the complete DRC command file.
//
//
//-----------------------------------------------------------------------------------



/* SWITCH DEFINITION START */
//
#DEFINE _SERRESN2_          // Systematic related(Others)

#IFDEF Systematic
#DEFINE CHECK_SERRESN2_    // Systematic related(Others)
#ENDIF
//
/* SWITCH DEFINITION END */

// DRAWN LAYER DEFINITIONS
//------------------------
LAYER EHVTNi 9301             // Extreme High Vt NMOS implant
LAYER MAP 93 DATATYPE 1 9301
LAYER EHVTPi 9401             // Extreme High Vt PMOS implant
LAYER MAP 94 DATATYPE 1 9401
LAYER ELVTNi 1512             // Extreme Low Vt NMOS implant
LAYER MAP 151 DATATYPE 2 1512
LAYER ELVTPi 1522             // Extreme Low Vt PMOS implant   
LAYER MAP 152 DATATYPE 2 1522
LAYER AVTi   2070             // recongize analogue transistor
LAYER MAP 207 DATATYPE 0 2070
LAYER ULP_WR  25564            // Wide range Vdd usage
LAYER MAP 255 DATATYPE 64 25564
LAYER SRM_ULL 5028            // Define ULL SRAM implant
LAYER MAP 50 DATATYPE 28 5028
LAYER LNP    1625   
LAYER MAP 162 DATATYPE 5 1625
LAYER SERPDMY 11520
LAYER MAP 115 DATATYPE 20 11520
LAYER ANALOG    20711
LAYER MAP 207 DATATYPE 11 20711
LAYER JDMY  18351
LAYER MAP 183 DATATYPE 51 18351
LAYER JNW   18350
LAYER MAP 183 DATATYPE 50 18350
LAYER HVJDMY    18352
LAYER MAP 183 DATATYPE 52 18352
LAYER JFETDMY_1 18321
LAYER MAP 183 DATATYPE 21 18321
LAYER JFETDMY_2 18322
LAYER MAP 183 DATATYPE 22 18322
LAYER JFETDMY_4 18324
LAYER MAP 183 DATATYPE 24 18324
LAYER JFETDMY_5 18325
LAYER MAP 183 DATATYPE 25 18325
LAYER FGDDMY 20820
LAYER MAP 208 DATATYPE 20 20820
LAYER SBDDMYi    11320     		// SBDDMY to cover schottky barrier diode
LAYER MAP 113 DATATYPE 10 11320
SBDDMY = COPY SBDDMYi


EHVTN  = EHVTNi NOT SRAM_EXCLUDE
EHVTNs = EHVTNi NOT INSIDE SRAM_EXCLUDE
EHVTP  = EHVTPi NOT SRAM_EXCLUDE
EHVTPs = EHVTPi NOT INSIDE SRAM_EXCLUDE
ELVTN  = ELVTNi NOT SRAM_EXCLUDE
ELVTNs = ELVTNi NOT INSIDE SRAM_EXCLUDE
ELVTP  = ELVTPi NOT SRAM_EXCLUDE
ELVTPs = ELVTPi NOT INSIDE SRAM_EXCLUDE
AVT  = AVTi NOT SRAM_EXCLUDE
AVTs = AVTi NOT INSIDE SRAM_EXCLUDE

// VARIABLE 
//===================
VARIABLE EHVTN_W_1    0.18
VARIABLE EHVTN_W_2    0.05
VARIABLE EHVTN_S_1    0.18
VARIABLE EHVTN_S_2    0.08
VARIABLE EHVTN_S_2_1  0.16
VARIABLE EHVTN_S_3    0.18
VARIABLE EHVTN_EN_1   0.16
VARIABLE EHVTN_EN_2   0.08
VARIABLE EHVTN_A_1    0.19
VARIABLE EHVTN_A_2    0.19
VARIABLE EHVTN_R_3    0.14
VARIABLE EHVTN_L_1    0.50
VARIABLE EHVTP_W_1    0.18
VARIABLE EHVTP_W_2    0.05
VARIABLE EHVTP_S_1    0.18
VARIABLE EHVTP_S_2    0.08
VARIABLE EHVTP_S_2_1  0.16
VARIABLE EHVTP_S_3    0.18
VARIABLE EHVTP_EN_1   0.16
VARIABLE EHVTP_EN_2   0.08
VARIABLE EHVTP_A_1    0.19
VARIABLE EHVTP_A_2    0.19
VARIABLE EHVTP_R_3    0.14
VARIABLE EHVTP_L_1    0.50
VARIABLE ELVTN_W_1    0.18
VARIABLE ELVTN_S_1    0.18
VARIABLE ELVTN_S_2    0.08
VARIABLE ELVTN_S_2_1  0.14
VARIABLE ELVTN_S_3    0.18
VARIABLE ELVTN_EN_1   0.14
VARIABLE ELVTN_EN_2   0.08
VARIABLE ELVTN_A_1    0.19
VARIABLE ELVTN_A_2    0.19
VARIABLE ELVTN_R_3    0.14
VARIABLE ELVTN_L_1    0.50
VARIABLE ELVTP_W_1    0.18
VARIABLE ELVTP_S_1    0.18
VARIABLE ELVTP_S_2    0.08
VARIABLE ELVTP_S_2_1  0.14
VARIABLE ELVTP_S_3    0.18
VARIABLE ELVTP_EN_1   0.14
VARIABLE ELVTP_EN_2   0.08
VARIABLE ELVTP_A_1    0.19
VARIABLE ELVTP_A_2    0.19
VARIABLE ELVTP_R_3    0.14
VARIABLE ELVTP_L_1    0.50
VARIABLE AVT_W_1      0.30
VARIABLE AVT_W_2      0.27
VARIABLE AVT_W_3      0.27
VARIABLE AVT_S_1      0.18
VARIABLE AVT_S_2      0.08
VARIABLE AVT_S_3      0.16
VARIABLE AVT_S_4      0.18
VARIABLE AVT_EN_1     0.19
VARIABLE AVT_EN_2     0.08
VARIABLE AVT_A_1      0.19
VARIABLE AVT_A_2      0.19
VARIABLE AVT_R_3      0.14
VARIABLE AVT_L_1      0.50
VARIABLE N_AVT_W_1    0.80
VARIABLE SRAM_WARN_3  645000
VARIABLE SRAM_WARN_4  807000
VARIABLE SRAM_WARN_5  800000
VARIABLE LNP_W_1_MIN   45
VARIABLE LNP_W_1_MAX   50
VARIABLE LNP_W_1_1_MIN 50
VARIABLE LNP_W_1_1_MAX 65
VARIABLE LNP_W_2       2
VARIABLE LNP_W_3       1.5
VARIABLE LNP_W_4       0.1
VARIABLE LNP_W_4L      45.76
VARIABLE LNP_S_1       6
VARIABLE LNP_S_2       0.12
VARIABLE LNP_S_3       0.1
VARIABLE LNP_R_6       6
VARIABLE LNP_R_7       1
#IFNDEF WIRE_BOND
VARIABLE LNP_FC_R_8     2
VARIABLE LNP_FC_R_8_MIN 4
VARIABLE LNP_FC_R_8_MAX 7
#ENDIF
VARIABLE SERRES_W_1   0.04     
VARIABLE SERRES_S_1   0.1
VARIABLE SERRES_S_2   0.3
VARIABLE SERRES_S_3   0.6
VARIABLE SERRES_EX_1  0.3
VARIABLE SERPDMY_EX_1  0.0
VARIABLE RH_EX_1    0.0
VARIABLE SERRES_N_1   752
VARIABLE SERRES_N_2_R 1006522
VARIABLE SERRES_N_3   2
VARIABLE SERRES_L_1   3.6
VARIABLE POJ_N_W_1	0.7
VARIABLE POJ_N_W_2	0.08
VARIABLE POJ_N_W_3	0.08
VARIABLE POJ_N_W_4	0.8
VARIABLE POJ_N_S_1	0.5
VARIABLE POJ_N_S_2	0.5
VARIABLE POJ_N_S_3	0.22
VARIABLE POJ_N_S_4	0.05
VARIABLE POJ_N_S_5	0.25
VARIABLE POJ_N_S_6	0.4
VARIABLE POJ_N_EN_1	0.8
VARIABLE POJ_N_EN_2	1
VARIABLE POJ_N_EN_3	0.12
VARIABLE POJ_N_EN_4	0.54
VARIABLE POJ_N_EX_1	0.3
VARIABLE POJ_N_EX_2	0.17
VARIABLE POJ_N_EX_3	0.3
VARIABLE POJ_N_EX_4	0.3
VARIABLE POJ_N_O_1	0.1
VARIABLE POJ_N_O_2	0.1
VARIABLE POJ_N_O_3	0.15
VARIABLE POJ_P_W_1	0.7
VARIABLE POJ_P_W_2	0.08
VARIABLE POJ_P_W_3	0.8
VARIABLE POJ_P_S_1	0.22
VARIABLE POJ_P_S_2	0.05
VARIABLE POJ_P_S_3	0.25
VARIABLE POJ_P_S_4	0.4
VARIABLE POJ_P_EN_1	0.12
VARIABLE POJ_P_EN_2	0.54
VARIABLE POJ_P_EX_1	0.3
VARIABLE POJ_P_EX_2	0.17
VARIABLE POJ_P_EX_3	0.3
VARIABLE POJ_P_EX_4	0.3
VARIABLE POJ_P_O_1	0.1
VARIABLE POJ_P_O_2	0.1
VARIABLE POJ_P_O_3	0.15
VARIABLE HVJ_N_W_2	0.08
VARIABLE HVJ_N_W_3	0.08
VARIABLE HVJ_N_W_4	0.08
VARIABLE HVJ_N_W_5	0.08
VARIABLE HVJ_N_W_6	0.35
VARIABLE HVJ_N_W_7	0.52
VARIABLE HVJ_N_S_1	1.0
VARIABLE HVJ_N_S_2	0.55
VARIABLE HVJ_N_S_3	0.55
VARIABLE HVJ_N_S_4	0.68
VARIABLE HVJ_N_S_5	0.3
VARIABLE HVJ_N_S_6	0.34
VARIABLE HVJ_N_S_7	2.08
VARIABLE HVJ_N_EN_1	0.8
VARIABLE HVJ_N_EN_2	1.0
VARIABLE HVJ_N_EN_3	0.25
VARIABLE HVJ_N_EN_4	0.15
VARIABLE HVJ_N_EN_5	0.08
VARIABLE HVJ_N_N_1	1.0
VARIABLE HVJ_P_W_1	1.0
VARIABLE HVJ_P_W_2	0.08
VARIABLE HVJ_P_W_3	0.08
VARIABLE HVJ_P_W_4	0.08
VARIABLE HVJ_P_W_5	0.8
VARIABLE HVJ_P_S_1	0.5
VARIABLE HVJ_P_S_2	0.5
VARIABLE HVJ_P_S_3	0.5
VARIABLE HVJ_P_S_4	0.0
VARIABLE HVJ_P_S_5	0.22
VARIABLE HVJ_P_EN_1	0.8
VARIABLE HVJ_P_EN_2	1.0
VARIABLE HVJ_P_EN_3	0.01
VARIABLE HVJ_P_EN_4	0.05
VARIABLE HVJ_P_O_1	0.1
VARIABLE HVJ_P_O_2	0.1
VARIABLE HVJ_P_N_1	1.0
VARIABLE JDMY_S_1	0.0
VARIABLE JDMY_EN_1	0.0
VARIABLE JNW_W_1	1.0
VARIABLE JNW_S_1	0.5
VARIABLE JNW_S_2	0.2
VARIABLE JNW_EN_1	0.5
VARIABLE JNW_EX_1	0.0
VARIABLE JNW_EX_2	0.5
VARIABLE JNW_O_1	0.4
VARIABLE JFETDMY_1_W_1	1.94
VARIABLE JFETDMY_1_S_1	6.8
VARIABLE JFETDMY_1_S_2	6.24
VARIABLE JFETDMY_1_EN_1	0.0
VARIABLE JFETDMY_1_N_1	1.0
VARIABLE JFETDMY_2_S_1	5.44
VARIABLE JFETDMY_2_S_2	0.0
VARIABLE JFETDMY_2_S_3	0.0
VARIABLE JFETDMY_2_N_1	1
VARIABLE JFETDMY_4_S_1	0.0
VARIABLE JFETDMY_4_S_2	0.0
VARIABLE JFETDMY_4_EN_1	0.0
VARIABLE JFETDMY_4_N_1	2.0
VARIABLE JFETDMY_5_EN_1	0.0
VARIABLE JFETDMY_5_N_1	2.0
VARIABLE ANALOG_EN_1	0.5
VARIABLE OD_25_EN_1	0.5
VARIABLE JFETDMY_1_W_2_1 10.44
VARIABLE JFETDMY_1_W_2_2 19.04
VARIABLE JFETDMY_1_W_2_3 44.84
VARIABLE HVJ_N_W_1_1 9.34
VARIABLE HVJ_N_W_1_2 17.94
VARIABLE HVJ_N_W_1_3 43.74
VARIABLE OD_25_EN_2_4V_PJFET 0.5
VARIABLE OD_25_EN_2_4V_NJFET 1.0
VARIABLE HVJDMY_EN_1_4V_PJFET 0.5
VARIABLE HVJDMY_EN_1_4V_NJFET 1.0
VARIABLE  PO_A_3_1    0.1
VARIABLE  PO_A_3_1_L  0.04
VARIABLE  PO_A_3_1_S  0.04
VARIABLE FGD_W_1	10.0
VARIABLE FGD_W_2	10.0
VARIABLE FGD_W_3	0.61
VARIABLE FGD_S_1	0.4
VARIABLE FGD_S_2	0.49
VARIABLE FGD_S_3	0.0
VARIABLE FGD_EX_1	0.33
VARIABLE FGD_EX_2	0.15
VARIABLE FGD_EX_3	0.25
VARIABLE FGD_EX_4	0.15
VARIABLE FGD_N_1	2.0
VARIABLE NGD_W_1	10.0
VARIABLE NGD_W_2	10.0
VARIABLE NGD_W_3	0.61
VARIABLE NGD_S_1	0.4
VARIABLE NGD_S_2	0.49
VARIABLE NGD_EX_1	0.33
VARIABLE NGD_EX_4	0.15
VARIABLE NGD_N_1	2.0
VARIABLE ANALOG_W_1	0.47
VARIABLE ANALOG_S_1	0.47
VARIABLE ANALOG_S_2	0.27
VARIABLE ANALOG_S_3	0.34
VARIABLE ANALOG_S_4	0.27
VARIABLE ANALOG_EX_1	0.27
VARIABLE ANALOG_EX_2	0.34
VARIABLE ANALOG_A_1	0.22
VARIABLE OD_25_EN_3	0.13
VARIABLE OD_25_EN_4	0.0
VARIABLE SBD_W_1	4.0
VARIABLE SBD_W_1_1	16.0
VARIABLE SBD_W_2	4.0
VARIABLE SBD_W_2_1	16.0
VARIABLE SBD_W_3	1.4
VARIABLE SBD_S_1	0.11
VARIABLE SBD_S_2	0.54
VARIABLE SBD_S_3	0.6
VARIABLE SBD_EX_1	0.09
VARIABLE SBD_O_1	0.09
VARIABLE SBD_O_2	0.4
VARIABLE SBD_R_1_1  2
VARIABLE SBD_R_1_2  1.18
VARIABLE SBD_N_1	16
VARIABLE SBD_L_1	1.0
VARIABLE SBD_L_2	0.32
VARIABLE SBDDMY_S_1 0.5
VARIABLE SBDDMY_EX_1    0




#IFNDEF DFM_ONLY
G.1:EHVTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID EHVTNi 5
}
G.1:EHVTPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID EHVTPi 5
}
G.1:ELVTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID ELVTNi 5
}
G.1:ELVTPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID ELVTPi 5
}
G.1:AVTi { @ grid must be an integer multiple of ^Grid um
  OFFGRID AVTi 5
}
G.1:ULP_WR { @ grid must be an integer multiple of ^Grid um
  OFFGRID ULP_WR 5
}
G.1:SRM_ULL { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM_ULL 5
}
G.1:LNP { @ grid must be an integer multiple of ^Grid um
  OFFGRID LNP 5
}
G.1:SERPDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID SERPDMY 5
}
G.1:ANALOG { @ grid must be an integer multiple of ^Grid um
  OFFGRID ANALOG 5
}
G.1:JDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID JDMY 5
}
G.1:JNW { @ grid must be an integer multiple of ^Grid um
  OFFGRID JNW 5
}
G.1:HVJDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVJDMY 5
}
G.1:JFETDMY_1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID JFETDMY_1 5
}
G.1:JFETDMY_2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID JFETDMY_2 5
}
G.1:JFETDMY_4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID JFETDMY_4 5
}
G.1:JFETDMY_5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID JFETDMY_5 5
}
G.1:FGDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID FGDDMY 5
}
G.1:SBDDMYi { @ grid must be an integer multiple of ^Grid um
  OFFGRID SBDDMYi 5
}
G.2:EHVTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT EHVTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EHVTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:EHVTPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT EHVTPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EHVTPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ELVTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ELVTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ELVTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ELVTPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ELVTPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ELVTPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:AVTi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT AVTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AVTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ULP_WR { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ULP_WR < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ULP_WR < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRM_ULL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM_ULL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM_ULL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LNP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LNP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LNP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SERPDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SERPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SERPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ANALOG { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ANALOG < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ANALOG < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JNW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JNW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JNW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:HVJDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVJDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVJDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JFETDMY_1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JFETDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JFETDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JFETDMY_2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JFETDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JFETDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JFETDMY_4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JFETDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JFETDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:JFETDMY_5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT JFETDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT JFETDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:FGDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FGDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FGDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SBDDMYi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SBDDMYi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SBDDMYi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.3:EHVTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE EHVTNi >0  <45
  ANGLE EHVTNi >45 <90
}
G.3:EHVTPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE EHVTPi >0  <45
  ANGLE EHVTPi >45 <90
}
G.3:ELVTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ELVTNi >0  <45
  ANGLE ELVTNi >45 <90
}
G.3:ELVTPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ELVTPi >0  <45
  ANGLE ELVTPi >45 <90
}
G.3:AVTi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE AVTi >0  <45
  ANGLE AVTi >45 <90
}
G.3:ULP_WR { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ULP_WR >0  <45
  ANGLE ULP_WR >45 <90
}
G.3:SRM_ULL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM_ULL >0  <45
  ANGLE SRM_ULL >45 <90
}
G.3:LNP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LNP >0  <45
  ANGLE LNP >45 <90
}
G.3:SERPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SERPDMY >0  <45
  ANGLE SERPDMY >45 <90
}
G.3:ANALOG { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ANALOG >0  <45
  ANGLE ANALOG >45 <90
}
G.3:JDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JDMY >0  <45
  ANGLE JDMY >45 <90
}
G.3:JNW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JNW >0  <45
  ANGLE JNW >45 <90
}
G.3:HVJDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVJDMY >0  <45
  ANGLE HVJDMY >45 <90
}
G.3:JFETDMY_1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JFETDMY_1 >0  <45
  ANGLE JFETDMY_1 >45 <90
}
G.3:JFETDMY_2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JFETDMY_2 >0  <45
  ANGLE JFETDMY_2 >45 <90
}
G.3:JFETDMY_4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JFETDMY_4 >0  <45
  ANGLE JFETDMY_4 >45 <90
}
G.3:JFETDMY_5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE JFETDMY_5 >0  <45
  ANGLE JFETDMY_5 >45 <90
}
G.3:FGDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FGDDMY >0  <45
  ANGLE FGDDMY >45 <90
}
G.3:SBDDMYi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SBDDMYi >0  <45
  ANGLE SBDDMYi >45 <90
}
G.4:EHVTNi { @ Adjacent edges with length less than min. width is not allowed.
  EHVTNia = EHVTNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH EHVTNia < EHVTN_W_1
  EHVTNi_ShortExp = EXPAND EDGE X BY 0.01
  EHVTNi_SmallJog = (VERTEX EHVTNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  EHVTNi INSIDE EDGE EHVTNi_SmallJog
}
G.4:EHVTPi { @ Adjacent edges with length less than min. width is not allowed.
  EHVTPia = EHVTPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH EHVTPia < EHVTP_W_1
  EHVTPi_ShortExp = EXPAND EDGE X BY 0.01
  EHVTPi_SmallJog = (VERTEX EHVTPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  EHVTPi INSIDE EDGE EHVTPi_SmallJog
}
G.4:ELVTNi { @ Adjacent edges with length less than min. width is not allowed.
  ELVTNia = ELVTNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH ELVTNia < ELVTN_W_1
  ELVTNi_ShortExp = EXPAND EDGE X BY 0.01
  ELVTNi_SmallJog = (VERTEX ELVTNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  ELVTNi INSIDE EDGE ELVTNi_SmallJog
}
G.4:ELVTPi { @ Adjacent edges with length less than min. width is not allowed.
  ELVTPia = ELVTPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH ELVTPia < ELVTP_W_1
  ELVTPi_ShortExp = EXPAND EDGE X BY 0.01
  ELVTPi_SmallJog = (VERTEX ELVTPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  ELVTPi INSIDE EDGE ELVTPi_SmallJog
}
#ENDIF // DFM_ONLY
//G.4.a is checked by G.4:EHVTNi, G.4:EHVTPi, G.4:ELVTNi, G.4:ELVTPi



//EHVT_N CHECKS
//============
EHVTN_R = COPY EHVTNs
// waive one track overlap 	  
EHVTN_A1 = INT EHVTNs < EHVTN_W_1 ABUT < 90 REGION PROJ==0
EHVTN_B1 = EHVTN_R NOT (EXPAND EDGE EHVTN_R INSIDE BY EHVTN_R_3/2)	
EHVTN_C1 = EXT EHVTN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
EHVTN_D1 = EHVTN_A1 ENCLOSE EHVTN_C1
// waive one track space
EHVTN_A2 = EXT EHVTNs < EHVTN_S_1 ABUT < 90 REGION PROJ==0
EHVTN_B2 = EHVTN_R OR (EXPAND EDGE EHVTN_R OUTSIDE BY EHVTN_R_3/2)
EHVTN_C2 = EXT EHVTN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
EHVTN_D2  = EHVTN_A2 ENCLOSE EHVTN_C2
// waive point touch
EHVTN_P = EXT EHVTN_R < EHVTN_S_1 SINGULAR INTERSECTING ONLY REGION

EHVT_N.W.1 { @ Width >= ^EHVTN_W_1. One-track(^EHVTN_R_3) overlap is allowed
  X = INT EHVTNs < EHVTN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT EHVTN_D1)) NOT INSIDE SRAM_EXCLUDE
}
EHVT_N.S.1 { @ Space >= ^EHVTN_S_1. Point touch of corners is allowed. One-track(^EHVTN_R_3) space is allowed.
  X = EXT EHVTNs < EHVTN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (EHVTN_D2 OR EHVTN_P))) NOT INSIDE SRAM_EXCLUDE
}
EHVT_N.S.2__EHVT_N.S.2.1 { @ Space to gate in PO endcap direction >= ^EHVTN_S_2 & in S/D direction >= ^EHVTN_S_2_1
  A = GATE NOT INTERACT EHVTN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (EHVTN_S_2_1 - EHVTN_S_2)) OR A
  C = SIZE B BY EHVTN_S_2
  EHVTN AND C
}

// EHVT_N.S.2 and EHVT_N.S.2.1 are checked by EHVT_N.S.2__EHVT_N.S.2.1
EHVT_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^EHVTN_S_3
  EXT EHVTN ODPO_RES_RPO < EHVTN_S_3 ABUT < 90 SINGULAR
  AND EHVTN ODPO_RES_RPO    
}  
EHVT_N.EN.1__EHVT_N.EN.2 { @ Enclosure of gate in S/D direction >= ^EHVTN_EN_1 & in PO endcap direction >= ^EHVTN_EN_2 
  A = GATE INTERACT EHVTN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (EHVTN_EN_1 - EHVTN_EN_2)) OR A
  C = SIZE B BY EHVTN_EN_2
  C NOT EHVTN
}
// EHVT_N.EN.1 and EHVT_N.EN.2 are checked by EHVT_N.EN.1__EHVT_N.EN.2
EHVT_N.A.1 { @ Area >= ^EHVTN_A_1
  (AREA EHVTNs < EHVTN_A_1) NOT INSIDE SRAM_EXCLUDE
}
EHVT_N.A.2 { @ Enclosed area >= ^EHVTN_A_2
  A = HOLES EHVTN INNER
  B = A NOT EHVTN
  AREA B < EHVTN_A_2
}
EHVT_N.R.1 { @ Overlap of P+ ACTIVE, VAR, VTH_N, VTL_N, ULVT_N, ELVT_N, VTH_P, VTL_P, ULVT_P, ELVT_P, EHVT_P, NT_N, TCDDMY, {OD AND NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed   
  EHVTN AND OD2
  EHVTN AND NTN
  EHVTN AND PACT
  EHVTN AND ELVTN
}
// EHVT_N.R.2 and EHVT_N.R.3 are checked by EHVT_N.W.1 and EHVT_N.S.1
EHVT_N.L.1 { @ 45-degree edge length >= ^EHVTN_L_1 um
  EHVTN_45ANGLE = EHVTN ANGLE == 45
  (LENGTH EHVTN_45ANGLE < EHVTN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

EHVTN_GATE = GATE INSIDE EHVTN
EHVTN_GATE_W = EHVTN_GATE INSIDE EDGE OD
EHVT_N.W.2 { @ Channel length of Gate [INSIDE EHVT_N] >= ^EHVTN_W_2
		INT EHVTN_GATE_W < EHVTN_W_2 ABUT < 90 REGION
}
EHVT_N.R.1:b { @ Overlap of N+ ACTIVE, VAR, VTH_P, VTL_P, ULVT_P, ELVT_P, VTH_N, VTL_N, ULVT_N, ELVT_N, EHVT_P, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed.
  EHVTN AND VAR
  EHVTN AND VTHN
  EHVTN AND VTLN
  EHVTN AND VTHP
  EHVTN AND VTLP
  EHVTN AND ULVT_N
  EHVTN AND ULVT_P
  EHVTN AND ELVTP
  EHVTN AND EHVTP
  EHVTN AND TCDDMY
  EHVTN AND (OD AND NWDMY)
  EHVTN AND (NP INTERACT NWDMY)
  EHVTN AND SRM
  EHVTN AND ROM
  EHVTN AND BJTDMY
  EHVTN AND RH
  EHVTN AND POFUSE
  EHVTN AND HVD_N
  EHVTN AND HVD_P
}
EHVTNR4_REGION = ((SRM OR SRAMDMY) OR EHVTNi) NOT RAM1TDMY
EHVTNR4_GATE = (GATEi NOT OUTSIDE EHVTNR4_REGION) OUTSIDE RODMY
EHVTNR4_GATE_W = POi COIN INSIDE EDGE EHVTNR4_GATE
EHVTNR4_GATE_W_V = EXPAND EDGE (ANGLE EHVTNR4_GATE_W == 90) INSIDE BY GRID
EHVTNR4_GATE_W_H = EXPAND EDGE (ANGLE EHVTNR4_GATE_W == 0) INSIDE BY GRID
EHVTNR4_BAD = (CHIP INTERACT EHVTNR4_GATE_W_V) INTERACT EHVTNR4_GATE_W_H
EHVT_N.R.4:V { @ Poly gates of all SRAM cells and EHVT_N devices ((50;0 OR 186;0) OR 93:1) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
	EHVTNR4_GATE_W_V AND EHVTNR4_BAD
}
EHVT_N.R.4:H { @ Poly gates of all SRAM cells and EHVT_N devices ((50;0 OR 186;0) OR 93:1) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
	EHVTNR4_GATE_W_H AND EHVTNR4_BAD
}


//EHVT_P CHECKS
//============

EHVTP_R = COPY EHVTPs
// waive one track overlap 	  
EHVTP_A1 = INT EHVTPs < EHVTP_W_1 ABUT < 90 REGION PROJ==0
EHVTP_B1 = EHVTP_R NOT (EXPAND EDGE EHVTP_R INSIDE BY EHVTP_R_3/2)	
EHVTP_C1 = EXT EHVTP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
EHVTP_D1 = EHVTP_A1 ENCLOSE EHVTP_C1
// waive one track space
EHVTP_A2 = EXT EHVTPs < EHVTP_S_1 ABUT < 90 REGION PROJ==0
EHVTP_B2 = EHVTP_R OR (EXPAND EDGE EHVTP_R OUTSIDE BY EHVTP_R_3/2)
EHVTP_C2 = EXT EHVTP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
EHVTP_D2  = EHVTP_A2 ENCLOSE EHVTP_C2
// waive point touch
EHVTP_P = EXT EHVTP_R < EHVTP_S_1 SINGULAR INTERSECTING ONLY REGION

EHVT_P.W.1 { @ Width >= ^EHVTP_W_1. One-track(^EHVTP_R_3) overlap is allowed
  X = INT EHVTPs < EHVTP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT EHVTP_D1)) NOT INSIDE SRAM_EXCLUDE
}
EHVT_P.S.1 { @ Space >= ^EHVTP_S_1. Point touch of corners is allowed. One-track(^EHVTP_R_3) space is allowed.
  X = EXT EHVTPs < EHVTP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (EHVTP_D2 OR EHVTP_P))) NOT INSIDE SRAM_EXCLUDE
}
EHVT_P.S.2__EHVT_P.S.2.1 { @ Space to gate in PO endcap direction >= ^EHVTP_S_2 & in S/D direction >= ^EHVTP_S_2_1
  A = GATE NOT INTERACT EHVTP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (EHVTP_S_2_1 - EHVTP_S_2)) OR A
  C = SIZE B BY EHVTP_S_2
  EHVTP AND C
}

// EHVT_P.S.2 and EHVT_P.S.2.1 are checked by EHVT_P.S.2__EHVT_P.S.2.1
EHVT_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^EHVTP_S_3
  EXT EHVTP ODPO_RES_RPO < EHVTP_S_3 ABUT < 90 SINGULAR
  AND EHVTP ODPO_RES_RPO    
}  
EHVT_P.EN.1__EHVT_P.EN.2 { @ Enclosure of gate in S/D direction >= ^EHVTP_EN_1 & in PO endcap direction >= ^EHVTP_EN_2 
  A = GATE INTERACT EHVTP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (EHVTP_EN_1 - EHVTP_EN_2)) OR A
  C = SIZE B BY EHVTP_EN_2
  C NOT EHVTP
}
// EHVT_P.EN.1 and EHVT_P.EN.2 are checked by EHVT_P.EN.1__EHVT_P.EN.2
EHVT_P.A.1 { @ Area >= ^EHVTP_A_1
  (AREA EHVTPs < EHVTP_A_1) NOT INSIDE SRAM_EXCLUDE
}
EHVT_P.A.2 { @ Enclosed area >= ^EHVTP_A_2
  A = HOLES EHVTP INNER
  B = A NOT EHVTP
  AREA B < EHVTP_A_2
}
EHVT_P.R.1 { @ Overlap of N+ ACTIVE, VAR, VTH_P, VTL_P, ULVT_P, ELVT_P, VTH_N, VTL_N, ULVT_N, ELVT_N, EHVT_N, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed   
  EHVTP AND OD2
  EHVTP AND NTN
  EHVTP AND NACT
  EHVTP AND ELVTP
}
// EHVT_P.R.2 and EHVT_P.R.3 are checked by EHVT_P.W.1 and EHVT_P.S.1
EHVT_P.L.1 { @ 45-degree edge length >= ^EHVTP_L_1 um
  EHVTP_45ANGLE = EHVTP ANGLE == 45
  (LENGTH EHVTP_45ANGLE < EHVTP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

EHVTP_GATE = GATE INSIDE EHVTP
EHVTP_GATE_W = EHVTP_GATE INSIDE EDGE OD
EHVT_P.W.2 { @ Channel length of Gate [INSIDE EHVT_P] >= ^EHVTP_W_2
		INT EHVTP_GATE_W < EHVTP_W_2 ABUT < 90 REGION
}
EHVT_P.R.1:b { @ Overlap of N+ ACTIVE, VAR, VTH_P, VTL_P, ULVT_P, ELVT_P, VTH_N, VTL_N, ULVT_N, ELVT_N, EHVT_N, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed.
  EHVTP AND VAR
  EHVTP AND VTHN
  EHVTP AND VTLN
  EHVTP AND VTHP
  EHVTP AND VTLP
  EHVTP AND ULVT_N
  EHVTP AND ULVT_P
  EHVTP AND ELVTN
  EHVTP AND EHVTN
  EHVTP AND TCDDMY
  EHVTP AND (OD AND NWDMY)
  EHVTP AND (NP INTERACT NWDMY)
  EHVTP AND SRM
  EHVTP AND ROM
  EHVTP AND BJTDMY
  EHVTP AND RH
  EHVTP AND POFUSE
  EHVTP AND HVD_N
  EHVTP AND HVD_P
}

EHVTPR4_REGION = ((SRM OR SRAMDMY) OR EHVTPi) NOT RAM1TDMY
EHVTPR4_GATE = (GATEi NOT OUTSIDE EHVTPR4_REGION) OUTSIDE RODMY
EHVTPR4_GATE_W = POi COIN INSIDE EDGE EHVTPR4_GATE
EHVTPR4_GATE_W_V = EXPAND EDGE (ANGLE EHVTPR4_GATE_W == 90) INSIDE BY GRID
EHVTPR4_GATE_W_H = EXPAND EDGE (ANGLE EHVTPR4_GATE_W == 0) INSIDE BY GRID
EHVTPR4_BAD = (CHIP INTERACT EHVTPR4_GATE_W_V) INTERACT EHVTPR4_GATE_W_H
EHVT_P.R.4:V { @ Poly gates of all SRAM cells and EHVT_P devices ((50;0 OR 186;0) OR 94:1) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
	EHVTPR4_GATE_W_V AND EHVTPR4_BAD
}
EHVT_P.R.4:H { @ Poly gates of all SRAM cells and EHVT_P devices ((50;0 OR 186;0) OR 94:1) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
	EHVTPR4_GATE_W_H AND EHVTPR4_BAD
}


//ELVT_N CHECKS
//============

ELVTN_R = COPY ELVTNs
// waive one track overlap 	  
ELVTN_A1 = INT ELVTNs < ELVTN_W_1 ABUT < 90 REGION PROJ==0
ELVTN_B1 = ELVTN_R NOT (EXPAND EDGE ELVTN_R INSIDE BY ELVTN_R_3/2)	
ELVTN_C1 = EXT ELVTN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ELVTN_D1 = ELVTN_A1 ENCLOSE ELVTN_C1
// waive one track space
ELVTN_A2 = EXT ELVTNs < ELVTN_S_1 ABUT < 90 REGION PROJ==0
ELVTN_B2 = ELVTN_R OR (EXPAND EDGE ELVTN_R OUTSIDE BY ELVTN_R_3/2)
ELVTN_C2 = EXT ELVTN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ELVTN_D2  = ELVTN_A2 ENCLOSE ELVTN_C2
// waive point touch
ELVTN_P = EXT ELVTN_R < ELVTN_S_1 SINGULAR INTERSECTING ONLY REGION

ELVT_N.W.1 { @ Width >= ^ELVTN_W_1. One-track(^ELVTN_R_3) overlap is allowed
  X = INT ELVTNs < ELVTN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ELVTN_D1)) NOT INSIDE SRAM_EXCLUDE
}
ELVT_N.S.1 { @ Space >= ^ELVTN_S_1. Point touch of corners is allowed. One-track(^ELVTN_R_3) space is allowed.
  X = EXT ELVTNs < ELVTN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ELVTN_D2 OR ELVTN_P))) NOT INSIDE SRAM_EXCLUDE
}
ELVT_N.S.2__ELVT_N.S.2.1 { @ Space to gate in PO endcap direction >= ^ELVTN_S_2 & in S/D direction >= ^ELVTN_S_2_1
  A = GATE NOT INTERACT ELVTN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ELVTN_S_2_1 - ELVTN_S_2)) OR A
  C = SIZE B BY ELVTN_S_2
  ELVTN AND C
}

// ELVT_N.S.2 and ELVT_N.S.2.1 are checked by ELVT_N.S.2__ELVT_N.S.2.1
ELVT_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^ELVTN_S_3
  EXT ELVTN ODPO_RES_RPO < ELVTN_S_3 ABUT < 90 SINGULAR
  AND ELVTN ODPO_RES_RPO    
}  
ELVT_N.EN.1__ELVT_N.EN.2 { @ Enclosure of gate in S/D direction >= ^ELVTN_EN_1 & in PO endcap direction >= ^ELVTN_EN_2 
  A = GATE INTERACT ELVTN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ELVTN_EN_1 - ELVTN_EN_2)) OR A
  C = SIZE B BY ELVTN_EN_2
  C NOT ELVTN
}
// ELVT_N.EN.1 and ELVT_N.EN.2 are checked by ELVT_N.EN.1__ELVT_N.EN.2
ELVT_N.A.1 { @ Area >= ^ELVTN_A_1
  (AREA ELVTNs < ELVTN_A_1) NOT INSIDE SRAM_EXCLUDE
}
ELVT_N.A.2 { @ Enclosed area >= ^ELVTN_A_2
  A = HOLES ELVTN INNER
  B = A NOT ELVTN
  AREA B < ELVTN_A_2
}
ELVT_N.R.1 { @ Overlap of P+ACTIVE, VAR, VTL_N, VTH_N, ULVT_N, EHVT_N, VTL_P, VTH_P, ULVT_P, EHVT_P, ELVT_P, NT_N, TCDDMY, {OD AND NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed   
  ELVTN AND OD2
  ELVTN AND NTN
  ELVTN AND PACT
  ELVTN AND EHVTN
}
// ELVT_N.R.2 and ELVT_N.R.3 are checked by ELVT_N.W.1 and ELVT_N.S.1
ELVT_N.L.1 { @ 45-degree edge length >= ^ELVTN_L_1 um
  ELVTN_45ANGLE = ELVTN ANGLE == 45
  (LENGTH ELVTN_45ANGLE < ELVTN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

ELVT_N.R.1:b { @ Overlap of N+ ACTIVE, VAR, VTH_P, VTL_P, ULVT_P, ELVT_P, VTH_N, VTL_N, ULVT_N, ELVT_P, EHVT_N, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed.
  ELVTN AND VAR
  ELVTN AND VTHN
  ELVTN AND VTLN
  ELVTN AND VTHP
  ELVTN AND VTLP
  ELVTN AND ULVT_N
  ELVTN AND ULVT_P
  ELVTN AND EHVTP
  ELVTN AND ELVTP
  ELVTN AND TCDDMY
  ELVTN AND (OD AND NWDMY)
  ELVTN AND SRM
  ELVTN AND ROM
  ELVTN AND BJTDMY
  ELVTN AND RH
  ELVTN AND POFUSE
  ELVTN AND HVD_N
  ELVTN AND HVD_P
}


//ELVL_P CHECKS
//============

ELVTP_R = COPY ELVTPs
// waive one track overlap 	  
ELVTP_A1 = INT ELVTPs < ELVTP_W_1 ABUT < 90 REGION PROJ==0
ELVTP_B1 = ELVTP_R NOT (EXPAND EDGE ELVTP_R INSIDE BY ELVTP_R_3/2)	
ELVTP_C1 = EXT ELVTP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ELVTP_D1 = ELVTP_A1 ENCLOSE ELVTP_C1
// waive one track space
ELVTP_A2 = EXT ELVTPs < ELVTP_S_1 ABUT < 90 REGION PROJ==0
ELVTP_B2 = ELVTP_R OR (EXPAND EDGE ELVTP_R OUTSIDE BY ELVTP_R_3/2)
ELVTP_C2 = EXT ELVTP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ELVTP_D2  = ELVTP_A2 ENCLOSE ELVTP_C2
// waive point touch
ELVTP_P = EXT ELVTP_R < ELVTP_S_1 SINGULAR INTERSECTING ONLY REGION

ELVT_P.W.1 { @ Width >= ^ELVTP_W_1. One-track(^ELVTP_R_3) overlap is allowed
  X = INT ELVTPs < ELVTP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ELVTP_D1)) NOT INSIDE SRAM_EXCLUDE
}
ELVT_P.S.1 { @ Space >= ^ELVTP_S_1. Point touch of corners is allowed. One-track(^ELVTP_R_3) space is allowed.
  X = EXT ELVTPs < ELVTP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ELVTP_D2 OR ELVTP_P))) NOT INSIDE SRAM_EXCLUDE
}
ELVT_P.S.2__ELVT_P.S.2.1 { @ Space to gate in PO endcap direction >= ^ELVTP_S_2 & in S/D direction >= ^ELVTP_S_2_1
  A = GATE NOT INTERACT ELVTP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ELVTP_S_2_1 - ELVTP_S_2)) OR A
  C = SIZE B BY ELVTP_S_2
  ELVTP AND C
}

// ELVT_P.S.2 and ELVT_P.S.2.1 are checked by ELVT_P.S.2__ELVT_P.S.2.1
ELVT_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^ELVTP_S_3
  EXT ELVTP ODPO_RES_RPO < ELVTP_S_3 ABUT < 90 SINGULAR
  AND ELVTP ODPO_RES_RPO    
}  
ELVT_P.EN.1__ELVT_P.EN.2 { @ Enclosure of gate in S/D direction >= ^ELVTP_EN_1 & in PO endcap direction >= ^ELVTP_EN_2 
  A = GATE INTERACT ELVTP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (ELVTP_EN_1 - ELVTP_EN_2)) OR A
  C = SIZE B BY ELVTP_EN_2
  C NOT ELVTP
}
// ELVT_P.EN.1 and ELVT_P.EN.2 are checked by ELVT_P.EN.1__ELVT_P.EN.2
ELVT_P.A.1 { @ Area >= ^ELVTP_A_1
  (AREA ELVTPs < ELVTP_A_1) NOT INSIDE SRAM_EXCLUDE
}
ELVT_P.A.2 { @ Enclosed area >= ^ELVTP_A_2
  A = HOLES ELVTP INNER
  B = A NOT ELVTP
  AREA B < ELVTP_A_2
}
ELVT_P.R.1 { @ Overlap of N+ACTIVE, VAR, VTL_P, VTH_P, ULVT_P, EHVT_P, VTL_N, VTH_N, ULVT_N, EHVT_N, ELVT_N, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed   
  ELVTP AND OD2
  ELVTP AND NTN
  ELVTP AND NACT
  ELVTP AND EHVTP
}
// ELVT_P.R.2 and ELVT_P.R.3 are checked by ELVT_P.W.1 and ELVT_P.S.1
ELVT_P.L.1 { @ 45-degree edge length >= ^ELVTP_L_1 um
  ELVTP_45ANGLE = ELVTP ANGLE == 45
  (LENGTH ELVTP_45ANGLE < ELVTP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

ELVT_P.R.1:b { @ Overlap of N+ ACTIVE, VAR, VTH_P, VTL_P, ULVT_P, EHVT_P, VTH_N, VTL_N, ULVT_N, ELVT_N, EHVT_N, NT_N, TCDDMY, {OD AND NWDMY}, {NP INTERACT NWDMY}, SRM, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed.
  ELVTP AND VAR
  ELVTP AND VTHN
  ELVTP AND VTLN
  ELVTP AND VTHP
  ELVTP AND VTLP
  ELVTP AND ULVT_N
  ELVTP AND ULVT_P
  ELVTP AND EHVTN
  ELVTP AND ELVTN
  ELVTP AND TCDDMY
  ELVTP AND (OD AND NWDMY)
  ELVTP AND SRM
  ELVTP AND ROM
  ELVTP AND BJTDMY
  ELVTP AND RH
  ELVTP AND POFUSE
  ELVTP AND HVD_N
  ELVTP AND HVD_P
}

//DEFINED HERE FOR WAIVE RECOMMENDED RULES.
PJFET_4V_DMY = HVJDMY INTERACT JNW  
NJFET_4V_DMY = HVJDMY NOT INTERACT JNW

#IFNDEF DFM_ONLY
#IFDEF FRONT_END




    













// Low Noise Pad Layout Rules
//=====================

PJFET_PO_2d5V_DMY = JDMY INTERACT JNW
NJFET_PO_2d5V_DMY = JDMY NOT INTERACT JNW
JFET_PO_2d5V_DEVICE_REGION = ANALOG INTERACT JDMY
JFET_PO_2d5V_DEVICE_REGION_OD25 = OD25 INTERACT JDMY
JFET_PO_2d5V_ACT_OD = (OD INTERACT POLY) AND (JDMY INTERACT ANALOG)
JFET_PO_2d5V_PSUB_RING = ((PP AND OD) NOT JDMY) AND JFET_PO_2d5V_DEVICE_REGION 
JFET_PO_2d5V_PSUB_RING_H = (HOLES JFET_PO_2d5V_PSUB_RING) ENCLOSE JDMY
JFET_4V_PSUB_RING = ((PP AND OD) NOT DNW) AND HVJDMY
JFET_NW_R_PRE = DONUT (NWEL INTERACT (JFET_PO_2d5V_DEVICE_REGION OR NJFET_4V_DMY))
JFET_4V_PSUB_RING_H = HOLES JFET_4V_PSUB_RING INNER


// 2.5V PJFET
PJFET_PO_2d5V_OD_GATE_CO = (((CO AND OD) INSIDE NP) NOT INTERACT POLY) AND PJFET_PO_2d5V_DMY
PJFET_PO_2d5V_SD_OD = ((OD NOT RPO) INSIDE PP) AND PJFET_PO_2d5V_DMY
PJFET_PO_2d5V_ACT_PP = (PP INTERACT RPO) AND PJFET_PO_2d5V_DMY
PJFET_PO_2d5V_PO = POLY AND PJFET_PO_2d5V_DMY
PJFET_PO_2d5V_NP = (NP INTERACT RPO) AND PJFET_PO_2d5V_DMY
PJFET_PO_2d5V_RPO = RPO AND PJFET_PO_2d5V_DMY

// 2.5V NJFET
NJFET_PO_2d5V_OD_GATE_CO = (((CO AND OD) INSIDE PP) NOT INTERACT POLY) AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_SD_OD = ((OD NOT RPO) INSIDE NP) AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_ACT_NP = (NP INTERACT RPO) AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_PP = (PP INTERACT RPO) AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_RPO = RPO AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_ISO_RING = ((NP AND OD) AND NWEL) AND JFET_PO_2d5V_DEVICE_REGION
NJFET_PO_2d5V_PO = POLY AND NJFET_PO_2d5V_DMY
NJFET_PO_2d5V_NW_H = (HOLES JFET_NW_R_PRE INNER) ENCLOSE NJFET_PO_2d5V_OD_GATE_CO
NJFET_PO_2d5V_NW_R = JFET_NW_R_PRE TOUCH NJFET_PO_2d5V_NW_H
NJFET_PO_2d5V_DNW = DNW AND JFET_PO_2d5V_DEVICE_REGION

// 4V NJFET
NJFET_4V_D_OD = ((NP AND OD) AND JFETDMY_1) AND NJFET_4V_DMY
NJFET_4V_GATE_OD = ((PP AND OD) AND DNW) AND NJFET_4V_DMY
NJFET_4V_SOURCE_RING = ((NP AND OD) NOT JFETDMY_1) AND NJFET_4V_DMY
NJFET_4V_SOURCE_RING_H = HOLES NJFET_4V_SOURCE_RING INNER
NJFET_4V_NW_H = (HOLES JFET_NW_R_PRE INNER) ENCLOSE NJFET_4V_GATE_OD
NJFET_4V_NW_R = JFET_NW_R_PRE TOUCH NJFET_4V_NW_H
NJFET_4V_NW_R_ALL = NJFET_4V_NW_R OR NJFET_4V_NW_H
NJFET_4V_NW_JFETDMY = NWEL INSIDE JFETDMY_1
NJFET_4V_NW_JFETDMY_INT = NWEL INTERACT JFETDMY_1
NJFET_4V_NW_DNW = DNW AND NJFET_4V_DMY
NJFET_4V_JFETDMY2 = JFETDMY_2 AND NJFET_4V_DMY
NJFET_4V_JFETDMY2_H = HOLES JFETDMY_2 INNER
NJFET_4V_JFETDMY1 = JFETDMY_1 AND NJFET_4V_DMY
NJFET_4V_JFETDMY4 = JFETDMY_4 AND NJFET_4V_DMY
NJFET_4V_OD25 = OD25 AND NJFET_4V_DMY


// 4V PJFET
PJFET_4V_D_OD = (((PP AND OD ) AND DNW) NOT INTERACT RPO) AND PJFET_4V_DMY
PJFET_4V_SOURCE_OD = (((PP AND OD ) AND DNW) INTERACT RPO) AND PJFET_4V_DMY
PJFET_4V_GATE_OD = ((NP AND OD) AND JNW) AND PJFET_4V_DMY
PJFET_4V_GATE_RING = ((NP AND OD) NOT JNW) AND PJFET_4V_DMY
PJFET_4V_RPO = RPO AND PJFET_4V_DMY
PJFET_4V_NW_R_PRE = NWEL NOT (NWEL AND JNW)
PJFET_4V_NW_H = (HOLES PJFET_4V_NW_R_PRE INNER) ENCLOSE PJFET_4V_GATE_OD
PJFET_4V_NW_R = PJFET_4V_NW_R_PRE TOUCH PJFET_4V_NW_H 
PJFET_4V_JNW = JNW AND PJFET_4V_DMY
PJFET_4V_DNW = DNW AND PJFET_4V_DMY
PJFET_4V_JFETDMY5 = JFETDMY_5 AND PJFET_4V_DMY
PJFET_4V_GATE_RING_H = HOLES PJFET_4V_GATE_RING INNER
PJFET_4V_OD25 = OD25 AND PJFET_4V_DMY

// 2.5V_PO_PJFET DEVICES CHECK 
///============================
ANALOG.EN.1:2.5V_PO_PJFET { @ Enclosure of ANALOG beyond 2.5V_PO_JFET PSUB RING [outer edge] == ^ANALOG_EN_1 um
    JFET_PO_2d5V_PSUB_RING_CHECK =  JFET_PO_2d5V_PSUB_RING INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_H_CHECK = JFET_PO_2d5V_PSUB_RING_H INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_DEVICE_REGION_CHECK = JFET_PO_2d5V_DEVICE_REGION INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_CHECK_FILL = JFET_PO_2d5V_PSUB_RING_CHECK OR JFET_PO_2d5V_PSUB_RING_H_CHECK
    JFET_PO_2d5V_PSUB_RING_CHECK_SIZE = SIZE JFET_PO_2d5V_PSUB_RING_CHECK_FILL BY ANALOG_EN_1 
    JFET_PO_2d5V_DEVICE_REGION_CHECK XOR JFET_PO_2d5V_PSUB_RING_CHECK_SIZE
}

OD_25.EN.1:2.5V_PO_PJFET { @ Enclosure of OD_25 beyond 2.5V_PO_JFET PSUB RING [outer edge] == ^OD_25_EN_1 um
    JFET_PO_2d5V_PSUB_RING_CHECK =  JFET_PO_2d5V_PSUB_RING INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_H_CHECK = JFET_PO_2d5V_PSUB_RING_H INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_DEVICE_REGION_OD25_CHECK = JFET_PO_2d5V_DEVICE_REGION_OD25 INTERACT (ANALOG INTERACT PJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_CHECK_FILL = JFET_PO_2d5V_PSUB_RING_CHECK OR JFET_PO_2d5V_PSUB_RING_H_CHECK
    JFET_PO_2d5V_PSUB_RING_CHECK_SIZE = SIZE JFET_PO_2d5V_PSUB_RING_CHECK_FILL BY OD_25_EN_1 
    JFET_PO_2d5V_DEVICE_REGION_OD25_CHECK XOR JFET_PO_2d5V_PSUB_RING_CHECK_SIZE
}

JDMY.EN.1:2.5V_PO_PJFET { @ Enclosure of JDMY beyond JNW == ^JDMY_EN_1 um
    JNW_CHECK = JNW INTERACT JDMY
    PJFET_PO_2d5V_DMY XOR JNW_CHECK
}

JNW.S.1:2.5V_PO_PJFET { @ Space of JNW to 2.5V_PO_JFET PSUB RING == ^JNW_S_1 um
    JNW_CHECK = JNW INTERACT JDMY
    JFET_PO_2d5V_PSUB_RING_H_PJFET = JFET_PO_2d5V_PSUB_RING_H ENCLOSE PJFET_PO_2d5V_SD_OD
    JFET_PO_2d5V_PSUB_RING_PJFET = JFET_PO_2d5V_PSUB_RING INTERACT JFET_PO_2d5V_PSUB_RING_H_PJFET
    JNW_CHECK_SIZE = SIZE JNW_CHECK BY JNW_S_1
    JFET_PO_2d5V_PSUB_RING_PJFET_HOLE = HOLES JFET_PO_2d5V_PSUB_RING_PJFET INNER
    JFET_PO_2d5V_PSUB_RING_PJFET_HOLE XOR JNW_CHECK_SIZE
    NOT RECTANGLE JNW_CHECK_SIZE 
}

JNW.EN.1:2.5V_PO_PJFET { @ Enclosure of JNW beyond 2.5V_PO_JFET ACTIVE OD == ^JNW_EN_1 um
    JNW_CHECK = JNW INTERACT JDMY
    JFET_PO_2d5V_ACT_OD_SIZE = SIZE JFET_PO_2d5V_ACT_OD BY POJ_P_S_4/2 OVERUNDER
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD_SIZE AND PJFET_PO_2d5V_DMY
    JFET_PO_2d5V_ACT_OD_CHECK_SIZE = SIZE JFET_PO_2d5V_ACT_OD_CHECK BY JNW_EN_1
    JFET_PO_2d5V_ACT_OD_CHECK_SIZE XOR JNW_CHECK
    NOT RECTANGLE JFET_PO_2d5V_ACT_OD_CHECK
    NOT RECTANGLE JNW_CHECK
}

POJ_P.W.1:2.5V_PO_PJFET { @ Width of 2.5V_PO_PJFET ACTIVE PP in channel width direction >= ^POJ_P_W_1 um
    NOT RECTANGLE PJFET_PO_2d5V_ACT_PP
    PJFET_PO_2d5V_ACT_PP INSIDE OD
    PJFET_PO_2d5V_ACT_PP_CHECK_pre = PJFET_PO_2d5V_ACT_PP NOT OD
    PJFET_PO_2d5V_ACT_PP_CHECK = PJFET_PO_2d5V_ACT_PP_CHECK_pre COIN OUTSIDE EDGE OD
    LENGTH PJFET_PO_2d5V_ACT_PP_CHECK < POJ_P_W_1
}

POJ_P.W.2:2.5V_PO_PJFET { @ Width of 2.5V_PO_JFET PSUB RING == ^POJ_P_W_2 um
    INT JFET_PO_2d5V_PSUB_RING < POJ_P_W_2 ABUT < 90 SINGULAR REGION
    SIZE JFET_PO_2d5V_PSUB_RING BY POJ_P_W_2/2 UNDEROVER
}

POJ_P.W.3:2.5V_PO_PJFET { @ Width of PO in channel length direction >= ^POJ_P_W_3 um
    PJFET_PO_2d5V_PO_EXP = EXPAND EDGE PJFET_PO_2d5V_PO OUTSIDE BY GRID
    PJFET_PO_2d5V_PO_pre = PJFET_PO_2d5V_PO_EXP INSIDE RPO
    PJFET_PO_2d5V_PO_CHK_pre = PJFET_PO_2d5V_PO_EXP NOT PJFET_PO_2d5V_PO_pre
    PJFET_PO_2d5V_PO_CHK = PJFET_PO_2d5V_PO_CHK_pre COIN OUTSIDE EDGE PJFET_PO_2d5V_PO
    LENGTH PJFET_PO_2d5V_PO_CHK < POJ_P_W_3 
}

POJ_P.S.1:2.5V_PO_PJFET { @ Space of CO to RPO >= ^POJ_P_S_1 um
    EXT CO PJFET_PO_2d5V_RPO < POJ_P_S_1 ABUT < 90 SINGULAR REGION
}

POJ_P.S.2:2.5V_PO_PJFET { @ Space of CO ON 2.5V_PO_PJFET GATE OD to PO == ^POJ_P_S_2 um
    PJFET_PO_2d5V_OD_GATE_CO_SIZE = SIZE PJFET_PO_2d5V_OD_GATE_CO BY POJ_P_S_2
    PJFET_PO_2d5V_OD_GATE_CO_SIZE NOT TOUCH PJFET_PO_2d5V_PO
    NOT RECTANGLE PJFET_PO_2d5V_OD_GATE_CO
    NOT RECTANGLE PJFET_PO_2d5V_PO
}

POJ_P.S.3:2.5V_PO_PJFET { @ Space of 2.5V_PO_PJFET SOURCE / DRAIN OD to PO == ^POJ_P_S_3 um
    PJFET_PO_2d5V_SD_OD_SIZE = SIZE PJFET_PO_2d5V_SD_OD BY POJ_P_S_3
    PJFET_PO_2d5V_SD_OD_SIZE NOT TOUCH PJFET_PO_2d5V_PO
    NOT RECTANGLE PJFET_PO_2d5V_SD_OD
    NOT RECTANGLE PJFET_PO_2d5V_PO
}

POJ_P.S.4:2.5V_PO_PJFET { @ Space of 2.5V_PO_JFET ACTIVE OD == ^POJ_P_S_4 um
    EXT JFET_PO_2d5V_ACT_OD < POJ_P_S_4 ABUT < 90 SINGULAR REGION
    JFET_PO_2d5V_ACT_OD_SIZE = SIZE JFET_PO_2d5V_ACT_OD BY POJ_P_S_4/2 OVERUNDER
    NOT RECTANGLE JFET_PO_2d5V_ACT_OD_SIZE
    JDMY INTERACT JFET_PO_2d5V_ACT_OD_SIZE > 1
}

POJ_P.EN.1:2.5V_PO_PJFET { @ Enclosure of 2.5V_PO_JFET ACTIVE OD beyond PO in channel width direction == ^POJ_P_EN_1 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND PJFET_PO_2d5V_DMY
    PJFET_PO_2d5V_PO_EXP_pre = EXPAND EDGE PJFET_PO_2d5V_PO OUTSIDE BY POJ_P_EN_1
    PJFET_PO_2d5V_PO_EXP = PJFET_PO_2d5V_PO_EXP_pre INTERACT NP
    PJFET_PO_2d5V_PO_EDGE = PJFET_PO_2d5V_PO COIN OUTSIDE EDGE PJFET_PO_2d5V_PO_EXP
    PJFET_PO_2d5V_PO_EDGE_EXP1 = EXPAND EDGE PJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_P_EN_1
    PJFET_PO_2d5V_PO_EDGE_EXP2 = EXPAND EDGE PJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_P_EN_1 + GRID
    PJFET_PO_2d5V_PO_CHECK = (PJFET_PO_2d5V_PO_EDGE_EXP2 NOT PJFET_PO_2d5V_PO_EDGE_EXP1) TOUCH EDGE PJFET_PO_2d5V_PO_EDGE_EXP1
    PJFET_PO_2d5V_PO_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD_CHECK 

}

POJ_P.EN.2:2.5V_PO_PJFET { @ Enclosure of 2.5V_PO_JFET ACTIVE OD beyond PO in channel length direction == ^POJ_P_EN_2 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND PJFET_PO_2d5V_DMY
    PJFET_PO_2d5V_PO_EXP_pre = EXPAND EDGE PJFET_PO_2d5V_PO OUTSIDE BY POJ_P_EN_2
    PJFET_PO_2d5V_PO_EXP = PJFET_PO_2d5V_PO_EXP_pre INTERACT PP
    PJFET_PO_2d5V_PO_EDGE = PJFET_PO_2d5V_PO COIN OUTSIDE EDGE PJFET_PO_2d5V_PO_EXP
    PJFET_PO_2d5V_PO_EDGE_EXP1 = EXPAND EDGE PJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_P_EN_2
    PJFET_PO_2d5V_PO_EDGE_EXP2 = EXPAND EDGE PJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_P_EN_2 + GRID
    PJFET_PO_2d5V_PO_CHECK = (PJFET_PO_2d5V_PO_EDGE_EXP2 NOT PJFET_PO_2d5V_PO_EDGE_EXP1) TOUCH EDGE PJFET_PO_2d5V_PO_EDGE_EXP1
    PJFET_PO_2d5V_PO_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD_CHECK
    
}

POJ_P.EX.1:2.5V_PO_PJFET { @ Extension of RPO beyond 2.5V_PO_JFET ACTIVE OD == ^POJ_P_EX_1 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND PJFET_PO_2d5V_DMY
    PJFET_PO_2d5V_ACT_PP_SIZE_PRE = SIZE PJFET_PO_2d5V_ACT_PP BY (POJ_P_EX_1 - POJ_P_EX_3)
    PJFET_PO_2d5V_ACT_PP_SIZE = PJFET_PO_2d5V_ACT_PP_SIZE_PRE NOT PJFET_PO_2d5V_RPO
    PJFET_PO_2d5V_NP_SIZE_PRE = SIZE PJFET_PO_2d5V_NP BY (POJ_P_EX_1 - POJ_P_EX_4)
    PJFET_PO_2d5V_NP_SIZE = PJFET_PO_2d5V_NP_SIZE_PRE NOT PJFET_PO_2d5V_RPO
    PJFET_PO_2d5V_RPO_REC = (PJFET_PO_2d5V_RPO OR PJFET_PO_2d5V_ACT_PP_SIZE) OR PJFET_PO_2d5V_NP_SIZE
    NOT RECTANGLE PJFET_PO_2d5V_RPO_REC
    JFET_PO_2d5V_ACT_OD_CHECK_SIZE = SIZE JFET_PO_2d5V_ACT_OD_CHECK BY POJ_P_EX_1
    PJFET_PO_2d5V_RPO_REC XOR JFET_PO_2d5V_ACT_OD_CHECK_SIZE
}

POJ_P.EX.2:2.5V_PO_PJFET { @ Extension of 2.5V_PO_JFET ACTIVE OD beyond 2.5V_PO_PJFET ACTIVE PP in channel width direction == ^POJ_P_EX_2 um
    ACT_PP_PRE_1 = PJFET_PO_2d5V_ACT_PP NOT JFET_PO_2d5V_ACT_OD
    ACT_PP_PRE_2 = PJFET_PO_2d5V_ACT_PP NOT ACT_PP_PRE_1
    PJFET_PO_2d5V_PO_CHECK1 = SIZE PJFET_PO_2d5V_PO BY POJ_P_S_3 - POJ_P_O_1
    EDGE_CHECK = ACT_PP_PRE_2 NOT COIN OUTSIDE EDGE (ACT_PP_PRE_1 OR PJFET_PO_2d5V_PO_CHECK1)
    EDGE_CHECK_SIZE_1 = EXPAND EDGE EDGE_CHECK OUTSIDE BY POJ_P_EX_2
    EDGE_CHECK_SIZE_2 = EXPAND EDGE EDGE_CHECK OUTSIDE BY POJ_P_EX_2+GRID
    EDGE_CHECK_CHECK = (EDGE_CHECK_SIZE_2 NOT EDGE_CHECK_SIZE_1) TOUCH EDGE EDGE_CHECK_SIZE_1
    EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD

}

POJ_P.EX.3:2.5V_PO_PJFET { @ Extension of 2.5V_PO_PJFET ACTIVE PP beyond 2.5V_PO_JFET ACTIVE OD in channel length direction == ^POJ_P_EX_3 um
    OD_EDGE_CHECK = JFET_PO_2d5V_ACT_OD INSIDE EDGE PJFET_PO_2d5V_ACT_PP
    PJFET_PO_2d5V_ACT_PP INSIDE JFET_PO_2d5V_ACT_OD
    OD_EDGE_CHECK_SIZE_1 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_P_EX_3
    OD_EDGE_CHECK_SIZE_2 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_P_EX_3+GRID
    OD_EDGE_CHECK_CHECK = (OD_EDGE_CHECK_SIZE_2 NOT OD_EDGE_CHECK_SIZE_1) TOUCH EDGE OD_EDGE_CHECK_SIZE_1
    OD_EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE PJFET_PO_2d5V_ACT_PP
}

POJ_P.EX.4:2.5V_PO_PJFET { @ Extension of NP beyond 2.5V_PO_JFET ACTIVE OD in channel width direction == ^POJ_P_EX_4 um
    OD_EDGE_CHECK = JFET_PO_2d5V_ACT_OD INSIDE EDGE PJFET_PO_2d5V_NP
    PJFET_PO_2d5V_NP INSIDE JFET_PO_2d5V_ACT_OD
    OD_EDGE_CHECK_SIZE_1 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_P_EX_4
    OD_EDGE_CHECK_SIZE_2 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_P_EX_4+GRID
    OD_EDGE_CHECK_CHECK = (OD_EDGE_CHECK_SIZE_2 NOT OD_EDGE_CHECK_SIZE_1) TOUCH EDGE OD_EDGE_CHECK_SIZE_1
    OD_EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE PJFET_PO_2d5V_NP
}

POJ_P.O.1:2.5V_PO_PJFET { @ Overlap of 2.5V_PO_PJFET ACTIVE PP and RPO == ^POJ_P_O_1 um
    OVERLAP_CHECK = PJFET_PO_2d5V_ACT_PP AND PJFET_PO_2d5V_RPO
    INT OVERLAP_CHECK < POJ_P_O_1 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_P_O_1 / 2) UNDEROVER 
}

POJ_P.O.2:2.5V_PO_PJFET { @ Overlap of NP and RPO in channel length direction == ^POJ_P_O_2 um
    OVERLAP_CHECK = PJFET_PO_2d5V_NP AND PJFET_PO_2d5V_RPO
    INT OVERLAP_CHECK < POJ_P_O_2 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_P_O_2 / 2) UNDEROVER 
}

POJ_P.O.3:2.5V_PO_PJFET { @ Overlap of RPO and PO in channel length direction == ^POJ_P_O_3 um
    OVERLAP_CHECK = PJFET_PO_2d5V_RPO AND PJFET_PO_2d5V_PO
    INT OVERLAP_CHECK < POJ_P_O_3 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_P_O_3 / 2) UNDEROVER 
}

POJ_P.R.1:2.5V_PO_PJFET { @ {{PO NOT NP} AND {JDNW INTERACT JNW}} NOT INSIDE RPO is not allowed 
    ((POLY NOT NP) AND PJFET_PO_2d5V_DMY) NOT INSIDE RPO
}
// JDMY.R.1U:2.5V_PO_PJFET is uncheckable


// 2.5V_PO_NJFET DEVICES CHECK 
///============================

ANALOG.EN.1:2.5V_PO_NJFET { @ Enclosure of ANALOG beyond 2.5V_PO_JFET PSUB RING [outer edge] == ^ANALOG_EN_1 um
    JFET_PO_2d5V_PSUB_RING_CHECK =  JFET_PO_2d5V_PSUB_RING INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_H_CHECK = JFET_PO_2d5V_PSUB_RING_H INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_DEVICE_REGION_CHECK = JFET_PO_2d5V_DEVICE_REGION INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_CHECK_FILL = JFET_PO_2d5V_PSUB_RING_CHECK OR JFET_PO_2d5V_PSUB_RING_H_CHECK
    JFET_PO_2d5V_PSUB_RING_CHECK_SIZE = SIZE JFET_PO_2d5V_PSUB_RING_CHECK_FILL BY ANALOG_EN_1 
    JFET_PO_2d5V_DEVICE_REGION_CHECK XOR JFET_PO_2d5V_PSUB_RING_CHECK_SIZE
}

JDMY.S.1:2.5V_PO_NJFET { @ Space of JDMY to NWEL RING (butted is must) == ^JDMY_S_1 um
    NOT RECTANGLE NJFET_PO_2d5V_DMY
    NJFET_PO_2d5V_NW_R_HOLE = HOLES NJFET_PO_2d5V_NW_R INNER
    NJFET_PO_2d5V_DMY XOR NJFET_PO_2d5V_NW_R_HOLE
}

OD_25.EN.1:2.5V_PO_NJFET { @ Enclosure of OD_25 beyond 2.5V_PO_JFET PSUB RING [outer edge] == ^OD_25_EN_1 um
    JFET_PO_2d5V_PSUB_RING_CHECK =  JFET_PO_2d5V_PSUB_RING INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_H_CHECK = JFET_PO_2d5V_PSUB_RING_H INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_DEVICE_REGION_OD25_CHECK = JFET_PO_2d5V_DEVICE_REGION_OD25 INTERACT (ANALOG INTERACT NJFET_PO_2d5V_DMY)
    JFET_PO_2d5V_PSUB_RING_CHECK_FILL = JFET_PO_2d5V_PSUB_RING_CHECK OR JFET_PO_2d5V_PSUB_RING_H_CHECK
    JFET_PO_2d5V_PSUB_RING_CHECK_SIZE = SIZE JFET_PO_2d5V_PSUB_RING_CHECK_FILL BY OD_25_EN_1 
    JFET_PO_2d5V_DEVICE_REGION_OD25_CHECK XOR JFET_PO_2d5V_PSUB_RING_CHECK_SIZE
}

POJ_N.W.1:2.5V_PO_NJFET { @ Width of 2.5V_PO_NJFET ACTIVE NP in channel width direction >= ^POJ_N_W_1 um
    NOT RECTANGLE NJFET_PO_2d5V_ACT_NP
    NJFET_PO_2d5V_ACT_NP INSIDE OD
    NJFET_PO_2d5V_ACT_NP_CHECK_pre = NJFET_PO_2d5V_ACT_NP NOT OD
    NJFET_PO_2d5V_ACT_NP_CHECK = NJFET_PO_2d5V_ACT_NP_CHECK_pre COIN OUTSIDE EDGE OD
    LENGTH NJFET_PO_2d5V_ACT_NP_CHECK < POJ_N_W_1
}

POJ_N.W.2:2.5V_PO_NJFET { @ Width of 2.5V_PO_NJFET ISO RING == ^POJ_N_W_2 um
    INT NJFET_PO_2d5V_ISO_RING < POJ_N_W_2 ABUT < 90 SINGULAR REGION
    SIZE NJFET_PO_2d5V_ISO_RING BY POJ_N_W_2/2 UNDEROVER
}

POJ_N.W.3:2.5V_PO_NJFET { @ Width of 2.5V PO JFET PSUB RING == ^POJ_N_W_3 um
    INT JFET_PO_2d5V_PSUB_RING < POJ_N_W_3 ABUT < 90 SINGULAR REGION
    SIZE JFET_PO_2d5V_PSUB_RING BY POJ_N_W_3/2 UNDEROVER
}

POJ_N.W.4:2.5V_PO_NJFET { @ Width of PO in channel length direction >= ^POJ_N_W_4 um
    NJFET_PO_2d5V_PO_EXP = EXPAND EDGE NJFET_PO_2d5V_PO OUTSIDE BY GRID
    NJFET_PO_2d5V_PO_pre = NJFET_PO_2d5V_PO_EXP INSIDE RPO
    NJFET_PO_2d5V_PO_CHK_pre = NJFET_PO_2d5V_PO_EXP NOT NJFET_PO_2d5V_PO_pre
    NJFET_PO_2d5V_PO_CHK = NJFET_PO_2d5V_PO_CHK_pre COIN OUTSIDE EDGE NJFET_PO_2d5V_PO
    LENGTH NJFET_PO_2d5V_PO_CHK < POJ_N_W_4 
}

POJ_N.S.1:2.5V_PO_NJFET { @ Space of NWEL RING to 2.5V PO JFET PSUB RING == ^POJ_N_S_1 um
    JFET_PO_2d5V_PSUB_RING_H_NJFET = JFET_PO_2d5V_PSUB_RING_H ENCLOSE NJFET_PO_2d5V_SD_OD
    JFET_PO_2d5V_PSUB_RING_NJFET = JFET_PO_2d5V_PSUB_RING INTERACT JFET_PO_2d5V_PSUB_RING_H_NJFET
    NJFET_PO_2d5V_NW_R_SIZE_H = HOLES NJFET_PO_2d5V_NW_R
    NJFET_PO_2d5V_NW_R_SIZE_PRE = NJFET_PO_2d5V_NW_R OR NJFET_PO_2d5V_NW_R_SIZE_H
    NJFET_PO_2d5V_NW_R_SIZE = SIZE NJFET_PO_2d5V_NW_R_SIZE_PRE BY POJ_N_S_1
    NOT RECTANGLE NJFET_PO_2d5V_NW_R_SIZE
    JFET_PO_2d5V_PSUB_RING_NJFET_HOLE = HOLES JFET_PO_2d5V_PSUB_RING_NJFET
    NJFET_PO_2d5V_NW_R_SIZE XOR JFET_PO_2d5V_PSUB_RING_NJFET_HOLE
}

POJ_N.S.2:2.5V_PO_NJFET { @ Space of 2.5V PO JFET ACTIVE OD to NWEL RING == ^POJ_N_S_2 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD INTERACT NJFET_PO_2d5V_DMY
    JFET_PO_2d5V_ACT_OD_CHECK_SIZE = SIZE JFET_PO_2d5V_ACT_OD_CHECK BY POJ_N_S_2
    NJFET_PO_2d5V_NW_R_HOLE = HOLES NJFET_PO_2d5V_NW_R INNER
    NJFET_PO_2d5V_NW_R_HOLE XOR JFET_PO_2d5V_ACT_OD_CHECK_SIZE
    NOT RECTANGLE JFET_PO_2d5V_ACT_OD_CHECK_SIZE 
}

POJ_N.S.3:2.5V_PO_NJFET { @ Space of CO to RPO >= ^POJ_N_S_3 um
    EXT CO NJFET_PO_2d5V_RPO < POJ_N_S_3 ABUT < 90 SINGULAR REGION
}

POJ_N.S.4:2.5V_PO_NJFET { @ Space of CO ON 2.5V_PO_NJFET GATE OD to PO == ^POJ_N_S_4 um
    NJFET_PO_2d5V_OD_GATE_CO_SIZE = SIZE NJFET_PO_2d5V_OD_GATE_CO BY POJ_N_S_4
    NJFET_PO_2d5V_OD_GATE_CO_SIZE NOT TOUCH NJFET_PO_2d5V_PO
    NOT RECTANGLE NJFET_PO_2d5V_OD_GATE_CO
    NOT RECTANGLE NJFET_PO_2d5V_PO
}

POJ_N.S.5:2.5V_PO_NJFET { @ Space of 2.5V_PO_NJFET SOURCE / DRAIN OD to PO == ^POJ_N_S_5 um
    NJFET_PO_2d5V_SD_OD_SIZE = SIZE NJFET_PO_2d5V_SD_OD BY POJ_N_S_5
    NJFET_PO_2d5V_SD_OD_SIZE NOT TOUCH NJFET_PO_2d5V_PO
    NOT RECTANGLE NJFET_PO_2d5V_SD_OD
    NOT RECTANGLE NJFET_PO_2d5V_PO
}

POJ_N.S.6:2.5V_PO_NJFET { @ Space of 2.5V PO JFET ACTIVE OD == ^POJ_N_S_6 um
    EXT JFET_PO_2d5V_ACT_OD < POJ_N_S_6 ABUT < 90 SINGULAR REGION
    JFET_PO_2d5V_ACT_OD_SIZE = SIZE JFET_PO_2d5V_ACT_OD BY POJ_N_S_6/2 OVERUNDER
    NOT RECTANGLE JFET_PO_2d5V_ACT_OD_SIZE
    JDMY INTERACT JFET_PO_2d5V_ACT_OD_SIZE > 1
}

POJ_N.EN.1:2.5V_PO_NJFET { @ Enclosure of NWEL RING beyond 2.5V_PO_NJFET ISO RING == ^POJ_N_EN_1 um
    NJFET_PO_2d5V_ISO_RING_SIZE = SIZE NJFET_PO_2d5V_ISO_RING BY POJ_N_EN_1 
    NJFET_PO_2d5V_NW_R XOR NJFET_PO_2d5V_ISO_RING_SIZE
}

POJ_N.EN.2:2.5V_PO_NJFET { @ Enclosure of NWEL RING beyond DNW == ^POJ_N_EN_2 um
    NJFET_PO_2d5V_NW_R_FILL = NJFET_PO_2d5V_NW_R OR NJFET_PO_2d5V_NW_H
    NJFET_PO_2d5V_DNW_SIZE = SIZE NJFET_PO_2d5V_DNW BY POJ_N_EN_2 
    NJFET_PO_2d5V_NW_R_FILL XOR NJFET_PO_2d5V_DNW_SIZE
}

POJ_N.EN.3:2.5V_PO_NJFET { @ Enclosure of 2.5V_PO_JFET ACTIVE OD beyond PO in channel width direction == ^POJ_N_EN_3 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND NJFET_PO_2d5V_DMY
    NJFET_PO_2d5V_PO_EXP_pre = EXPAND EDGE NJFET_PO_2d5V_PO OUTSIDE BY POJ_N_EN_3
    NJFET_PO_2d5V_PO_EXP = NJFET_PO_2d5V_PO_EXP_pre INTERACT PP
    NJFET_PO_2d5V_PO_EDGE = NJFET_PO_2d5V_PO COIN OUTSIDE EDGE NJFET_PO_2d5V_PO_EXP
    NJFET_PO_2d5V_PO_EDGE_EXP1 = EXPAND EDGE NJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_N_EN_3
    NJFET_PO_2d5V_PO_EDGE_EXP2 = EXPAND EDGE NJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_N_EN_3 + GRID
    NJFET_PO_2d5V_PO_CHECK = (NJFET_PO_2d5V_PO_EDGE_EXP2 NOT NJFET_PO_2d5V_PO_EDGE_EXP1) TOUCH EDGE NJFET_PO_2d5V_PO_EDGE_EXP1
    NJFET_PO_2d5V_PO_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD_CHECK 

}

POJ_N.EN.4:2.5V_PO_NJFET { @ Enclosure of 2.5V_PO_JFET ACTIVE OD beyond PO in channel length direction == ^POJ_N_EN_4 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND NJFET_PO_2d5V_DMY
    NJFET_PO_2d5V_PO_EXP_pre = EXPAND EDGE NJFET_PO_2d5V_PO OUTSIDE BY POJ_N_EN_4
    NJFET_PO_2d5V_PO_EXP = NJFET_PO_2d5V_PO_EXP_pre INTERACT NP
    NJFET_PO_2d5V_PO_EDGE = NJFET_PO_2d5V_PO COIN OUTSIDE EDGE NJFET_PO_2d5V_PO_EXP
    NJFET_PO_2d5V_PO_EDGE_EXP1 = EXPAND EDGE NJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_N_EN_4
    NJFET_PO_2d5V_PO_EDGE_EXP2 = EXPAND EDGE NJFET_PO_2d5V_PO_EDGE OUTSIDE BY POJ_N_EN_4 + GRID
    NJFET_PO_2d5V_PO_CHECK = (NJFET_PO_2d5V_PO_EDGE_EXP2 NOT NJFET_PO_2d5V_PO_EDGE_EXP1) TOUCH EDGE NJFET_PO_2d5V_PO_EDGE_EXP1
    NJFET_PO_2d5V_PO_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD_CHECK
    
}

POJ_N.EX.1:2.5V_PO_NJFET { @ Extension of RPO beyond 2.5V_PO_JFET ACTIVE OD == ^POJ_N_EX_1 um
    JFET_PO_2d5V_ACT_OD_CHECK = JFET_PO_2d5V_ACT_OD AND NJFET_PO_2d5V_DMY
    NJFET_PO_2d5V_ACT_NP_SIZE_PRE = SIZE NJFET_PO_2d5V_ACT_NP BY (POJ_N_EX_1 - POJ_N_EX_3)
    NJFET_PO_2d5V_ACT_NP_SIZE = NJFET_PO_2d5V_ACT_NP_SIZE_PRE NOT NJFET_PO_2d5V_RPO
    NJFET_PO_2d5V_PP_SIZE_PRE = SIZE NJFET_PO_2d5V_PP BY (POJ_N_EX_1 - POJ_N_EX_4)
    NJFET_PO_2d5V_PP_SIZE = NJFET_PO_2d5V_PP_SIZE_PRE NOT NJFET_PO_2d5V_RPO
    NJFET_PO_2d5V_RPO_REC = (NJFET_PO_2d5V_RPO OR NJFET_PO_2d5V_ACT_NP_SIZE) OR NJFET_PO_2d5V_PP_SIZE
    NOT RECTANGLE NJFET_PO_2d5V_RPO_REC
    JFET_PO_2d5V_ACT_OD_CHECK_SIZE = SIZE JFET_PO_2d5V_ACT_OD_CHECK BY POJ_N_EX_1
    NJFET_PO_2d5V_RPO_REC XOR JFET_PO_2d5V_ACT_OD_CHECK_SIZE
}

POJ_N.EX.2:2.5V_PO_NJFET { @ Extension of 2.5V_PO_JFET ACTIVE OD beyond 2.5V_PO_NJFET ACTIVE NP in channel width direction == ^POJ_N_EX_2 um
    ACT_NP_PRE_1 = NJFET_PO_2d5V_ACT_NP NOT JFET_PO_2d5V_ACT_OD
    ACT_NP_PRE_2 = NJFET_PO_2d5V_ACT_NP NOT ACT_NP_PRE_1
    NJFET_PO_2d5V_PO_CHECK1 = SIZE NJFET_PO_2d5V_PO BY POJ_N_S_5 - POJ_N_O_1
    EDGE_CHECK = ACT_NP_PRE_2 NOT COIN OUTSIDE EDGE (ACT_NP_PRE_1 OR NJFET_PO_2d5V_PO_CHECK1)
    EDGE_CHECK_SIZE_1 = EXPAND EDGE EDGE_CHECK OUTSIDE BY POJ_N_EX_2
    EDGE_CHECK_SIZE_2 = EXPAND EDGE EDGE_CHECK OUTSIDE BY POJ_N_EX_2+GRID
    EDGE_CHECK_CHECK = (EDGE_CHECK_SIZE_2 NOT EDGE_CHECK_SIZE_1) TOUCH EDGE EDGE_CHECK_SIZE_1
    EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE JFET_PO_2d5V_ACT_OD
}

POJ_N.EX.3:2.5V_PO_NJFET { @ Extension of 2.5V_PO_NJFET ACTIVE NP beyond 2.5V_PO_JFET ACTIVE OD in channel length direction == ^POJ_N_EX_3 um
    OD_EDGE_CHECK = JFET_PO_2d5V_ACT_OD INSIDE EDGE NJFET_PO_2d5V_ACT_NP
    NJFET_PO_2d5V_ACT_NP INSIDE JFET_PO_2d5V_ACT_OD
    OD_EDGE_CHECK_SIZE_1 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_N_EX_3
    OD_EDGE_CHECK_SIZE_2 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_N_EX_3+GRID
    OD_EDGE_CHECK_CHECK = (OD_EDGE_CHECK_SIZE_2 NOT OD_EDGE_CHECK_SIZE_1) TOUCH EDGE OD_EDGE_CHECK_SIZE_1
    OD_EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE NJFET_PO_2d5V_ACT_NP
}

POJ_N.EX.4:2.5V_PO_NJFET { @ Extension of PP beyond 2.5V_PO_JFET ACTIVE OD in channel width direction == ^POJ_N_EX_4 um
    OD_EDGE_CHECK = JFET_PO_2d5V_ACT_OD INSIDE EDGE NJFET_PO_2d5V_PP
    NJFET_PO_2d5V_PP INSIDE JFET_PO_2d5V_ACT_OD
    OD_EDGE_CHECK_SIZE_1 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_N_EX_4
    OD_EDGE_CHECK_SIZE_2 = EXPAND EDGE OD_EDGE_CHECK OUTSIDE BY POJ_N_EX_4+GRID
    OD_EDGE_CHECK_CHECK = (OD_EDGE_CHECK_SIZE_2 NOT OD_EDGE_CHECK_SIZE_1) TOUCH EDGE OD_EDGE_CHECK_SIZE_1
    OD_EDGE_CHECK_CHECK NOT COIN OUTSIDE EDGE NJFET_PO_2d5V_PP
}

POJ_N.O.1:2.5V_PO_NJFET { @ Overlap of 2.5V_PO_NJFET ACTIVE NP and RPO == ^POJ_N_O_1 um
    OVERLAP_CHECK = NJFET_PO_2d5V_ACT_NP AND NJFET_PO_2d5V_RPO
    INT OVERLAP_CHECK < POJ_N_O_1 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_N_O_1 / 2) UNDEROVER 
}

POJ_N.O.2:2.5V_PO_NJFET { @ Overlap of PP and RPO in channel length direction  == ^POJ_N_O_2 um
    OVERLAP_CHECK = NJFET_PO_2d5V_PP AND NJFET_PO_2d5V_RPO
    INT OVERLAP_CHECK < POJ_N_O_2 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_N_O_2 / 2) UNDEROVER 
}

POJ_N.O.3:2.5V_PO_NJFET { @ Overlap of RPO and PO in channel length direction == ^POJ_N_O_3 um
    OVERLAP_CHECK = NJFET_PO_2d5V_RPO AND NJFET_PO_2d5V_PO
    INT OVERLAP_CHECK < POJ_N_O_3 ABUT < 90 SINGULAR REGION
    SIZE OVERLAP_CHECK BY (POJ_N_O_3 / 2) UNDEROVER 
}

POJ_N.R.1:2.5V_PO_NJFET { @ {{PO NOT PP} AND {JDNW NOT INTERACT JNW}} NOT INSIDE RPO is not allowed 
    ((POLY NOT PP) AND NJFET_PO_2d5V_DMY) NOT INSIDE RPO
}
// JDMY.R.1U:2.5V_PO_NJFET is uncheckable

// 4V_NJFET DEVICES CHECK 
///============================

HVJ_N.W.1:4V_NJFET { @ Width of 4V_NJFET GATE OD in channel width direction == ^HVJ_N_W_1_1  ^HVJ_N_W_1_2  ^HVJ_N_W_1_3 um
    NJFET_4V_GATE_OD_EXPAND_1 = EXPAND EDGE NJFET_4V_GATE_OD OUTSIDE BY 0.001
    NJFET_4V_GATE_OD_EXPAND_2 = NJFET_4V_GATE_OD COIN OUTSIDE EDGE NJFET_4V_GATE_OD_EXPAND_1
    
    NJFET_4V_GATE_OD_WIDTH = LENGTH NJFET_4V_GATE_OD_EXPAND_2 != HVJ_N_W_2
    NJFET_4V_GATE_OD_WIDTH_HVJ_N_W_1_1 = LENGTH NJFET_4V_GATE_OD_WIDTH != HVJ_N_W_1_1
    NJFET_4V_GATE_OD_WIDTH_HVJ_N_W_1_2 = LENGTH NJFET_4V_GATE_OD_WIDTH_HVJ_N_W_1_1 != HVJ_N_W_1_2
    LENGTH NJFET_4V_GATE_OD_WIDTH_HVJ_N_W_1_2 != HVJ_N_W_1_3
    NOT RECTANGLE NJFET_4V_GATE_OD
}

HVJ_N.W.2:4V_NJFET { @ Width of 4V_NJFET GATE OD in channel length direction == ^HVJ_N_W_2 um
    INT NJFET_4V_GATE_OD < HVJ_N_W_2 ABUT < 90 SINGULAR REGION
    SIZE NJFET_4V_GATE_OD BY (HVJ_N_W_2 / 2) UNDEROVER 
}

HVJ_N.W.3:4V_NJFET { @ Width of 4V_NJFET DRAIN OD in channel length direction == ^HVJ_N_W_3 um
    INT NJFET_4V_D_OD < HVJ_N_W_3 ABUT < 90 SINGULAR REGION
    SIZE NJFET_4V_D_OD BY (HVJ_N_W_3 / 2) UNDEROVER 
}

HVJ_N.W.4:4V_NJFET { @ Width of 4V_NJFET SOURCE RING == ^HVJ_N_W_4 um
    INT NJFET_4V_SOURCE_RING < HVJ_N_W_4 ABUT < 90 SINGULAR REGION
    SIZE NJFET_4V_SOURCE_RING BY HVJ_N_W_4/2 UNDEROVER
}

HVJ_N.W.5:4V_NJFET { @ Width of 4V_JFET PSUB RING == ^HVJ_N_W_5 um
    INT JFET_4V_PSUB_RING < HVJ_N_W_5 ABUT < 90 SINGULAR REGION
    SIZE JFET_4V_PSUB_RING BY HVJ_N_W_5/2 UNDEROVER
}

NJFET_4V_GATE_OD_EXP_FOR_ENDCAP = EXPAND EDGE NJFET_4V_GATE_OD OUTSIDE BY (HVJ_N_S_5 + HVJ_N_W_3)
NJFET_4V_NW_JFETDMY_ENDCAP_PRE = NJFET_4V_NW_JFETDMY_INT OUTSIDE EDGE NJFET_4V_GATE_OD_EXP_FOR_ENDCAP
NJFET_4V_NW_JFETDMY_ENDCAP = NJFET_4V_NW_JFETDMY WITH EDGE NJFET_4V_NW_JFETDMY_ENDCAP_PRE
NJFET_4V_NW_JFETDMY_NON_ENDCAP = NJFET_4V_NW_JFETDMY NOT NJFET_4V_NW_JFETDMY_ENDCAP
HVJ_N.W.6:4V_NJFET { @ Width of {NW INSIDE JFETDMY_1}[endcap] in channel width direction == ^HVJ_N_W_6 um
    INT NJFET_4V_NW_JFETDMY_ENDCAP < HVJ_N_W_6 ABUT < 90 SINGULAR REGION
    SIZE NJFET_4V_NW_JFETDMY_ENDCAP BY (HVJ_N_W_6 / 2) UNDEROVER 
}

HVJ_N.W.7:4V_NJFET { @ Width of {NW INSIDE JFETDMY_1}[non-endcap] in channel width direction == ^HVJ_N_W_7 um
    INT NJFET_4V_NW_JFETDMY_NON_ENDCAP < HVJ_N_W_7 ABUT < 90 SINGULAR REGION
    SIZE NJFET_4V_NW_JFETDMY_NON_ENDCAP BY (HVJ_N_W_7 / 2) UNDEROVER 
}

HVJ_N.S.1:4V_NJFET { @ Space of NWEL RING to 4V_JFET PSUB RING == ^HVJ_N_S_1 um
    JFET_4V_PSUB_RING_CHECK = JFET_4V_PSUB_RING AND NJFET_4V_DMY
    NJFET_4V_NW_R_SIZE_H = HOLES NJFET_4V_NW_R
    NJFET_4V_NW_R_SIZE_PRE = NJFET_4V_NW_R OR NJFET_4V_NW_R_SIZE_H
    NJFET_4V_NW_R_SIZE = SIZE NJFET_4V_NW_R_SIZE_PRE BY HVJ_N_S_1
    NOT RECTANGLE NJFET_4V_NW_R_SIZE
    JFET_4V_PSUB_RING_CHECK_HOLE = HOLES JFET_4V_PSUB_RING_CHECK
    NJFET_4V_NW_R_SIZE XOR JFET_4V_PSUB_RING_CHECK_HOLE
}

HVJ_N.S.2:4V_NJFET { @ Space of 4V_NJFET GATE OD to NWEL RING == ^HVJ_N_S_2 um
    NJFET_4V_NW_JFETDMY_NON_ENDCAP_SIZE = SIZE NJFET_4V_NW_JFETDMY_NON_ENDCAP BY (HVJ_N_S_5 - HVJ_N_EN_3)
    NJFET_4V_GATE_OD_CHECK_PRE = NJFET_4V_NW_JFETDMY_NON_ENDCAP_SIZE OR NJFET_4V_GATE_OD
    NJFET_4V_GATE_OD_CHECK = EXTENTS NJFET_4V_GATE_OD_CHECK_PRE
    NJFET_4V_GATE_OD_CHECK_SIZE = SIZE NJFET_4V_GATE_OD_CHECK BY HVJ_N_S_2
    NJFET_4V_NW_R_HOLE = HOLES NJFET_4V_NW_R INNER
    NJFET_4V_NW_R_HOLE XOR NJFET_4V_GATE_OD_CHECK_SIZE
    NOT RECTANGLE NJFET_4V_GATE_OD_CHECK_SIZE 
}
NJFET_4V_D_OD_ENDCAP = NJFET_4V_D_OD AND NJFET_4V_NW_JFETDMY_ENDCAP
NJFET_4V_D_OD_NON_ENDCAP = NJFET_4V_D_OD AND NJFET_4V_NW_JFETDMY_NON_ENDCAP
NJFET_4V_NW_JFETDMY_ENDCAP_NON_COIN_EDGE = NJFET_4V_NW_JFETDMY_ENDCAP NOT COIN OUTSIDE EDGE JFETDMY_2
NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE = NJFET_4V_NW_JFETDMY_ENDCAP COIN OUTSIDE EDGE JFETDMY_2
NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_EXP = EXPAND EDGE NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE OUTSIDE BY 0.001
NJFET_4V_NW_JFETDMY_ENDCAP_NON_COIN_EDGE_EXP = EXPAND EDGE NJFET_4V_NW_JFETDMY_ENDCAP_NON_COIN_EDGE INSIDE BY 0.001
NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK = NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_EXP NOT INTERACT NJFET_4V_NW_JFETDMY_ENDCAP_NON_COIN_EDGE_EXP
NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL = NJFET_4V_NW_JFETDMY_ENDCAP COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK

NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_PRE = NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK
NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EXP = EXPAND EDGE NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_PRE OUTSIDE BY (JFETDMY_1_W_2_1 - HVJ_N_W_1_1)
NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE = NJFET_4V_NW_R INSIDE EDGE NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EXP
NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE_EXP = EXPAND EDGE NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE INSIDE BY 0.001


NJFET_4V_NW_JFETDMY_SPACE_REGION = (SIZE NJFET_4V_NW_JFETDMY BY HVJ_N_S_6 / 2 OVERUNDER) NOT NJFET_4V_NW_JFETDMY
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END = NJFET_4V_NW_JFETDMY COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_SPACE_REGION
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE = NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END NOT COIN INSIDE EDGE NJFET_4V_NW_JFETDMY_ENDCAP
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_PRE = NJFET_4V_NW_JFETDMY NOT COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_SPACE_REGION
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_EXP_PRE = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_PRE OUTSIDE BY 0.001
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_EXP = NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_EXP_PRE NOT NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE = NJFET_4V_NW_JFETDMY COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_EXP


HVJ_N.S.3:4V_NJFET { @ Space of 4V_NJFET DRAIN OD [endcap] to NWEL RING in channel width direction == ^HVJ_N_S_3 um
    NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EXP NOT CUT NJFET_4V_NW_R
    NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE_EXP_SIZE = SIZE NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE_EXP BY HVJ_N_S_3
    NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE_EXP_SIZE NOT TOUCH NJFET_4V_D_OD_ENDCAP
    NOT RECTANGLE NJFET_4V_NW_JFETDMY_NW_R_OPPSITE_ENDCAP_OD_EDGE_EXP
    NOT RECTANGLE NJFET_4V_D_OD_ENDCAP
}

HVJ_N.S.4:4V_NJFET { @ Space of NWEL RING to {NW INSIDE JFETDMY_1} in channel length direction == ^HVJ_N_S_4 um
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE1 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE OUTSIDE BY HVJ_N_S_4
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE2 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE OUTSIDE BY HVJ_N_S_4 + GRID
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_CHECK = (NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE2 NOT NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE1) TOUCH EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE1
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_CHECK NOT COIN INSIDE EDGE NJFET_4V_NW_R
}

HVJ_N.S.5:4V_NJFET { @ Space of 4V_NJFET GATE OD to 4V_NJFET DRAIN OD == ^HVJ_N_S_5 um
    NJFET_4V_GATE_OD_SIZE = SIZE NJFET_4V_GATE_OD BY HVJ_N_S_5
    NJFET_4V_GATE_OD_SIZE NOT TOUCH NJFET_4V_D_OD
    NOT RECTANGLE NJFET_4V_GATE_OD
    NOT RECTANGLE NJFET_4V_D_OD
}

HVJ_N.S.6:4V_NJFET { @ Space of {NW INSIDE JFETDMY_1} in channel width direction == ^HVJ_N_S_6 um
    EXT NJFET_4V_NW_JFETDMY < HVJ_N_S_6 ABUT < 90 SINGULAR REGION
    NJFET_4V_NW_JFETDMY_SIZE = SIZE NJFET_4V_NW_JFETDMY BY HVJ_N_S_6/2 OVERUNDER
    NOT RECTANGLE NJFET_4V_NW_JFETDMY_SIZE
    JFETDMY_1 INTERACT NJFET_4V_NW_JFETDMY_SIZE > 1
}

HVJ_N.S.7:4V_NJFET { @ Space of NWEL RING [outer edge] == ^HVJ_N_S_7 um
    EXT NJFET_4V_NW_R_ALL < HVJ_N_S_7 ABUT < 90 SINGULAR REGION
    NJFET_4V_NW_R_ALL_SIZE = SIZE NJFET_4V_NW_R_ALL BY HVJ_N_S_7/2 OVERUNDER
    NOT RECTANGLE NJFET_4V_NW_R_ALL_SIZE
    HVJDMY INTERACT NJFET_4V_NW_R_ALL_SIZE > 1
}

HVJ_N.EN.1:4V_NJFET { @ Enclosure of NWEL RING beyond 4V_NJFET SOURCE RING == ^HVJ_N_EN_1 um
    NJFET_4V_SOURCE_RING_SIZE = SIZE NJFET_4V_SOURCE_RING BY HVJ_N_EN_1 
    NJFET_4V_NW_R XOR NJFET_4V_SOURCE_RING_SIZE
}

HVJ_N.EN.2:4V_NJFET { @ Enclosure of NWEL RING beyond DNW == ^HVJ_N_EN_2 um
    NJFET_4V_NW_R_FILL = NJFET_4V_NW_R OR NJFET_4V_NW_H
    NJFET_4V_NW_DNW_SIZE = SIZE NJFET_4V_NW_DNW BY HVJ_N_EN_2 
    NJFET_4V_NW_R_FILL XOR NJFET_4V_NW_DNW_SIZE
}

HVJ_N.EN.3:4V_NJFET { @ Enclosure of {NW INSIDE JFETDMY_1} beyond 4V_NJFET DRAIN OD in channel length direction == ^HVJ_N_EN_3 um
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE_1 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE INSIDE BY HVJ_N_EN_3
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE_2 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE INSIDE BY HVJ_N_EN_3-GRID
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_CHECK = NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE_1 NOT NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_SIZE_2
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_CHECK NOT TOUCH NJFET_4V_D_OD
    NOT RECTANGLE NJFET_4V_D_OD
}

HVJ_N.EN.4:4V_NJFET { @ Enclosure of {NW INSIDE JFETDMY_1} beyond 4V_NJFET DRAIN OD [endcap] in channel width direction == ^HVJ_N_EN_4 um
    NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_SIZE_1 = EXPAND EDGE NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL INSIDE BY HVJ_N_EN_4
    NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_SIZE_2 = EXPAND EDGE NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL INSIDE BY HVJ_N_EN_4-GRID
    NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_CHECK = NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_SIZE_1 NOT NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_SIZE_2
    NJFET_4V_NW_JFETDMY_ENDCAP_COIN_EDGE_CHECK_FINAL_CHECK NOT TOUCH NJFET_4V_D_OD_ENDCAP
    NOT RECTANGLE NJFET_4V_D_OD_ENDCAP
}

HVJ_N.EN.5:4V_NJFET { @ Enclosure of {NW INSIDE JFETDMY_1} beyond 4V_NJFET DRAIN OD [non-endcap] in channel width direction == ^HVJ_N_EN_5 um
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_SIZE_1 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE INSIDE BY HVJ_N_EN_5
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_SIZE_2 = EXPAND EDGE NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE INSIDE BY HVJ_N_EN_5-GRID
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_CHECK = NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_SIZE_1 NOT NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_SIZE_2
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_NO_END_EDGE_CHECK NOT TOUCH NJFET_4V_D_OD_NON_ENDCAP
    NOT RECTANGLE NJFET_4V_D_OD_NON_ENDCAP
}

HVJ_N.N.1:4V_NJFET { @ Number of 4V_NJFET SOURCE RING hole INSIDE 4V_NJFET PSUB RING hole == ^HVJ_N_N_1 um
    JFET_4V_PSUB_RING_H_CHECK = JFET_4V_PSUB_RING_H AND NJFET_4V_DMY
    JFET_4V_PSUB_RING_H_CHECK ENCLOSE NJFET_4V_SOURCE_RING != HVJ_N_N_1
    JFET_4V_PSUB_RING_H_CHECK NOT ENCLOSE NJFET_4V_SOURCE_RING
}

HVJDMY.EN.1:4V_NJFET { @ Enclosure of HVJDMY beyond 4V_JFET PSUB RING [outer edge] == ^HVJDMY_EN_1_4V_NJFET um
    JFET_4V_PSUB_RING_FILL = JFET_4V_PSUB_RING_H OR JFET_4V_PSUB_RING
    JFET_4V_PSUB_RING_FILL_CHECK = JFET_4V_PSUB_RING_FILL AND NJFET_4V_DMY
    HVJDMY_CHECK = HVJDMY INTERACT NJFET_4V_DMY
    JFET_4V_PSUB_RING_FILL_CHECK_SIZE = SIZE JFET_4V_PSUB_RING_FILL_CHECK BY HVJDMY_EN_1_4V_NJFET
    JFET_4V_PSUB_RING_FILL_CHECK_SIZE XOR HVJDMY_CHECK
    NOT RECTANGLE JFET_4V_PSUB_RING_FILL_CHECK
    NOT RECTANGLE HVJDMY_CHECK
}

//HVJDMY.R.1U:4V_NJFET is uncheckable
JFETDMY_12 = JFETDMY_1 OR JFETDMY_2
JFETDMY_1.W.1:4V_NJFET { @ Width of {JFETDMY_1 OR JFETDMY_2} in channel length direction == ^JFETDMY_1_W_1 um
    INT JFETDMY_12 < JFETDMY_1_W_1 ABUT < 90 SINGULAR REGION
    SIZE JFETDMY_12 BY (JFETDMY_1_W_1 / 2) UNDEROVER 
}

JFETDMY_1.W.2:4V_NJFET { @ Width of {JFETDMY_1 OR JFETDMY_2} in channel width direction == ^JFETDMY_1_W_2_1 ^JFETDMY_1_W_2_2 ^JFETDMY_1_W_2_3 um
    JFETDMY_12_EXPAND_1 = EXPAND EDGE JFETDMY_12 OUTSIDE BY 0.001
    JFETDMY_12_EXPAND_2 = JFETDMY_12 COIN OUTSIDE EDGE JFETDMY_12_EXPAND_1
    
    JFETDMY_12_WIDTH = LENGTH JFETDMY_12_EXPAND_2 != JFETDMY_1_W_1
    JFETDMY_12_WIDTH_JFETDMY_1_W_2_1 = LENGTH JFETDMY_12_WIDTH != JFETDMY_1_W_2_1
    JFETDMY_12_WIDTH_JFETDMY_1_W_2_2 = LENGTH JFETDMY_12_WIDTH_JFETDMY_1_W_2_1 != JFETDMY_1_W_2_2
    LENGTH JFETDMY_12_WIDTH_JFETDMY_1_W_2_2 != JFETDMY_1_W_2_3
    NOT RECTANGLE JFETDMY_12
}

JFETDMY_1.S.1:4V_NJFET { @ Space of JFETDMY_1 in channel length direction. == ^JFETDMY_1_S_1 um
    NJFET_4V_JFETDMY2_FILL = NJFET_4V_JFETDMY2 OR NJFET_4V_JFETDMY2_H
    NJFET_4V_JFETDMY1_EXP_pre = EXPAND EDGE NJFET_4V_JFETDMY1 OUTSIDE BY HVJ_N_S_4
    NJFET_4V_JFETDMY1_EXP = NJFET_4V_JFETDMY1_EXP_pre INTERACT NJFET_4V_GATE_OD
    NJFET_4V_JFETDMY1_EDGE = NJFET_4V_JFETDMY1 COIN OUTSIDE EDGE NJFET_4V_JFETDMY1_EXP
    NJFET_4V_JFETDMY1_EDGE_EXP1 = EXPAND EDGE NJFET_4V_JFETDMY1_EDGE OUTSIDE BY HVJ_N_S_4
    NJFET_4V_JFETDMY1_EDGE_EXP2 = EXPAND EDGE NJFET_4V_JFETDMY1_EDGE OUTSIDE BY HVJ_N_S_4 + GRID
    NJFET_4V_JFETDMY1_CHECK = (NJFET_4V_JFETDMY1_EDGE_EXP2 NOT NJFET_4V_JFETDMY1_EDGE_EXP1) TOUCH EDGE NJFET_4V_JFETDMY1_EDGE_EXP1
    NJFET_4V_JFETDMY1_CHECK NOT COIN OUTSIDE EDGE NJFET_4V_JFETDMY2_FILL
    
}

JFETDMY_1.S.2:4V_NJFET { @ Space of JFETDMY_1 in channel width direction.  == ^JFETDMY_1_S_2 um
    NJFET_4V_JFETDMY2_FILL = NJFET_4V_JFETDMY2 OR NJFET_4V_JFETDMY2_H
    NJFET_4V_JFETDMY1_EXP_pre = EXPAND EDGE NJFET_4V_JFETDMY1 OUTSIDE BY (HVJ_N_S_3 - HVJ_N_EN_4)
    NJFET_4V_JFETDMY1_EXP = NJFET_4V_JFETDMY1_EXP_pre NOT INTERACT NJFET_4V_GATE_OD
    NJFET_4V_JFETDMY1_EDGE = NJFET_4V_JFETDMY1 COIN OUTSIDE EDGE NJFET_4V_JFETDMY1_EXP
    NJFET_4V_JFETDMY1_EDGE_EXP1 = EXPAND EDGE NJFET_4V_JFETDMY1_EDGE OUTSIDE BY (HVJ_N_S_3 - HVJ_N_EN_4)
    NJFET_4V_JFETDMY1_EDGE_EXP2 = EXPAND EDGE NJFET_4V_JFETDMY1_EDGE OUTSIDE BY (HVJ_N_S_3 - HVJ_N_EN_4) + GRID
    NJFET_4V_JFETDMY1_CHECK = (NJFET_4V_JFETDMY1_EDGE_EXP2 NOT NJFET_4V_JFETDMY1_EDGE_EXP1) TOUCH EDGE NJFET_4V_JFETDMY1_EDGE_EXP1
    NJFET_4V_JFETDMY1_CHECK NOT COIN OUTSIDE EDGE NJFET_4V_JFETDMY2_FILL
}
NJFET_4V_NW_JFETDMY_SPACE_REGION_1 = (SIZE NJFET_4V_NW_JFETDMY_INT BY HVJ_N_S_6 / 2 OVERUNDER) NOT NJFET_4V_NW_JFETDMY_INT
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_NON_END_1 = NJFET_4V_NW_JFETDMY_INT COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_SPACE_REGION_1
NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_PRE_1 = NJFET_4V_NW_JFETDMY_INT NOT COIN OUTSIDE EDGE NJFET_4V_NW_JFETDMY_SPACE_REGION_1

JFETDMY_1.EN.1:4V_NJFET { @ Enclosure of JFETDMY_1 beyond {NW INTERACT JFETDMY_1} == ^JFETDMY_1_EN_1 um
    NJFET_4V_NW_JFETDMY_CH_WIDTH_EDGE_PRE_1 NOT COIN INSIDE EDGE NJFET_4V_JFETDMY1
}

JFETDMY_1.N.1:4V_NJFET { @ Number of JFETDMY_1 INSIDE 4V_NJFET SOURCE RING hole == ^JFETDMY_1_N_1 um
    NJFET_4V_SOURCE_RING_H ENCLOSE NJFET_4V_JFETDMY1 != JFETDMY_1_N_1
    NJFET_4V_SOURCE_RING_H NOT ENCLOSE NJFET_4V_JFETDMY1
}

JFETDMY_1.R.1:4V_NJFET { @ {NW INTERACT JFETDMY_1} CUT JFETDMY_1 is not allowed.
    (NWEL INTERACT JFETDMY_1) CUT JFETDMY_1
}

JFETDMY_2.S.1:4V_NJFET { @ Space of JFETDMY_2 == ^JFETDMY_2_S_1 um
    NJFET_4V_JFETDMY2_FILL = NJFET_4V_JFETDMY2 OR NJFET_4V_JFETDMY2_H
    EXT NJFET_4V_JFETDMY2_FILL < JFETDMY_2_S_1 ABUT < 90 SINGULAR REGION
    NJFET_4V_JFETDMY2_FILL_SIZE = SIZE NJFET_4V_JFETDMY2_FILL BY JFETDMY_2_S_1/2 OVERUNDER
    NOT RECTANGLE NJFET_4V_JFETDMY2_FILL_SIZE
    NJFET_4V_DMY INTERACT NJFET_4V_JFETDMY2_FILL_SIZE > 1
}

JFETDMY_2.S.2:4V_NJFET { @ Space of JFETDMY_2 to NWEL RING (butted is must) == ^JFETDMY_2_S_2 um
    NJFET_4V_JFETDMY2_FILL = NJFET_4V_JFETDMY2 OR NJFET_4V_JFETDMY2_H
    NOT RECTANGLE NJFET_4V_JFETDMY2_FILL
    NJFET_4V_NW_R_HOLE = HOLES NJFET_4V_NW_R INNER
    NJFET_4V_JFETDMY2_FILL XOR NJFET_4V_NW_R_HOLE
}

JFETDMY_2.S.3:4V_NJFET { @ Space of JFETDMY_2 to {NW INSIDE JFETDMY_1} (butted is must) == ^JFETDMY_2_S_3 um
    NJFET_4V_NW_JFETDMY_CHECK = (SIZE NJFET_4V_NW_JFETDMY BY HVJ_N_S_6 / 2 OVERUNDER) AND JFETDMY_1
    NOT RECTANGLE NJFET_4V_NW_JFETDMY_CHECK
    NJFET_4V_JFETDMY2_HOLE = HOLES NJFET_4V_JFETDMY2 INNER
    NJFET_4V_NW_JFETDMY_CHECK XOR NJFET_4V_JFETDMY2_HOLE
}

JFETDMY_2.N.1:4V_NJFET { @ Number of JFETDMY_2 INSIDE 4V_NJFET SOURCE RING hole == ^JFETDMY_2_N_1 um
    NJFET_4V_SOURCE_RING_H ENCLOSE NJFET_4V_JFETDMY2 != JFETDMY_2_N_1
    NJFET_4V_SOURCE_RING_H NOT ENCLOSE NJFET_4V_JFETDMY2
}

JFETDMY_4.S.1:4V_NJFET { @ Space of JFETDMY_4 to JFETDMY_1 (butted is must) == ^JFETDMY_4_S_1 um
    NJFET_4V_JFETDMY4 NOT TOUCH NJFET_4V_JFETDMY1
    NOT RECTANGLE NJFET_4V_JFETDMY4
    NOT RECTANGLE NJFET_4V_JFETDMY1
}

JFETDMY_4.S.2:4V_NJFET { @ Space of JFETDMY_4 to NWEL RING in channel length direction (butted is must) == ^JFETDMY_4_S_2 um
    NJFET_4V_JFETDMY4_TOUCH_1 = NJFET_4V_JFETDMY4 COIN OUTSIDE EDGE NJFET_4V_JFETDMY1
    NJFET_4V_JFETDMY4_EXP = EXPAND EDGE NJFET_4V_JFETDMY4_TOUCH_1 INSIDE BY 0.001
    NJFET_4V_JFETDMY4_NON_TOUCH = NJFET_4V_JFETDMY4 NOT COIN OUTSIDE EDGE NJFET_4V_JFETDMY1
    NJFET_4V_JFETDMY4_NON_TOUCH_EXP = EXPAND EDGE NJFET_4V_JFETDMY4_NON_TOUCH OUTSIDE BY 0.001
    NJFET_4V_JFETDMY4_CHECK_PRE = NJFET_4V_JFETDMY4_NON_TOUCH_EXP NOT INTERACT NJFET_4V_JFETDMY4_EXP
    NJFET_4V_JFETDMY4_CHECK = NJFET_4V_JFETDMY4 COIN OUTSIDE EDGE NJFET_4V_JFETDMY4_CHECK_PRE
    NJFET_4V_JFETDMY4_CHECK NOT COIN OUTSIDE EDGE NJFET_4V_NW_R
}

JFETDMY_4.EN.1:4V_NJFET { @ Enclosure of JFETDMY_4 beyond 4V_NJFET GATE OD in channel width direction == ^JFETDMY_4_EN_1 um
    NJFET_4V_JFETDMY4_TOUCH_1 = NJFET_4V_JFETDMY4 COIN OUTSIDE EDGE NJFET_4V_JFETDMY1
    NJFET_4V_JFETDMY4_EXP = EXPAND EDGE NJFET_4V_JFETDMY4_TOUCH_1 INSIDE BY 0.001
    NJFET_4V_JFETDMY4_NON_TOUCH = NJFET_4V_JFETDMY4 NOT COIN OUTSIDE EDGE NJFET_4V_JFETDMY1
    NJFET_4V_JFETDMY4_NON_TOUCH_EXP = EXPAND EDGE NJFET_4V_JFETDMY4_NON_TOUCH OUTSIDE BY 0.001
    NJFET_4V_JFETDMY4_CHECK_PRE = NJFET_4V_JFETDMY4_NON_TOUCH_EXP INTERACT NJFET_4V_JFETDMY4_EXP
    NJFET_4V_JFETDMY4_CHECK = NJFET_4V_JFETDMY4 COIN OUTSIDE EDGE NJFET_4V_JFETDMY4_CHECK_PRE
    NJFET_4V_JFETDMY4_CHECK NOT TOUCH EDGE NJFET_4V_GATE_OD
    NOT RECTANGLE NJFET_4V_GATE_OD
}

JFETDMY_4.N.1:4V_NJFET { @ Number of JFETDMY_4 INSIDE 4V_NJFET SOURCE RING hole == ^JFETDMY_4_N_1 um
    NJFET_4V_SOURCE_RING_H ENCLOSE NJFET_4V_JFETDMY4 != JFETDMY_4_N_1
    NJFET_4V_SOURCE_RING_H NOT ENCLOSE NJFET_4V_JFETDMY4
}

//OD_25.EN.2 is checked by OD_25.EN.2:4V_NJFET
OD_25.EN.2:4V_NJFET { @ Enclosure of OD_25 beyond 4V_JFET PSUB RING [outer edge] == ^OD_25_EN_2_4V_NJFET um
    JFET_4V_PSUB_RING_CHECK = JFET_4V_PSUB_RING INTERACT NJFET_4V_DMY
    JFET_4V_PSUB_RING_H_CHECK = JFET_4V_PSUB_RING_H INTERACT NJFET_4V_DMY
    NJFET_4V_OD25_CHECK = NJFET_4V_OD25 INTERACT NJFET_4V_DMY
    JFET_4V_PSUB_RING_CHECK_FILL = JFET_4V_PSUB_RING_CHECK OR JFET_4V_PSUB_RING_H_CHECK
    JFET_4V_PSUB_RING_CHECK_SIZE = SIZE JFET_4V_PSUB_RING_CHECK_FILL BY OD_25_EN_2_4V_NJFET 
    NJFET_4V_OD25_CHECK XOR JFET_4V_PSUB_RING_CHECK_SIZE
}

// 4V_PJFET DEVICES CHECK 
///============================

HVJ_P.W.1:4V_PJFET { @ Width of 4V_PJFET DRAIN OD in channel width direction >= ^HVJ_P_W_1 um
    PJFET_4V_D_OD_LENGTH = LENGTH PJFET_4V_D_OD != HVJ_P_W_2
    LENGTH PJFET_4V_D_OD_LENGTH < HVJ_P_W_1
    NOT RECTANGLE PJFET_4V_D_OD
}

HVJ_P.W.2:4V_PJFET { @ Width of 4V_PJFET DRAIN OD in channel length direction == ^HVJ_P_W_2 um
    INT PJFET_4V_D_OD < HVJ_P_W_2 ABUT < 90 SINGULAR REGION
    SIZE PJFET_4V_D_OD BY (HVJ_P_W_2 / 2) UNDEROVER 
}

HVJ_P.W.3:4V_PJFET { @ Width of 4V_PJFET GATE RING == ^HVJ_P_W_3 um
    INT PJFET_4V_GATE_RING < HVJ_P_W_3 ABUT < 90 SINGULAR REGION
    SIZE PJFET_4V_GATE_RING BY HVJ_P_W_3/2 UNDEROVER
}

HVJ_P.W.4:4V_PJFET { @ Width of 4V_JFET PSUB RING == ^HVJ_P_W_4 um
    INT JFET_4V_PSUB_RING < HVJ_P_W_4 ABUT < 90 SINGULAR REGION
    SIZE JFET_4V_PSUB_RING BY HVJ_P_W_4/2 UNDEROVER
}

HVJ_P.W.5:4V_PJFET { @ Width of RPO in channel length direction == ^HVJ_P_W_5 um
    INT PJFET_4V_RPO < HVJ_P_W_5 ABUT < 90 SINGULAR REGION
    SIZE PJFET_4V_RPO BY (HVJ_P_W_5 / 2) UNDEROVER 
}

HVJ_P.S.1:4V_PJFET { @ Space of {NW NOT {NW AND JNW}} RING to 4V_JFET PSUB RING == ^HVJ_P_S_1 um
    JFET_4V_PSUB_RING_CHECK = JFET_4V_PSUB_RING AND PJFET_4V_DMY
    PJFET_4V_NW_R_SIZE_H = HOLES PJFET_4V_NW_R
    PJFET_4V_NW_R_SIZE_PRE = PJFET_4V_NW_R OR PJFET_4V_NW_R_SIZE_H
    PJFET_4V_NW_R_SIZE = SIZE PJFET_4V_NW_R_SIZE_PRE BY HVJ_P_S_1
    NOT RECTANGLE PJFET_4V_NW_R_SIZE
    JFET_4V_PSUB_RING_CHECK_HOLE = HOLES JFET_4V_PSUB_RING_CHECK
    PJFET_4V_NW_R_SIZE XOR JFET_4V_PSUB_RING_CHECK_HOLE
}

HVJ_P.S.2:4V_PJFET { @ Space of 4V_PJFET DRAIN OD to NWEL RING == ^HVJ_P_S_2 um
    PJFET_4V_JNW_SIZE = SIZE PJFET_4V_JNW BY JNW_S_2
    PJFET_4V_D_OD_IN_EDGE = PJFET_4V_D_OD COIN OUTSIDE EDGE PJFET_4V_JNW_SIZE
    PJFET_4V_D_OD_EXP = EXPAND EDGE PJFET_4V_D_OD OUTSIDE BY 0.001
    PJFET_4V_D_OD_IN_EDGE_EXP = EXPAND EDGE PJFET_4V_D_OD_IN_EDGE OUTSIDE BY 0.001
    PJFET_4V_D_OD_EXP2 = PJFET_4V_D_OD_EXP NOT PJFET_4V_D_OD_IN_EDGE_EXP
    PJFET_4V_D_OD_OUT_EDGE = PJFET_4V_D_OD COIN OUTSIDE EDGE PJFET_4V_D_OD_EXP2
    PJFET_4V_D_OD_OUT_EDGE_SIZE1 = EXPAND EDGE PJFET_4V_D_OD_OUT_EDGE OUTSIDE BY HVJ_P_S_2
    PJFET_4V_D_OD_OUT_EDGE_SIZE2 = EXPAND EDGE PJFET_4V_D_OD_OUT_EDGE OUTSIDE BY HVJ_P_S_2 + GRID
    PJFET_4V_D_OD_OUT_EDGE_CHECK = (PJFET_4V_D_OD_OUT_EDGE_SIZE2 NOT PJFET_4V_D_OD_OUT_EDGE_SIZE1) TOUCH EDGE PJFET_4V_D_OD_OUT_EDGE_SIZE1
    PJFET_4V_D_OD_OUT_EDGE_CHECK NOT COIN INSIDE EDGE PJFET_4V_NW_R
}

HVJ_P.S.3:4V_PJFET { @ Space of 4V_PJFET SOURCE OD to NWEL RING in channel width direction == ^HVJ_P_S_3 um
    PJFET_4V_SOURCE_OD_IN_DMY = PJFET_4V_SOURCE_OD AND RPO 
    PJFET_4V_SOURCE_OD_OUT_DMY = PJFET_4V_SOURCE_OD NOT RPO
    PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK = PJFET_4V_SOURCE_OD_OUT_DMY NOT COIN OUTSIDE EDGE PJFET_4V_SOURCE_OD_IN_DMY
    PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_SIZE1 = EXPAND EDGE PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK OUTSIDE BY HVJ_P_S_3
    PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_SIZE2 = EXPAND EDGE PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK OUTSIDE BY HVJ_P_S_3 + GRID
    PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_CHECK = (PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_SIZE2 NOT PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_SIZE1) TOUCH EDGE PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_SIZE1
    PJFET_4V_SOURCE_OD_OUT_DMY_EDGE_CHECK_CHECK NOT COIN INSIDE EDGE PJFET_4V_NW_R
    NOT RECTANGLE PJFET_4V_SOURCE_OD
}

HVJ_P.S.4:4V_PJFET { @ Space of 4V_PJFET GATE OD to {NW INTERACT JFETDMY_5} in channel width direction == ^HVJ_P_S_4 um
    JFETDMY_5_WI_NW = NWEL AND JFETDMY_5
    JFETDMY_5 INTERACT JFETDMY_5_WI_NW != 2
    JFETDMY_5 NOT CUT JFETDMY_5_WI_NW

    NW_INT_JFETDMY_5 = NWEL INTERACT JFETDMY_5
    NW_INT_JFETDMY_5_CHECK = NW_INT_JFETDMY_5 AND JFETDMY_5
    NW_INT_JFETDMY_5_CHECK NOT TOUCH PJFET_4V_GATE_OD
    NOT RECTANGLE NW_INT_JFETDMY_5_CHECK
    NOT RECTANGLE PJFET_4V_GATE_OD
}

HVJ_P.S.5:4V_PJFET { @ Space of  {CO AND {OD INTERACT JFETDMY_5}}to RPO == ^HVJ_P_S_5 um
    CO_CHECK = CO AND (OD INTERACT JFETDMY_5)
    PJFET_4V_RPO_SIZE = SIZE PJFET_4V_RPO BY HVJ_P_S_5
    CO_CHECK NOT TOUCH PJFET_4V_RPO_SIZE
    NOT RECTANGLE PJFET_4V_RPO
    NOT RECTANGLE CO_CHECK
}

HVJ_P.EN.1:4V_PJFET { @ Enclosure of {NW NOT {NW AND JNW}} RING beyond 4V_PJFET GATE RING == ^HVJ_P_EN_1 um
    PJFET_4V_GATE_RING_SIZE = SIZE PJFET_4V_GATE_RING BY HVJ_P_EN_1 
    PJFET_4V_NW_R XOR PJFET_4V_GATE_RING_SIZE
}

HVJ_P.EN.2:4V_PJFET { @ Enclosure of {NW NOT {NW AND JNW}} RING beyond DNW == ^HVJ_P_EN_2 um
    PJFET_4V_NW_R_FILL = PJFET_4V_NW_R OR PJFET_4V_NW_H
    PJFET_4V_DNW_SIZE = SIZE PJFET_4V_DNW BY HVJ_P_EN_2 
    PJFET_4V_NW_R_FILL XOR PJFET_4V_DNW_SIZE
}

HVJ_P.EN.3:4V_PJFET { @ Enclosure of 4V_PJFET GATE OD beyond CO in channel length direction == ^HVJ_P_EN_3 um
    CO_CHECK = CO AND PJFET_4V_GATE_OD
    RPO_SIZE = SIZE PJFET_4V_RPO BY HVJ_P_S_5
    CO_CHECK_TO_RPO = CO_CHECK COIN OUTSIDE EDGE RPO_SIZE
    CO_CHECK_TO_RPO_EXP = EXPAND EDGE CO_CHECK_TO_RPO INSIDE BY 0.001
    CO_CHECK_EXP = EXPAND EDGE CO_CHECK OUTSIDE BY 0.001
    CO_CHECK_EDGE_PRE = CO_CHECK_EXP NOT INTERACT CO_CHECK_TO_RPO_EXP
    CO_CHECK_EDGE = CO_CHECK COIN OUTSIDE EDGE CO_CHECK_EDGE_PRE
    CO_CHECK_EDGE_SIZE_1 = EXPAND EDGE CO_CHECK_EDGE OUTSIDE BY HVJ_P_EN_3
    CO_CHECK_EDGE_SIZE_2 = EXPAND EDGE CO_CHECK_EDGE OUTSIDE BY HVJ_P_EN_3+GRID
    CO_CHECK_EDGE_CHECK = (CO_CHECK_EDGE_SIZE_2 NOT CO_CHECK_EDGE_SIZE_1) TOUCH EDGE CO_CHECK_EDGE_SIZE_1
    CO_CHECK_EDGE_CHECK NOT COIN OUTSIDE EDGE PJFET_4V_GATE_OD
}

HVJ_P.EN.4:4V_PJFET { @ Enclosure of {OD INTERACT JFETDMY_5} beyond CO in channel width direction == ^HVJ_P_EN_4 um
    OD_CHECK = OD INTERACT JFETDMY_5
    CO_CHECK = CO AND OD_CHECK
    OD_CHECK_EXP = EXPAND EDGE OD_CHECK OUTSIDE BY 0.001
    OD_CHECK_EDGE_pre = OD_CHECK_EXP INTERACT RPO
    OD_CHECK_EDGE = OD_CHECK COIN OUTSIDE EDGE OD_CHECK_EDGE_pre
    OD_CHECK_EDGE_SIZE_1 = EXPAND EDGE OD_CHECK_EDGE INSIDE BY HVJ_P_EN_4
    OD_CHECK_EDGE_SIZE_2 = EXPAND EDGE OD_CHECK_EDGE INSIDE BY HVJ_P_EN_4-GRID
    OD_CHECK_EDGE_CHECK = OD_CHECK_EDGE_SIZE_1 NOT OD_CHECK_EDGE_SIZE_2
    OD_CHECK_EDGE_CHECK NOT TOUCH CO_CHECK
    NOT RECTANGLE CO_CHECK
}

HVJ_P.O.1:4V_PJFET { @ Overlap of NP and RPO in channel length direction == ^HVJ_P_O_1 um
    NP_RPO_CHECK = NP AND PJFET_4V_RPO
    INT NP_RPO_CHECK < HVJ_P_O_1 ABUT < 90 SINGULAR REGION
    SIZE NP_RPO_CHECK BY (HVJ_P_O_1 / 2) UNDEROVER 
}

HVJ_P.O.2:4V_PJFET { @ Overlap of PP and RPO in channel length direction == ^HVJ_P_O_2 um
    PP_RPO_CHECK = PP AND PJFET_4V_RPO
    INT PP_RPO_CHECK < HVJ_P_O_2 ABUT < 90 SINGULAR REGION
    SIZE PP_RPO_CHECK BY (HVJ_P_O_2 / 2) UNDEROVER 
}

HVJ_P.N.1:4V_PJFET { @ Number of {OD INTERACT RPO} INSIDE 4V_PJFET GATE RING hole == ^HVJ_P_N_1 um
    OD_CHECK = OD INTERACT RPO
    PJFET_4V_GATE_RING_H ENCLOSE OD_CHECK != HVJ_P_N_1
    PJFET_4V_GATE_RING_H NOT ENCLOSE OD_CHECK
}
//HVJDMY.EN.1 is checked by HVJDMY.EN.1:4V_PJFET
HVJDMY.EN.1:4V_PJFET { @ Enclosure of HVJDMY beyond 4V_JFET PSUB RING [outer edge] == ^HVJDMY_EN_1_4V_PJFET um
    JFET_4V_PSUB_RING_FILL = JFET_4V_PSUB_RING_H OR JFET_4V_PSUB_RING
    JFET_4V_PSUB_RING_FILL_CHECK = JFET_4V_PSUB_RING_FILL AND PJFET_4V_DMY
    HVJDMY_CHECK = HVJDMY INTERACT PJFET_4V_DMY
    JFET_4V_PSUB_RING_FILL_CHECK_SIZE = SIZE JFET_4V_PSUB_RING_FILL_CHECK BY HVJDMY_EN_1_4V_PJFET
    JFET_4V_PSUB_RING_FILL_CHECK_SIZE XOR HVJDMY_CHECK
    NOT RECTANGLE JFET_4V_PSUB_RING_FILL_CHECK
    NOT RECTANGLE HVJDMY_CHECK
}
//HVJDMY.R.1U:4V_PJFET is uncheckable

JFETDMY_5.EN.1:4V_PJFET { @ Enclosure of JFETDMY_5 beyond JNW == ^JFETDMY_5_EN_1 um
    JFETDMY_5_CHECK = JFETDMY_5 AND PJFET_4V_DMY
    PJFET_4V_JNW XOR JFETDMY_5_CHECK  
}

JFETDMY_5.N.1:4V_PJFET { @ Number of JFETDMY_5 INSIDE 4V_PJFET GATE RING hole == ^JFETDMY_5_N_1 um
    JFETDMY_5_CHECK = JFETDMY_5 AND PJFET_4V_DMY
    PJFET_4V_GATE_RING_H ENCLOSE JFETDMY_5_CHECK != JFETDMY_5_N_1
    PJFET_4V_GATE_RING_H NOT ENCLOSE JFETDMY_5_CHECK
}

JNW.W.1:4V_PJFET { @ Width of JNW in channel length direction >= ^JNW_W_1 um
    INT PJFET_4V_JNW < JNW_W_1 ABUT < 90 SINGULAR REGION
}

JNW.S.2:4V_PJFET { @ Space of JNW to 4V_PJFET DRAIN OD == ^JNW_S_2 um
    PJFET_4V_JNW_SIZE = SIZE PJFET_4V_JNW BY JNW_S_2
    PJFET_4V_JNW_SIZE NOT TOUCH PJFET_4V_D_OD
    NOT RECTANGLE PJFET_4V_JNW
    NOT RECTANGLE PJFET_4V_D_OD
}

JNW.EX.1:4V_PJFET { @ Extension of JNW beyond {NW AND JFETDMY_5} in channel length direction == ^JNW_EX_1 um
    NWEL_JFETDMY5 = NWEL AND JFETDMY_5
    NWEL_CHECK_EXP = EXPAND EDGE NWEL_JFETDMY5 OUTSIDE BY 0.001
    NWEL_CHECK = NWEL_CHECK_EXP NOT INTERACT NP 
    NWEL_CHECK NOT TOUCH PJFET_4V_JNW
    NOT RECTANGLE PJFET_4V_JNW
    NOT RECTANGLE NWEL_JFETDMY5

}

JNW.EX.2:4V_PJFET { @ Extension of JNW beyond 4V_PJFET GATE OD in channel width direction == ^JNW_EX_2 um
    JFETDMY_5_EDGE = JFETDMY_5 COIN OUTSIDE EDGE PJFET_4V_NW_R
    JFETDMY_5_EDGE_SIZE_1 = EXPAND EDGE JFETDMY_5_EDGE INSIDE BY JNW_EX_2
    JFETDMY_5_EDGE_SIZE_2 = EXPAND EDGE JFETDMY_5_EDGE INSIDE BY JNW_EX_2-GRID
    JFETDMY_5_EDGE_CHECK = JFETDMY_5_EDGE_SIZE_1 NOT JFETDMY_5_EDGE_SIZE_2
    JFETDMY_5_EDGE_CHECK NOT TOUCH PJFET_4V_GATE_OD
    NOT RECTANGLE PJFET_4V_GATE_OD
}

JNW.O.1:4V_PJFET { @ Overlap of JNW and RPO in channel length direction == ^JNW_O_1 um
    JNW_RPO = (JNW AND RPO) INTERACT PJFET_4V_DMY
    INT JNW_RPO < JNW_O_1 ABUT < 90 SINGULAR REGION
    SIZE JNW_RPO BY (JNW_O_1 / 2) UNDEROVER 
}

OD_25.EN.2:4V_PJFET { @ Enclosure of OD_25 beyond 4V_JFET PSUB RING [outer edge] == ^OD_25_EN_2_4V_PJFET um
    JFET_4V_PSUB_RING_CHECK = JFET_4V_PSUB_RING INTERACT PJFET_4V_DMY
    JFET_4V_PSUB_RING_H_CHECK = JFET_4V_PSUB_RING_H INTERACT PJFET_4V_DMY
    PJFET_4V_OD25_CHECK = PJFET_4V_OD25 INTERACT PJFET_4V_DMY
    JFET_4V_PSUB_RING_CHECK_FILL = JFET_4V_PSUB_RING_CHECK OR JFET_4V_PSUB_RING_H_CHECK
    JFET_4V_PSUB_RING_CHECK_SIZE = SIZE JFET_4V_PSUB_RING_CHECK_FILL BY OD_25_EN_2_4V_PJFET 
    PJFET_4V_OD25_CHECK XOR JFET_4V_PSUB_RING_CHECK_SIZE
}


//PO CHECKS
//============
PO.A.3.1  { @ Enclosed area of non-rectangular PO >= ^PO_A_3_1 um [any one side of jog length >= ^PO_A_3_1_L um], gate to CO space = ^PO_A_3_1_S um and one CO in the hole for ULP 
  POLY_H = (HOLES INNER POLY) INTERACT GATEi == 2
  POLY_H_JOG1 = CONVEX EDGE POLY_H ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH >= PO_A_3_1_L
  POLY_H_JOG2 = CONVEX EDGE POLY_H ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= PO_A_3_1_L
  GATE_EXP =  EXPAND EDGE (GATE INSIDE EDGE OD) OUTSIDE BY PO_A_3_1_S 
  GATE_EXP_TOUCH_CO = GATE_EXP TOUCH CO == 1
  POLY_H_CHECK1 = (POLY_H WITH EDGE POLY_H_JOG1) INTERACT GATE_EXP_TOUCH_CO == 2
  POLY_H_CHECK2 = (POLY_H WITH EDGE POLY_H_JOG2) INTERACT GATE_EXP_TOUCH_CO == 2
  AREA POLY_H_CHECK1 < PO_A_3_1
  AREA POLY_H_CHECK2 < PO_A_3_1
}


//ANALOG layer rules
//==================
ANALOG.W.1 { @ Width of ANALOG >= ^ANALOG_W_1 um
  INT ANALOG < ANALOG_W_1  ABUT < 90 SINGULAR REGION
}

ANALOG.S.1 { @ Space of ANALOG >= ^ANALOG_S_1 um
  EXT ANALOG < ANALOG_S_1  ABUT < 90 SINGULAR REGION
}

ANALOG.S.2 { @ Space of ANALOG to ACT >= ^ANALOG_S_2 um
  A = NACT OR PACT
  EXT ANALOG A < ANALOG_S_2  ABUT < 90 SINGULAR REGION
}

EMPTY2i = SIZE EMPTYi BY 2.0
GATEa = GATE OR EMPTY2i
ANALOGa = ANALOG OR EMPTY2i
ODa = ODi OR EMPTY2i
CONNECT GATEa ODa
CONNECT ANALOGa ODa
ANALOG.S.3 { @ Space of ANALOG to GATE in the same OD >= ^ANALOG_S_3 um
  EXT ANALOGa GATEa < ANALOG_S_3  ABUT < 90 CONNECTED SINGULAR REGION
}

ANALOG.S.4 { @ Space of ANALOG to PO >= ^ANALOG_S_4 um
  EXT ANALOG POLYs < ANALOG_S_4  ABUT < 90 SINGULAR REGION
}

ANALOG.EX.1 { @ Extension of ANALOG beyond OD >= ^ANALOG_EX_1 um
  ENC OD ANALOG < ANALOG_EX_1 ABUT < 90 SINGULAR REGION
}

ANALOG.EX.2 { @ Enclosure of ANALOG beyond GATE in channel length directory >= ^ANALOG_EX_2 um
  ENC GATE_W ANALOG < ANALOG_EX_2 ABUT < 90 REGION
}

ANALOG.A.1 { @ Area of ANALOG >= ^ANALOG_A_1 um2
  AREA ANALOG < ANALOG_A_1 	
}

ANALOG.R.1 { @ GATE CUT ANALOG is not allowed
  GATE CUT ANALOG	
}


// FGD and NGD MOS
//2.5V FGD NMOS
FGD_NGATE = ((((GATE INTERACT NP) INTERACT PP) AND PWEL) AND OD2) AND FGDDMY
FGD_NGATE_PP = PP INTERACT FGD_NGATE
FGD_NGATE_NP = NP INTERACT FGD_NGATE
FGD_NGATE_OD = OD INTERACT FGD_NGATE
//2.5V NGD NMOS
NGD_NGATE = ((((GATE INTERACT NP) NOT INTERACT PP) AND PWEL) AND OD2) AND FGDDMY
NGD_NGATE_NP = NP INTERACT NGD_NGATE
NGD_NGATE_OD = OD INTERACT NGD_NGATE
//common layers for 2.5V FGD&NGD NMOS
FGD_PPOD_BULK_R_1 = PPOD AND FGDDMY
FGD_PPOD_BULK_H_1 = (HOLES FGD_PPOD_BULK_R_1 INNER) NOT FGD_PPOD_BULK_R_1
FGD_PPOD_BULK_R_2 = FGD_PPOD_BULK_R_1 TOUCH FGD_PPOD_BULK_H_1
FGD_PPOD_BULK_R_3 = FGD_PPOD_BULK_R_2 INTERACT (SIZE FGD_PPOD_BULK_R_2 BY (FGD_W_3/2) -GRID UNDEROVER)
FGD_PPOD_BULK_H   = (HOLES FGD_PPOD_BULK_R_3) ENCLOSE GATE 
FGD_PPOD_BULK_R   = FGD_PPOD_BULK_R_3 TOUCH FGD_PPOD_BULK_H

//common layers for FGD MOS
FGD_OD = OD AND (FGDDMY INTERACT FGD_NGATE)
FGD_GATE = GATE AND (FGDDMY INTERACT FGD_NGATE)
FGD_GATE_W = GATE_W INSIDE EDGE (FGDDMY INTERACT FGD_NGATE)

//For FGD NMOS check
//=====================
FGD.W.1 { @ Min and max Channel length of {GATE AND FGDDMY} for NGD I/O NMOS (2.5V) == ^FGD_W_1  um
  NOT RECTANGLE FGD_GATE == FGD_W_1 BY == FGD_W_2 ORTHOGONAL ONLY
}

FGD.W.2 { @ Min and max width of Channel width of {GATE AND FGDDMY} for FGD I/O NMOS (2.5V) == ^FGD_W_2  um
  PATH LENGTH FGD_GATE_W != FGD_W_2
}

FGD.W.3 { @ Min Width of {OD AND FGDDMY} for FGD I/O NMOS (2.5V) >= ^FGD_W_3 um
  INT FGD_OD < FGD_W_3 ABUT < 90 SINGULAR REGION
}

FGD.S.1 { @ Min Space of {ACTIVE OD AND FGDDMY} to P+ bulk ring for FGD I/O NMOS (2.5V) >= ^FGD_S_1  um
  A = NACT AND FGDDMY
  EXT A FGD_PPOD_BULK_R < FGD_S_1 ABUT < 90 SINGULAR REGION
}

FGD.S.2 { @ Min Space of {PO AND FGDDMY} to P+ bulk ring in channel width direction for FGD I/O NMOS (2.5V) >= ^FGD_S_2 um
  A = POLY AND FGDDMY
  EXT A FGD_PPOD_BULK_R < FGD_S_2 ABUT < 90 SINGULAR REGION
}

FGD.S.3 { @ Space of {(NP INTERACT PO) AND FGDDMY} to {(PP INTERACT PO) AND FGDDMY} for FGD I/O NMOS (2.5V) == ^FGD_S_3 um
  FGD_NGATE_NP NOT TOUCH FGD_NGATE_PP
}

FGD.EX.1 { @ Min Extension of {PO AND FGDDMY} beyond {OD AND FGDDMY} in channel width direction for FGD I/O NMOS (2.5V) >= ^FGD_EX_1 um
  A = OD AND FGDDMY
  B = POLY AND FGDDMY
  ENC A B < FGD_EX_1 ABUT < 90 SINGULAR REGION
}

FGD.EX.2 { @ Min Extension of  {{PP INTERACT PO} AND FGDDMY} beyond {PO AND FGDDMY} in channel width direction for FGD I/O NMOS (2.5V) >= ^FGD_EX_2 um
  A = POLY AND FGDDMY
  ENC A FGD_NGATE_PP < FGD_EX_2 ABUT < 90 SINGULAR REGION
}

FGD.EX.3 { @ Min and max Extension of {PO AND FGDDMY} beyond beyond {{PP INTERACT PO} AND FGDDMY} in channel length direction for FGD I/O NMOS (2.5V) == ^FGD_EX_3 um 
  ENC FGD_NGATE_PP POLY < FGD_EX_3 ABUT < 90 SINGULAR REGION
  A = FGD_NGATE NOT PP
  NOT RECTANGLE A
  SIZE A BY FGD_EX_3/2 UNDEROVER
}

FGD.EX.4 { @ Min Extension of {{NP INTERACT PO} AND FGDDMY} beyond {PO AND FGDDMY} in channel width direction for FGD I/O NMOS (2.5V) >= ^FGD_EX_4 um
  A = POLY AND FGDDMY
  ENC A FGD_NGATE_NP < FGD_EX_4 ABUT < 90 SINGULAR REGION
}


//FGD.A.1 is checked by FGD.W.1

FGD.N.1 { @ Min Number of CO on {PO AND FGDDMY} for FGD I/O NMOS (2.5V) >= ^FGD_N_1 um 
  A = (POLY AND FGDDMY) INTERACT FGD_NGATE
  A NOT INTERACT CO >= FGD_N_1
}
//FGDDMY.R.1U is uncheckable

// OD_25 rules check
//===================

OD_25.EN.3 { @ Enclosure of {OD_25 AND FGDDMY} beyond P+ BULK RING >= ^OD_25_EN_3 um
  DUM_CHECK = OD25 AND FGDDMY
  ENC FGD_PPOD_BULK_R DUM_CHECK < OD_25_EN_3 ABUT < 90 SINGULAR REGION
}

OD_25.EN.4 { @ Enclosure of OD_25 beyond FGDDMY == ^OD_25_EN_4 um
    OD_25_CHECK = OD25 INTERACT FGDDMY
    OD_25_CHECK XOR FGDDMY
    FGDDMY NOT INTERACT OD25
}
//For NGD NMOS check
//=====================

//common layers for NGD MOS
NGD_OD = OD AND (FGDDMY INTERACT NGD_NGATE)
NGD_GATE = GATE AND (FGDDMY INTERACT NGD_NGATE)
NGD_GATE_W = GATE_W INSIDE EDGE (FGDDMY INTERACT NGD_NGATE)
NGD.W.1 { @ Min and max Channel length of {GATE AND FGDDMY} for NGD I/O NMOS (2.5V) == ^NGD_W_1 um
  NOT RECTANGLE NGD_GATE == NGD_W_1 BY == NGD_W_2 ORTHOGONAL ONLY
}

NGD.W.2 { @ Min and max width of Channel width of {GATE AND FGDDMY} for NGD I/O NMOS (2.5V) == ^NGD_W_2 um
  PATH LENGTH NGD_GATE_W != NGD_W_2
}

NGD.W.3 { @ Min Width of {OD AND FGDDMY} for NGD I/O NMOS (2.5V) >= ^NGD_W_3 um 
  INT NGD_OD < NGD_W_3 ABUT < 90 SINGULAR REGION
}

NGD.S.1 { @ Min Space of {ACTIVE OD AND FGDDMY} to P+ bulk ring for NGD I/O NMOS (2.5V) >= ^NGD_S_1 um
  A = NACT AND FGDDMY
  EXT A FGD_PPOD_BULK_R < NGD_S_1 ABUT < 90 SINGULAR REGION
}

NGD.S.2 { @ Min Space of {PO AND FGDDMY} to P+ bulk ring in channel width direction for NGD I/O NMOS (2.5V) >= ^NGD_S_2 um
  A = POLY AND FGDDMY
  EXT A FGD_PPOD_BULK_R < NGD_S_2 ABUT < 90 SINGULAR REGION
}

NGD.EX.1 { @ Min Extension of {PO AND FGDDMY} beyond {ACTIVE OD AND FGDDMY} in channel width direction for NGD I/O NMOS (2.5V) >= ^NGD_EX_1 um
  A = ((NP AND OD) NOT NWEL) AND FGDDMY
  B = POLY AND FGDDMY
  ENC A B < NGD_EX_1 ABUT < 90 SINGULAR REGION
}

NGD.EX.4 { @ Min Extension of {{NP INTERACT PO} AND FGDDMY} beyond {PO AND FGDDMY} in channel width direction for NGD I/O NMOS (2.5V) >= ^NGD_EX_4 um
  A = POLY AND FGDDMY
  ENC A NGD_NGATE_NP < NGD_EX_4 ABUT < 90 SINGULAR REGION
}

//NGD.A.1 is checked by NGD.W.1

NGD.N.1 { @ Min Number of CO on {PO AND FGDDMY} for NGD I/O NMOS (2.5V) >= ^NGD_N_1 um
  A = (POLY AND FGDDMY) INTERACT NGD_NGATE
  A NOT INTERACT CO >= NGD_N_1
}

//Serpentine type poly resistor check
//========================================
PO_RES_SERP = (POLY NOT OD) AND PO_RES_RPO 
PORES_SERP = PO_RES_SERP INTERACT SERPDMY
PORES_SERP_T = (POLY INTERACT SERPDMY) NOT RPO

SERRES.W.1 { @ Width of {PO AND RPO} for Unsilicided P+ PO Resistor (serpentine type) == ^SERRES_W_1 um
  INT PORES_SERP < SERRES_W_1 ABUT < 90 SINGULAR REGION
  SIZE PORES_SERP BY SERRES_W_1/2 UNDEROVER
}

SERRES.S.1 { @ Space of {PO AND RPO} for Unsilicided P+ PO Resistor (serpentine type) == ^SERRES_S_1 um
  A = CONVEX EDGE PORES_SERP ANGLE1 == 270 ANGLE2 == 270
  NOT LENGTH A == SERRES_S_1
}

SERRES.S.2 { @ Space of RPO to terminal side poly for Unsilicided P+ PO Resistor (serpentine type) >= ^SERRES_S_2 um
  A = RPO INTERACT SERPDMY
  B = (POLY NOT OD) INTERACT RPDMY
  EXT A B < SERRES_S_2 ABUT < 90 SINGULAR REGION 
}

SERRES.S.3 { @ Space of {{PO NOT OD} AND RPO} to OD [inner edge] for Unsilicided P+ PO Resistor (serpentine type) >= ^SERRES_S_3 um
  EXT PORES_SERP OD < SERRES_S_3 ABUT < 90 SINGULAR REGION
  PORES_SERP INTERACT OD
}

SERRES.EX.1 { @ Extension of RPO beyond {PO AND RPO} for Unsilicided P+ PO Resistor (serpentine type) >= ^SERRES_EX_1 um
  A = (POLY INTERACT SERPDMY) NOT RPO
  B = PORES_SERP NOT COIN OUTSIDE EDGE A
  ENC B RPO < SERRES_EX_1 ABUT < 90 REGION
}

SERRES.N.1 { @ Number of the resistor SQ of Unsilicided P+ PO resistor (serpentine type) (SQ=total length/0.04 um) >= ^SERRES_N_1 um
  PO_SERP = POLY AND (RPO AND SERPDMY)
  AREA PO_SERP < (SERRES_N_1 * SERRES_W_1 * 0.04) 
}

//SERRES.R.2U is un-checkable rule
//SERPDMY.R.1U is un-checkable rule

SERRES.L.1 { @ Length of {PO AND RPO} for Unsilicided P+ PO Resistor (serpentine type) >= ^SERRES_L_1 um
  A = CONVEX EDGE PORES_SERP ANGLE1 == 90 ANGLE2 == 90
  B = LENGTH A == SERRES_S_1 + SERRES_W_1 * 2
  INT B < SERRES_L_1 ABUT < 90 OPPOSITE REGION
}

SERRES.N.3 { @ Number of CO for one terminal side poly >= ^SERRES_N_3
	PORES_SERP_T NOT INTERACT CO >= SERRES_N_3
}

RH.EX.1 { @ Min and max Extension of RH beyond RPO for Unsilicided P+ PO Resistor (serpentine type) under RPO == ^RH_EX_1 um
  A = (RPO INTERACT RH) INTERACT SERPDMY
  B = (RH INTERACT RPO) INTERACT SERPDMY
  A XOR B
}

SERPDMY.EX.1 { @ Min and max Extension of SERPDMY beyond RPO for Unsilicided P+ PO Resistor (serpentine type) under RPO == ^SERPDMY_EX_1 um
  (RPO INTERACT SERPDMY) XOR SERPDMY
}

#IFDEF DFM
#IFDEF Recommended

#IFDEF _SERRESN2_
#IFDEF CHECK_SERRESN2_
SERRESN2_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
SERRESN2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
SERRESN2_POCell = SERRESN2_POCellIn AND SERRESN2_POCellOut
SERRESN2_POMarker = POi AND RRuleRecommended
SERRESN2_PO = (( SERRESN2_POCell OR SERRESN2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block


RR:RE:SERRES.N.2 { @ Recommended Number of the resistor SQ of Unsilicided P+ PO resistor (serpentine type) (SQ=total length/0.04 um) <= ^SERRES_N_2_R 
  PO_SERP = SERRESN2_PO AND (RPO AND SERPDMY)
  AREA PO_SERP  > (SERRES_N_2_R * SERRES_W_1 * 0.04)
}
// <SERRES.N.2.R> is checked by RR:RE:SERRES.N.2
#ENDIF
#ENDIF
#ENDIF 
#ENDIF 


//SBD CHECKS
//================


EMPTY_mf = SIZE EMPTYi BY 2.0 
NW_mf   = EMPTY_mf OR NWi
RW_mf   = EMPTY_mf OR RWi
PWEL_mf = EMPTY_mf OR PWELi
NWR_mfT = EMPTY_mf OR NWRiT
PO_mf   = EMPTY_mf OR POi
ILP1_mf = EMPTY_mf OR ILP1i
SRDPO_mf = EMPTY_mf OR SRDPO
NSD_mf  = EMPTY_mf OR NSDc
PSD_mf  = EMPTY_mf OR PSDc
NSTP_mf = EMPTY_mf OR NSTPi
PSTP_mf = EMPTY_mf OR PSTPi
CO_mf   = EMPTY_mf OR COi
M1_mf   = EMPTY_mf OR M1i
M2_mf   = EMPTY_mf OR M2i
M3_mf   = EMPTY_mf OR M3i
M4_mf   = EMPTY_mf OR M4i
M5_mf   = EMPTY_mf OR M5i
M6_mf   = EMPTY_mf OR M6i
VIA1_mf = EMPTY_mf OR VIA1i
VIA2_mf = EMPTY_mf OR VIA2i
VIA3_mf = EMPTY_mf OR VIA3i
VIA4_mf = EMPTY_mf OR VIA4i
VIA5_mf = EMPTY_mf OR VIA5i
RV_mf   = EMPTY_mf OR RVi
CB1_mf  = EMPTY_mf OR CB1i
CB2_mf  = EMPTY_mf OR CB2i
AP_mf   = EMPTY_mf OR APi
Cu_PPI_mf = EMPTY_mf OR Cu_PPIi
PM1_mf   = EMPTY_mf OR PM1i
PM2_mf   = EMPTY_mf OR PM2i
UBM_mf  = EMPTY_mf OR UBMi

//======================================
CONNECT NSTP_mf PSD_mf // For butted pickup
CONNECT PSTP_mf NSD_mf // For butted pickup
CONNECT CO_mf PSD_mf      // For butted CO
CONNECT CO_mf NSD_mf      // For butted CO
CONNECT CO_mf ILP1_mf       // For butted CO
CONNECT M1_mf ILP1_mf NSTP_mf PSTP_mf PSD_mf NSD_mf BY CO_mf
CONNECT M1_mf NWR_mfT BY CO_mf // prevent from connection shielding
CONNECT M1_mf M2_mf BY VIA1_mf
CONNECT M2_mf M3_mf BY VIA2_mf
CONNECT M3_mf M4_mf BY VIA3_mf
CONNECT M4_mf M5_mf BY VIA4_mf
CONNECT M5_mf M6_mf BY VIA5_mf
CONNECT CB1_mf M6_mf
#IFDEF SINGLE_PASSIVATION
CONNECT UBM_mf M6_mf BY CB1_mf
CONNECT UBM_mf AP_mf BY EMPTY_mf
#ELSE
#IFDEF WITH_APRDL
CONNECT M6_mf AP_mf  BY RV_mf
#ENDIF
CONNECT M6_mf AP_mf  BY CB1_mf
CONNECT CB2_mf AP_mf         
#IFNDEF WLCSP
CONNECT UBM_mf AP_mf BY CB2_mf
#ELSE
CONNECT Cu_PPI_mf AP_mf BY CB2_mf
CONNECT PM2_mf Cu_PPI_mf
CONNECT UBM_mf PM2_mf
#ENDIF
#ENDIF

SBDOD    = ( OD AND SBDDMY ) AND DNW

DNW_SBD   = DNW INTERACT SBDOD
NW_R_SBD_PRE = DONUT (NWEL AND SBDDMY)
NW_R_SBD_H = HOLES NW_R_SBD_PRE INNER
NW_R_SBD = NW_R_SBD_PRE TOUCH NW_R_SBD_H

NP_R_SBD   = NP INTERACT SBDOD 
NP_SBD_HOLE = HOLES NP_R_SBD INNER
NP_SBD_ALL = NP_R_SBD OR NP_SBD_HOLE

NPOD_SBD = SBDOD INTERACT NP
PPOD_SBD = SBDOD AND PP

NPOD_SBD_GAP = EXPAND EDGE NPOD_SBD OUTSIDE BY SBD_S_1
NPOD_SBD_G   = NPOD_SBD_GAP TOUCH PPOD_SBD
PPOD_SBD_GAP = EXPAND EDGE PPOD_SBD OUTSIDE BY SBD_S_1
PPOD_SBD_G   = PPOD_SBD_GAP TOUCH NPOD_SBD

SBDOD_ALL = ( NPOD_SBD OR PPOD_SBD ) OR NPOD_SBD_G 

NPOD_SBD_W = NPOD_SBD TOUCH OUTSIDE EDGE PPOD_SBD_G
NPOD_SBD_L = NPOD_SBD NOT TOUCH OUTSIDE EDGE PPOD_SBD_G
PPOD_SBD_W = PPOD_SBD TOUCH OUTSIDE EDGE NPOD_SBD_G
PPOD_SBD_L = PPOD_SBD NOT TOUCH OUTSIDE EDGE NPOD_SBD_G

SBD.W.1 { @ Width of  {OD INTERACT NP RING} for Schottky Barrier Diode >= ^SBD_W_1 um
    LENGTH NPOD_SBD_W > 0 < SBD_W_1
}

SBD.W.1.1 { @ Width of {OD INTERACT NP RING} for Schottky Barrier Diode <= ^SBD_W_1_1 um
    PATH LENGTH NPOD_SBD_W > SBD_W_1_1 < 999
}

SBD.W.2 { @ Width of P+OD for Schottky Barrier Diode >= ^SBD_W_2 um
    LENGTH PPOD_SBD_W > 0 < SBD_W_2
}

SBD.W.2.1 { @ Width of P+OD for Schottky Barrier Diode <= ^SBD_W_2_1 um
    PATH LENGTH PPOD_SBD_W > SBD_W_2_1 < 999 
}

SBD.W.3 { @ Minimum and Maximum Width of NW RING for Schottky Barrier Diode  == ^SBD_W_3 um
    INT NW_R_SBD < SBD_W_3 ABUT < 90 SINGULAR REGION
    SIZE NW_R_SBD BY SBD_W_3/2 UNDEROVER
}

//SBD.R.1 is checked by SBD.S.1
SBD.S.1 { @ Space of {OD INTERACT NP RING} to P+OD for Schottky Barrier Diode == ^SBD_S_1 um
    EXT NPOD_SBD PPOD_SBD < SBD_S_1 ABUT < 90 SINGULAR REGION
    NPOD_SBD INTERACT PPOD
    NPOD_SBD NOT TOUCH NPOD_SBD_G == 2
    A = NPOD_SBD TOUCH NPOD_SBD_G == 2
    B = A TOUCH OUTSIDE EDGE NPOD_SBD_G 
    C = INT B < SBD_S_1 ABUT == 90 INTERSECTING ONLY REGION 
    NPOD_SBD INTERACT C 
}

SBD.S.2 { @ Space of  {OD INTERACT NP RING} for Schottky Barrier Diode  == ^SBD_S_2 um
    EXT NPOD_SBD < SBD_S_2 ABUT < 90 SINGULAR REGION
    NPOD_SBD_SIZE = SIZE NPOD_SBD BY SBD_S_2/2 OVERUNDER
    NW_R_SBD_H INTERACT NPOD_SBD_SIZE > 1  
}

SBD.S.3 { @ Space of NW RING to P+OD for Schottky Barrier Diode  == ^SBD_S_3 um
    EXT NW_R_SBD PPOD_SBD < SBD_S_3 ABUT < 90 SINGULAR REGION
    SBDOD_REC = SIZE SBDOD BY SBD_S_1/2 OVERUNDER
    SBDOD_REC_SIZE = SIZE SBDOD_REC BY SBD_S_3
    NW_R_SBD_CHECK = NW_R_SBD OR SBDOD_REC_SIZE
    NOT RECTANGLE NW_R_SBD_CHECK
    NOT RECTANGLE SBDOD
    NOT RECTANGLE SBDOD_REC
}

SBD.EX.1 { @ Extension of NP RING beyond {OD INTERACT NP RING} for Schottky Barrier Diode == ^SBD_EX_1 um
    ENC NPOD_SBD NP_SBD_ALL < SBD_EX_1 ABUT < 90 SINGULAR REGION
    NPOD_SBD_SIZE = SIZE NPOD_SBD BY SBD_EX_1
    NP_SBD_ALL XOR NPOD_SBD_SIZE
}

SBD.O.1 { @ Overlap of NP RING and  {OD INTERACT NP RING} for Schottky Barrier Diode == ^SBD_O_1 um
    NP_CHECK = NPOD_SBD AND NP_R_SBD
    NP_CHECK_DONUT = DONUT NP_CHECK
    NP_CHECK XOR NP_CHECK_DONUT
    INT NP_CHECK < SBD_O_1 ABUT < 90 SINGULAR REGION
    SIZE NP_CHECK BY SBD_O_1/2 UNDEROVER
}

SBD.O.2 { @ Overlap of NW RING and DNW for Schottky Barrier Diode == ^SBD_O_2 um
    NW_CHECK = NW_R_SBD AND DNW
    INT NW_CHECK < SBD_O_2 ABUT < 90 SINGULAR REGION
    SIZE NW_CHECK BY SBD_O_2/2 UNDEROVER
}



SBD.R.1 { @ The {OD INTERACT NP RING} of the SBD must be located between the P+OD regions
    @DRC flag :
    @ (1).NP RING touch PP not equal to 2;
    @ (2).SPACE OF {PP TOUCH NP RING} not equal to 1.18 um
    (PP INTERACT NP_R_SBD) NOT INTERACT SBDOD 
    PP_CHECK = (PP INTERACT NP_R_SBD) INTERACT SBDOD
    NP_R_SBD TOUCH PP_CHECK != SBD_R_1_1
    NP_R_SBD NOT TOUCH PP_CHECK

    EXT PP_CHECK < SBD_R_1_2 ABUT < 90 SINGULAR REGION
    PP_CHECK_SIZE = SIZE PP_CHECK BY SBD_R_1_2/2 OVERUNDER
    NW_R_SBD_H INTERACT PP_CHECK_SIZE > 1

    A = NPOD_SBD TOUCH PP_CHECK == 2
    B = A TOUCH OUTSIDE EDGE NPOD_SBD_G 
    C = INT B < SBD_S_1 ABUT == 90 INTERSECTING ONLY REGION 
    NPOD_SBD INTERACT C 
}

SBD.R.2 { @ The widths of all the  {OD INTERACT NP RING} and the P+OD are the same for Schottky Barrier Diode 
    NPOD_SBD_SIZE = SIZE NPOD_SBD BY SBD_S_1 / 2
    PPOD_SBD_SIZE = SIZE PPOD_SBD BY SBD_S_1 / 2
    OD_CHECK = NPOD_SBD_SIZE OR PPOD_SBD_SIZE
    NOT RECTANGLE OD_CHECK
}

M1_NP_SBD_CHECK = (M1_mf AND CO) AND NPOD_SBD
CONNECT M1_mf M1_NP_SBD_CHECK
SBD.R.3 { @ For NF >= 2, all the {OD INTERACT NP RING} are connected as the same potential and all the P+OD are connected as the same potential for Schottky Barrier Diode
    X = SBDDMY INTERACT NPOD_SBD <= 2 
    Y = SBDDMY NOT X
    NPOD_SBD NOT INTERACT CO
    Y INTERACT M1_NP_SBD_CHECK > 1 BY NET
    Y INTERACT PSTP_mf > 1 BY NET
}

SBD.R.4 { @ NW RING OVERLAP P+OD is not allowed for Schottky Barrier Diode
    NW_R_SBD AND PPOD_SBD
}

SBD.N.1 { @ Maximum Finger Number of the {OD INTERACT NP RING}  for Schottky Barrier Diode <= ^SBD_N_1 um
    X = SBDDMY INTERACT NPOD_SBD <= SBD_N_1
    Y = SBDDMY NOT X 
    NPOD_SBD INTERACT Y
}

SBD.L.1 { @ Length of {OD INTERACT NP RING} for Schottky Barrier Diode == ^SBD_L_1 um
    NOT RECTANGLE NPOD_SBD	      
    INT NPOD_SBD < SBD_L_1 ABUT < 90 SINGULAR REGION
    SIZE NPOD_SBD BY SBD_L_1 / 2 UNDEROVER
}

SBD.L.2 { @ Length of P+OD for Schottky Barrier Diode == ^SBD_L_2 um
    NOT RECTANGLE PPOD_SBD	      
    INT PPOD_SBD < SBD_L_2 ABUT < 90 SINGULAR REGION
    SIZE PPOD_SBD BY SBD_L_2 / 2 UNDEROVER
}

SBDDMY.S.1 { @ Space of SBDDMY >= ^SBDDMY_S_1 um
    EXT SBDDMY < SBDDMY_S_1 ABUT < 90 SINGULAR REGION
}

SBDDMY.EX.1 { @ Extension of SBDDMY beyond NW RING == ^SBDDMY_EX_1 um
    NW_R_PRE = DONUT (NWEL INTERACT SBDDMY)
    NW_R_H = HOLES NW_R_PRE INNER
    NW_R = NW_R_PRE TOUCH NW_R_H
    NW_R_SBD_ALL = NW_R OR NW_R_H
    SBDDMY XOR NW_R_SBD_ALL
}

#ENDIF
#ENDIF

//T-N45-CL-DR-001 Impact Rules List
//=========================================
#IFNDEF DFM_ONLY
#IFDEF FRONT_END
DRC UNSELECT CHECK PO.S.9 SR_DPO.S.9 RES.W.1:OD RES.W.1:PO RES.EN.1 
DRC UNSELECT CHECK PO.R.4 PP.R.1 NW.S.3 NW.S.4 NW.S.5 NW.S.6 NW.S.7 NW.A.1 CO.S.3 CO.S.5 OD.R.1 OD.A.1 OD.A.2 OD.L.2 NP.R.1 NP.A.1 NP.EX.1 PP.R.1 PP.EN.1 PP.EX.2 RPO.A.2 RPO.S.4 NP.O.1
// <PO.S.9> is checked by PO.S.9.a

PO.S.9.a { @ Space [in same RPO](Except the SERPDMY region) >= 0.18 
  A = POLY INSIDE EDGE RPO
  (EXT A < PO_S_9 ABUT < 90 REGION) NOT INSIDE SERPDMY
}
// <SR_DPO.S.9> is checked by SR_DPO.S.9.a

SR_DPO.S.9.a { @ Space of {(PO OR SR_DPO) AND RPO} (Except the SERPDMY region) >= 0.18 
  SR_PO_RPO = SR_POLY AND RPO
  (EXT SR_PO_RPO < SRDPO_S_9 ABUT < 90 SINGULAR REGION) NOT INSIDE SERPDMY
}
// <RES.W.1:OD> is checked by RES.W.1.a:OD

RES.W.1.a:OD { @ Width of unsilicide OD resistor (Except the SERPDMY region) >= ^RES_W_1
  (INT OD_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SERPDMY
}

// <RES.W.1:PO> is checked by RES.W.1.a:PO

RES.W.1.a:PO { @ Width of unsilicide PO resistor (Except the SERPDMY region) >= ^RES_W_1
  (INT PO_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SERPDMY
}
// RES.W.1.a is checked by RES.W.1.a:OD and RES.W.1.a:PO
// <RES.EN.1> is checked by RES.EN.1.a

RES.EN.1.a { @ RH enclosure of unsilicided/silicided OD/PO resistor (Except the SERPDMY region) >= ^RES_EN_1
  (ENC OD_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SERPDMY
  (ENC PO_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SERPDMY
}

// <PP.R.1> is checked by PP.R.1.a

PP.R.1.a { @ PP must fully cover {PMOS GATE SIZING 0.08 um}  (except 2.5V_PO_NJFET and FGD I/O NMOS)>= 0.08 um
  CHECK_GATE = GATE_PP NOT INSIDE SRAM_REGION
  EXGATE_PP = SIZE CHECK_GATE BY PP_R_1
  (EXGATE_PP NOT PP) NOT INSIDE (NJFET_PO_2d5V_DMY OR (FGDDMY INTERACT PP))
}

#IFDEF CHECK_LOW_DENSITY
DRC UNSELECT CHECK OD.DN.2

// <OD.DN.2> is checked by OD.DN.2.a

OD.DN.2.a { @ Min. OD density over window 150 step 75 (except the SERPDMY region) >= 20% 
    ODx_CHECK = ODx NOT SERPDMY
    CHIP_NOT_ODEXC_CHECK = CHIP_NOT_ODEXC NOT SERPDMY
    ERR_WIN = DENSITY ODx_CHECK CHIP_NOT_ODEXC_CHECK < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx_CHECK)/AREA(CHIP_NOT_ODEXC_CHECK) ]
    F = WITH WIDTH (ERR_WIN NOT (OD_EXC OR SERPDMY)) >= OD_DN_2_E
    DENSITY F ODx_CHECK CHIP_NOT_ODEXC_CHECK < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.a.density
          [ !AREA(F)+AREA(ODx_CHECK)/AREA(CHIP_NOT_ODEXC_CHECK) ]
}
#ENDIF

// <NP.R.1> is checked by NP.R.1.a

NP.R.1.a { @ NP must fully cover {NMOS GATE SIZING ^NP_R_1 um}  (except 2.5V_PO_PJFET and FGD I/O NMOS) >= 0.08 um
  CHECK_GATE = GATE_NP NOT INSIDE SRAM_REGION
  EXGATE_NP = SIZE CHECK_GATE BY NP_R_1
  (EXGATE_NP NOT NP) NOT INSIDE (PJFET_PO_2d5V_DMY OR (FGDDMY INTERACT PP))
}

// <NW.S.3> is checked by NW.S.3.a

NW.S.3.a { @ NW1V space to NW2V with different potentials (*) (except 4V_NJFET) >= 1 
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  (EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED) NOT INSIDE (SRAM_EXCLUDE OR NJFET_4V_DMY)
}

// <NW.S.4> is checked by NW.S.4.a

NW.S.4.a { @ Space of 2 NW2V with different potentials (*) (except 4V_NJFET) >= 1 
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE (SRAM_EXCLUDE OR NJFET_4V_DMY)
}

// <NW.S.5> is checked by NW.S.5.a

NW.S.5.a { @ Space to PW STRAP (except 4V_NJFET) >= 0.08 
    (EXT NWi PPOD < NW_S_5 ABUT < 90 SINGULAR REGION) NOT INSIDE NJFET_4V_DMY
    (PPOD CUT NWi) NOT INSIDE NJFET_4V_DMY
}

// <NW.S.6> is checked by NW.S.6.a

NW.S.6.a { @ Space to N+ ACTIVE (except NW resistor) (except 4V_PJFET) >= 0.08 
  A = NPOD NOT INTERACT RNWEL
  (EXT NWi A < NW_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE (SRAM_REGION OR PJFET_4V_DMY)
  (A CUT NWi) NOT INSIDE (SRAM_REGION OR PJFET_4V_DMY)
}

// <NW.S.7> is checked by NW.S.7.a

NW.S.7.a { @ Space to {N+ ACTIVE INTERACT OD2} (except 4V_PJFET) >= 0.22 
  (EXT NWi NACT2 < NW_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE PJFET_4V_DMY
}

// <CO.S.3> is checked by CO.S.3.a

CO.S.3.a { @ Space to GATE (Overlap of GATE is not allowed) [space >= 0.035 um is allowed inside SRAM word line driver covered by layer 186;5 or 186;4] (Except SRAMDMY;0 (186;0) region and 2.5V_PO_JFET) >= 0.04 
  A = EXT COOD GATE < CO_S_3 ABUT < 90 SINGULAR REGION
  (A NOT INSIDE SRAMDMY_PERI) NOT INSIDE (SRAM_REGION OR JDMY)
  (CO AND GATE) NOT INSIDE (SRAM_REGION OR JDMY )
	// Checks for SRAM periphery are implemented by WLD.R.2
}

// <CO.S.5> is checked by CO.S.5.a

CO.S.5.a { @ {CO inside OD} space to I/O GATE (Except 2.5V_PO_JFET) >= 0.08 
  (EXT COOD HV_GATE < CO_S_5 ABUT < 90 SINGULAR REGION) NOT INSIDE JDMY
}

// <RPO.S.4> is checked by RPO.S.4.a

RPO.S.4.a { @ Min. RPO space to gate(except 2.5V_PO_JFET) >= ^RPO_S_4 um 
  NOGT = GATE NOT (SDI OR ICOVL)

  (EXT RPO NOGT < RPO_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE JDMY
  (RPO AND NOGT) NOT INSIDE JDMY
}

// <OD.R.1> is checked by OD.R.1.a

OD.R.1.a { @ OD must be fully covered by {NP OR PP} except for {(DOD OR SR_DOD) OR NWDMY}   (except 4VPJFET and 2.5V_PO_JFET and SBDDMY)
  (((OD NOT INTERACT NWRES) NOT LOGO) NOT IMP) NOT INSIDE ((JDMY OR PJFET_4V_DMY) OR SBDDMY)
}

// <PO.R.4> is checked by PO.R.4.a

PO.R.4.a { @ PO intersecting OD must form 2 or more diffusions. (Except CSRDMY region and  2.5V_PO_JFET)   
  WAIVE_REGION = (LOGO OR (RODMY AND SRAMDMY)) OR CSRDMY

  FOD = EXPAND EDGE (GATE INSIDE EDGE OD) BY GRID
  ((GATE NOT INSIDE WAIVE_REGION) NOT INTERACT FOD >= 2) NOT INSIDE JDMY
}

// <NW.A.1> is checked by NW.A.1.a

NW.A.1.a { @ Area (except 4V_NJFET) >= 0.64 
  (AREA NWEL < NW_A_1) NOT INSIDE NJFET_4V_DMY
}

// <OD.A.1> is checked by OD.A.1.a

OD.A.1.a { @ Area (This check doesn't include the patterns filling 0.06 um x 0.26 um rectangular tiles)(except 4V_NJFET) >= 0.035 
  A = AREA ((ODs NOT INSIDE SRAM_REGION) NOT OD_DMY) < OD_A_1
  (NOT ENCLOSE RECTANGLE A OD_A_1_W OD_A_1_L ORTHOGONAL ONLY) NOT INSIDE NJFET_4V_DMY
}

// <OD.A.2> is checked by OD.A.2.a

OD.A.2.a { @ Area [with all of edge lengths < 0.21 um](except 4V_NJFET) >= 0.055 
  A = AREA (ODs NOT INSIDE SRAM_REGION) < OD_A_2
  B = LENGTH A >= OD_A_2_L
  (A NOT WITH EDGE B) NOT INSIDE NJFET_4V_DMY
}

// <RPO.A.2> is checked by RPO.A.2.a

RPO.A.2.a { @ Enclosed area(except 2.5V_PO_JFET) >= 1.0 
  A = HOLES RPO INNER
  B = A NOT RPO
  (AREA B < RPO_A_2) NOT INSIDE JDMY
}  

// <NP.A.1> is checked by NP.A.1.a

NP.A.1.a { @ Area(except 4V_NJFET) >= 0.11 
  (AREA (NP NOT INSIDE SRAM_EXCLUDE) < NP_A_1) NOT INSIDE NJFET_4V_DMY
}

// <NP.O.1> is checked by NP.O.1.a

NP.O.1.a { @ Overlap of OD (except SBDDMY region) >= NP_O_1 um
  (INT OD NP < NP_O_1  ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE SBDDMY
}

// <PP.EN.1> is checked by PP.EN.1.a

PP.EN.1.a { @ {NP OR PP} enclosure of PO (except DPO and 2.5V_PO_JFET) >= ^PP_EN_1 
  WAIVE_REGION = COPY SRAM_REGION
  A = POLY NOT INSIDE WAIVE_REGION  
  (ENC A IMP < PP_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE (WAIVE_REGION OR JDMY)
  ((POLY NOT LOGO) NOT IMP) NOT INSIDE JDMY
}

// <PP.EX.2> is checked by PP.EX.2.a

PP.EX.2.a { @ Extension on PW STRAP (except SEALRING_ALL (162;2), 4VPJFET and 2.5V_PO_JFET) >= 0.02 
  PSTP_CHECK = (PSTP NOT SEALRING_EXCLUDE) NOT INSIDE SRAM_REGION 
  (ENC PSTP_CHECK PP < PP_EX_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE (JDMY OR PJFET_4V_DMY)
  X = ENC [PSTP_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE (JDMY OR PJFET_4V_DMY)
  ((EXPAND EDGE ODIMP INSIDE BY 0.001) AND PSTP_CHECK) NOT INSIDE (JDMY OR PJFET_4V_DMY)
}

// <NP.EX.1> is checked by NP.EX.1.a

NP.EX.1.a { @ Extension on N+ACTIVE(except NWROD ,SBDDMY, 4VPJFET and 2.5V_PO_JFET) >= ^NP_EX_1
  NACT_CHECK = ((NACT NOT ODWR) NOT OD_DMY) NOT INSIDE SRAM_REGION
  (ENC NACT_CHECK NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE ((JDMY OR PJFET_4V_DMY) OR SBDDMY)
  X = ENC [NACT_CHECK] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE ((JDMY OR PJFET_4V_DMY) OR SBDDMY)
  ((EXPAND EDGE ODIMP INSIDE BY 0.001) AND NACT_CHECK) NOT INSIDE ((JDMY OR PJFET_4V_DMY) OR SBDDMY)
}

// <OD.L.2> is checked by OD.L.2.a

OD.L.2.a { @ Max. OD length between 2 CO or CO to OD line end when OD width(except {RFDMY AND RFIP_DMY} and {MOMDMY(155;21) SIZING 1.2um}) (except 2.5V_PO_JFET and 4V_JFET) <= ^OD_L_2_W um  ^OD_L_2 um
  OD_CHECK = (INOD NOT RFIP) NOT (SIZE MOMDMY BY 1.2)
  LONGP = AREA OD_CHECK > OD_W_1 * OD_L_2	
  X = LONGP INTERACT COOD
  CHECK_COOD = COOD INTERACT X
  A = SIZE CHECK_COOD BY OD_L_2 / 2 INSIDE OF X STEP OD_S_1*0.7
  LINEN = X INTERACT A == 1
  P2P = X INTERACT A > 1
  B = A INTERACT LINEN
  C = SIZE B BY OD_L_2 / 2 INSIDE OF LINEN STEP OD_S_1*0.7
  BAD = (LINEN NOT C) OR (P2P NOT A)
  BAD_EDGE = BAD COIN INSIDE EDGE OD
  ERR = INT BAD_EDGE < OD_L_2_W ABUT < 90 REGION
  (X INTERACT ERR ) NOT INSIDE (JDMY OR HVJDMY)
}

#IFDEF NW_SUGGESTED
DRC UNSELECT CHECK NW.S.3__NW.S.4:SUGGESTED
// <NW.S.3__NW.S.4:SUGGESTED> is checked by NW.S.3__NW.S.4.a:SUGGESTED
NW.S.3__NW.S.4.a:SUGGESTED { @ A more conservative way to check NW.S.3, NW.S.4 with 
		          @ varied operating voltages determination of nwels.(except for 4V_NJFET region)
  NW1V = NWEL OUTSIDE OD2
  NW2V = NWEL NOT OUTSIDE OD2
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  (EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 NOT CONNECTED SINGULAR REGION) NOT INSIDE NJFET_4V_DMY
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE NJFET_4V_DMY
}
#ENDIF

#ENDIF  // FRONT_END
#ENDIF  //DFM_ONLY

#IFDEF DFM       // start DFM check
    
#IFDEF Required

#IFDEF CHECK_POEX2_
#IFDEF _POEX2_
DRC UNSELECT CHECK RR:AR:PO.EX.2

// <RR:AR:PO.EX.2> is checked by RR:AR:PO.EX.2.a

RR:AR:PO.EX.2.a { @ Recommended OD extension on PO.(except 2.5V_PO_JFET region) >= ^PO_EX_2_R um
  (ENC POLY POEX2_OD < PO_EX_2_R ABUT < 90 SINGULAR OPPOSITE REGION) NOT INSIDE ((LOGO OR TCDDMY) OR (SRAM_REGION OR JDMY))
}
#ENDIF // _POEX2_
#ENDIF // CHECK_POEX2_
#ENDIF // Required

#IFDEF Recommended

#IFDEF CHECK_COEN1_
#IFDEF _COEN1_
DRC UNSELECT CHECK RR:RE:SP:CO.EN.1
// <RR:RE:SP:CO.EN.1> is checked by RR:RE:SP:CO.EN.1.a

RR:RE:SP:CO.EN.1.a { @ Recommended enclosure by OD(except {ANALOG INTERACT JDMY} and 4V_JFET region) >= ^CO_EN_1_R um
  (ENC COEN1_CO OD < CO_EN_1_R ABUT < 90 REGION) NOT INSIDE (SRAM_REGION OR ((NJFET_4V_DMY OR PJFET_4V_DMY) OR (ANALOG INTERACT JDMY)))
}
#ENDIF // _COEN1_
#ENDIF // CHECK_COEN1_

#IFDEF CHECK_COEN11_
#IFDEF _COEN11_
DRC UNSELECT CHECK RR:RE:SP:CO.EN.1.1

// <RR:RE:SP:CO.EN.1.1> is checked by RR:RE:SP:CO.EN.1.1.a

RR:RE:SP:CO.EN.1.1.a { @ Recommended enclosure by OD [at least two opposite sides](except 4V_NJFET region) >= ^CO_EN_1_1_R um
  X = RECTANGLE ENCLOSURE COEN11_CO OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_1_R OPPOSITE CO_EN_1 CO_EN_1_1_R OPPOSITE
  Y = ENC [X] OD < CO_EN_1_1_R ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  (INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION) NOT INSIDE (SRAM_REGION OR NJFET_4V_DMY)  // adjacent narrow sides
}
#ENDIF // _COEN11_
#ENDIF // CHECK_COEN11_

#IFDEF CHECK_M1EN1_M1EN2_
#IFDEF _M1EN1_M1EN2_
// M1.EN.0.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
// M1.EN.1.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
// M1.EN.2.R is checked by RR:RE:FP:M1.EN.1__M1.EN.2
DRC UNSELECT CHECK RR:RE:FP:M1.EN.1__M1.EN.2

// <RR:RE:FP:M1.EN.1__M1.EN.2> is checked by RR:RE:FP:M1.EN.1.a__M1.EN.2.a
RR:RE:FP:M1.EN.1.a__M1.EN.2.a { @ Enclosure of CO at least two opposite sides(except 2.5V_PO_JFET region) ^M1_EN_2_R um/Enclosure of CO ^M1_EN_1_R um
  A = RECTANGLE ENCLOSURE M1EN1_M1EN2_CO M1s ABUT > 0 < 90 GOOD 0 M1_EN_2_R OPPOSITE 0 M1_EN_2_R OPPOSITE
  (ENC A M1s < M1_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE ((SRAM_EXCLUDE OR SRAM_REGION) OR JDMY)
}
#ENDIF // _M1EN1_M1EN2_
#ENDIF // CHECK_M1EN1_M1EN2_

#ENDIF // Recommended

#IFDEF Guideline
#IFDEF CHECK_COR5_
#IFDEF _COR5_
DRC UNSELECT CHECK RR:GL:CO.R.5

// <RR:GL:CO.R.5> is checked by RR:GL:CO.R.5.a

RR:GL:CO.R.5.a { @ Recommended to use redundant CO to avoid high Rc whenever layout allows. (except 2.5V_PO_JFET & 4V_NJFET region)
  (((FPO1 AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE (SRAM_REGION OR (NJFET_4V_DMY OR JDMY))
  (((SD AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE (SRAM_REGION OR (NJFET_4V_DMY OR JDMY))
  (((DSTP AND M1) INTERACT COR5_CO == 1) AND COR5_CO) NOT INSIDE (SRAM_REGION OR (NJFET_4V_DMY OR JDMY))
}
#ENDIF // _COR5_
#ENDIF // CHECK_COR5_

#ENDIF //Guideline

#ENDIF // END DFM CHECK 

#IFDEF GUIDELINE_ESD
ESD.WARN.3 { @ SDI INTERACT { {ANALOG INTERACT JDMY} OR HVJDMY } is not allowed. Please consult TSMC in advance if there is any special requirement.
    SDI INTERACT ((ANALOG INTERACT JDMY) OR HVJDMY)
}
#ENDIF // GUIDELINE_ESD

// AVT CHECKS
//=====================

AVT_R = COPY AVTs
// waive one track overlap 	  
AVT_A1 = INT AVTs < AVT_W_1 ABUT < 90 REGION PROJ==0
AVT_B1 = AVT_R NOT (EXPAND EDGE AVT_R INSIDE BY AVT_R_3/2)	
AVT_C1 = EXT AVT_B1 < GRID SINGULAR INTERSECTING ONLY REGION
AVT_D1 = AVT_A1 ENCLOSE AVT_C1
// waive one track space
AVT_A2 = EXT AVTs < AVT_S_1 ABUT < 90 REGION PROJ==0
AVT_B2 = AVT_R OR (EXPAND EDGE AVT_R OUTSIDE BY AVT_R_3/2)
AVT_C2 = EXT AVT_B2 < GRID SINGULAR INTERSECTING ONLY REGION
AVT_D2  = AVT_A2 ENCLOSE AVT_C2
// waive point touch
AVT_P = EXT AVT_R < AVT_S_1 SINGULAR INTERSECTING ONLY REGION

AVT.W.1 { @ Width >= ^AVT_W_1. One-track(^AVT_R_3) overlap is allowed
  X = INT AVTs < AVT_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT AVT_D1)) NOT INSIDE SRAM_EXCLUDE
}
AVT_P_GATE = (GATE AND PP) AND AVT
AVT_P_GATE_W = AVT_P_GATE INSIDE EDGE OD
AVT.W.2 { @ Channel length of {{GATE AND PP} AND AVT} >= ^AVT_W_2
  INT AVT_P_GATE_W < AVT_W_2 ABUT < 90 REGION
}
AVT_N_GATE = (GATE AND NP) AND AVT
AVT_N_GATE_W = AVT_N_GATE INSIDE EDGE OD
AVT.W.3 { @ Channel length of {{GATE AND NP} AND AVT} >= ^AVT_W_3
  INT AVT_N_GATE_W < AVT_W_3 ABUT < 90 REGION
}
AVT.S.1 { @ Space >= ^AVT_S_1. Point touch of corners is allowed. One-track(^AVT_R_3) space is allowed.
  X = EXT AVTs < AVT_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (AVT_D2 OR AVT_P))) NOT INSIDE SRAM_EXCLUDE
}
AVT.S.2__AVT.S.3 { @ Space to gate in PO endcap direction >= ^AVT_S_2 & in S/D direction ({ACTIVE OR GATE} cut CORELDD_IO is not allowed) >= ^AVT_S_3
  A = GATE NOT INTERACT AVT
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (AVT_S_3 - AVT_S_2)) OR A
  C = SIZE B BY AVT_S_2
  AVT AND C

  (DACT OR GATE) CUT AVT
}

// AVT.S.2 and AVT.S.3 are checked by AVT.S.2__AVT.S.3
AVT.S.4 { @ Space to unsilicided PO/OD resistor >= ^AVT_S_3
  EXT AVT ODPO_RES_RPO < AVT_S_4 ABUT < 90 SINGULAR
  AND AVT ODPO_RES_RPO    
}  
AVT.EN.1__AVT.EN.2 { @ Enclosure of gate in S/D direction >= ^AVT_EN_1 & in PO endcap direction >= ^AVT_EN_2 
  A = GATE INTERACT AVT
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (AVT_EN_1 - AVT_EN_2)) OR A
  C = SIZE B BY AVT_EN_2
  C NOT AVT
}
// AVT.EN.1 and AVT.EN.2 are checked by AVT.EN.1__AVT.EN.2
AVT.A.1 { @ Area >= ^AVT_A_1
  (AREA AVTs < AVT_A_1) NOT INSIDE SRAM_EXCLUDE
}
AVT.A.2 { @ Enclosed area >= ^AVT_A_2
  A = HOLES AVT INNER
  B = A NOT AVT
  AREA B < AVT_A_2
}
AVT.L.1 { @ 45-degree edge length >= 0.5 
  AVT_45ANGLE = AVT ANGLE == 45
  (LENGTH AVT_45ANGLE < AVT_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}
AVT.R.1 { @ Overlap of VAR, VTH_N, VTL_N, ULVT_N, ELVT_N, EHVT_N, VTH_P, VTL_P, ULVT_P, ELVT_P, EHVT_P, TCDDMY, {OD AND NWDMY}, ROM, BJTDMY, RH, POFUSE, HVD_N, HVD_P, or OD2 is not allowed   
  AVT AND VAR
  AVT AND VTHN
  AVT AND VTLN
  AVT AND ULVT_N
  AVT AND ELVTN
  AVT AND EHVTN
  AVT AND VTHP
  AVT AND VTLP
  AVT AND ULVT_P
  AVT AND ELVTP
  AVT AND EHVTP
  AVT AND TCDDMY
  AVT AND (OD AND NWDMY)
  AVT AND ROM
  AVT AND BJTDMY
  AVT AND RH
  AVT AND POFUSE
  AVT AND HVD_N
  AVT AND HVD_P
  AVT AND OD2
}
// AVT.R.2 and AVT.R.3 are checked by AVT.W.1 and AVT.S.1

// N_AVT CHECKS
//=====================
N_AVT_N_GATE = ((GATE AND NP) AND NTN) AND AVT
N_AVT_N_GATE_W = N_AVT_N_GATE INSIDE EDGE OD
N_AVT.W.1 { @ Channel length of {{{GATE AND NP} AND NT_N} AND AVT} >= ^N_AVT_W_1
  INT N_AVT_N_GATE_W < N_AVT_W_1 ABUT < 90 REGION
}
N_AVT.R.1 { @ NT_N must be inside AVT for native AVT device
	TARGET_NTN = NTN INTERACT N_AVT_N_GATE
	TARGET_NTN NOT AVT
}

// ULP_WR CHECKS
//=====================
ULP_WR.R.1 { @ ULP_WR must drawn identically to GATE
				 @ ULP_WR cannot be stand-alone without GATE
	ULP_WR NOT INTERACT GATE
	CHECK_GATE = GATE INTERACT ULP_WR
	ULP_WR XOR CHECK_GATE
}


M3_MOMlike_S = EXT (M3 AND LNP) == 0.1 ABUT < 90 OPPOSITE REGION // LNP.S.3
M3_MOMlike_W = INT (M3 AND LNP) < 1.5 ABUT < 90 OPPOSITE EXCLUDE SHIELDED REGION
M3_MOMlike_not = INT (M3_MOMlike_S OR M3_MOMlike_W) == 0.1 ABUT < 90 OPPOSITE REGION // LNP.W.3
M3_MOMlike = ((M3_MOMlike_S OR M3_MOMlike_W) NOT M3_MOMlike_not) INTERACT M3_MOMlike_W > 2

// Low Noise Pad Layout Rules
//=====================
LNP.W.1 { @ Width of LNP (the edge parallel to nearby chip edge) = 45~50 
  LENGTH LNP < LNP_W_1_MIN
  LENGTH (LNP COIN OUTSIDE EDGE SEALRING_ORI) > LNP_W_1_MAX
}
LNP.W.1.1 { @ Length of LNP (the edge perpendicular to nearby chip edge) = 50~65 
  LNP_EDGE_CHK = LNP TOUCH EDGE (INT [LNP] (LNP COIN OUTSIDE EDGE SEALRING_ORI) < GRID ABUT == 90 INTERSECTING ONLY)
  LENGTH LNP_EDGE_CHK < LNP_W_1_1_MIN
  LENGTH LNP > LNP_W_1_1_MAX
}
LNP.W.2:M6 { @ Width of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 2 
  M6_CHK = M6 AND (LNP AND SEALRING_ALL)
  M6_CHK NOT WITH WIDTH == LNP_W_2
}

LNP.W.2:M5 { @ Width of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 2 
  M5_CHK = M5 AND (LNP AND SEALRING_ALL)
  M5_CHK NOT WITH WIDTH == LNP_W_2
}


LNP.W.2:M3 { @ Width of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 2 
  M3_CHK = M3 AND (LNP AND SEALRING_ALL)
  M3_CHK NOT WITH WIDTH == LNP_W_2
}

LNP.W.3 { @ Width of {Mtop-2 AND LNP} = 1.5 
  INT (M4 AND LNP) < LNP_W_3 ABUT < 90 SINGULAR REGION
  (M4 AND LNP) NOT WITH WIDTH == LNP_W_3
}
LNP.W.4 { @ Width of {Mtop-3 AND LNP} in MOM-like region Definition of MOM-like region: Number of metal line >= 3, Space = 0.1 um, PRL = 45.76 um = 0.1 
  M3_MOMlike_W NOT WITH WIDTH == LNP_W_4
}
LNP.S.1:M6 { @ Space of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  M6_CHK = M6 AND (LNP AND SEALRING_ALL)
  EXT M6_CHK < LNP_S_1 ABUT < 90 OPPOSITE REGION
  M6_MERGE = SIZE M6_CHK BY LNP_S_1/2
  M6_MERGE INTERACT M6_CHK != LNP_R_6
}

LNP.S.1:M5 { @ Space of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  M5_CHK = M5 AND (LNP AND SEALRING_ALL)
  EXT M5_CHK < LNP_S_1 ABUT < 90 OPPOSITE REGION
  M5_MERGE = SIZE M5_CHK BY LNP_S_1/2
  M5_MERGE INTERACT M5_CHK != LNP_R_6
}


LNP.S.1:M3 { @ Space of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  M3_CHK = M3 AND (LNP AND SEALRING_ALL)
  EXT M3_CHK < LNP_S_1 ABUT < 90 OPPOSITE REGION
  M3_MERGE = SIZE M3_CHK BY LNP_S_1/2
  M3_MERGE INTERACT M3_CHK != LNP_R_6
}

LNP.S.2 { @ Space to Mtop-3 line-end [width= 0.1 um, INSIDE LNP] = 0.12 
  M3_lineend = LENGTH (CONVEX EDGE (M3 AND LNP) ANGLE1 == 90 ANGLE2 == 90) == LNP_W_4
  EXT M3_lineend M3 < LNP_S_2 ABUT < 90 OPPOSITE REGION
  EXT (M3_lineend) M3 <= LNP_S_2 ABUT < 90 OPPOSITE
}
LNP.S.3 { @ Space of Mtop-3 [width= 0.1 um, INSIDE LNP] = 0.1 
  EXT M3_MOMlike_W < LNP_S_3 ABUT < 90 OPPOSITE REGION
  M3_S_CHK = EXT M3_MOMlike_W < 0.30 ABUT < 90 OPPOSITE REGION
  ENCLOSE RECTANGLE M3_S_CHK LNP_W_4L LNP_S_3+GRID ORTHOGONAL ONLY
  LNP INTERACT M3_MOMlike > 1
}
LNP.R.1:M6 { @ Mtop/Mtop-1/Mtop-2/Mtop-3 [within {LNP AND SEALRING_ALL}] must connect to inner seal-ring   
  M6_CHK = M6 AND (LNP AND SEALRING_ALL)
  M6_CHK NOT INTERACT SEALRING_ORI
}
LNP.R.1:M5 { @ Mtop/Mtop-1/Mtop-2/Mtop-3 [within {LNP AND SEALRING_ALL}] must connect to inner seal-ring   
  M5_CHK = M5 AND (LNP AND SEALRING_ALL)
  M5_CHK NOT INTERACT SEALRING_ORI
}
LNP.R.1:M4 { @ Mtop/Mtop-1/Mtop-2/Mtop-3 [within {LNP AND SEALRING_ALL}] must connect to inner seal-ring   
  M4_CHK = M4 AND (LNP AND SEALRING_ALL)
  M4_CHK NOT INTERACT SEALRING_ORI
}
LNP.R.1:M3 { @ Mtop/Mtop-1/Mtop-2/Mtop-3 [within {LNP AND SEALRING_ALL}] must connect to inner seal-ring   
  M3_CHK = M3 AND (LNP AND SEALRING_ALL)
  M3_CHK NOT INTERACT SEALRING_ORI
}
LNP.R.2 { @ VIAtop-3 [INSIDE LNP] is not allowed   
  VIA2 AND LNP
}
LNP.R.3:M6 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT M6
}
LNP.R.3:M5 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT M5
}
LNP.R.3:M4 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT M4
}
LNP.R.3:M3 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT M3
}
LNP.R.3:VIA5 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT VIA5
}
LNP.R.3:VIA4 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT VIA4
}
LNP.R.3:VIA3 { @ {LNP NOT SEALRING_ALL} must interact with Mtop, Mtop-1, Mtop-2, Mtop-3, VIAtop, VIAtop-1, and VIAtop-2   
  (LNP NOT SEALRING_ALL) NOT INTERACT VIA3
}
LNP.R.5 { @ It is not allowed to connect low noise pattern and sealring by AP DRC check: {AP AND SEALRING_ALL} INTERACT {LNP NOT SEALRING_ALL}   
  (AP AND SEALRING_ALL) INTERACT (LNP NOT SEALRING_ALL)
}
LNP.R.6:M6 { @ The number of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  (LNP AND SEALRING_ALL) INTERACT (M6 AND (LNP AND SEALRING_ALL)) != LNP_R_6
  (LNP AND SEALRING_ALL) NOT INTERACT M6 
}

LNP.R.6:M5 { @ The number of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  (LNP AND SEALRING_ALL) INTERACT (M5 AND (LNP AND SEALRING_ALL)) != LNP_R_6
  (LNP AND SEALRING_ALL) NOT INTERACT M5 
}


LNP.R.6:M3 { @ The number of Mtop/Mtop-1/Mtop-3 [within {LNP AND SEALRING_ALL}] = 6 
  (LNP AND SEALRING_ALL) INTERACT (M3 AND (LNP AND SEALRING_ALL)) != LNP_R_6
  (LNP AND SEALRING_ALL) NOT INTERACT M3 
}

LNP.R.7 { @ The number of Mtop-2 [within {LNP AND SEALRING_ALL}] = 1 
  (LNP AND SEALRING_ALL) INTERACT (M4 AND (LNP AND SEALRING_ALL)) != LNP_R_7
  (LNP AND SEALRING_ALL) NOT INTERACT M4
}
LNP.R.9 { @ VIAtop-2 is not allowed in MOM-like region [INSIDE LNP] Definition of MOM-like region: Number of metal line >= 3, Space = 0.1 um, PRL = 45.76 um   
  VIA3 AND M3_MOMlike
}
LNP.R.10 { @ Mtop-3 [INSIDE LNP] is only offered for Mx   
  NOUSEM3 INSIDE LNP
}
LNP.R.12 { @ LNP must abut inner seal-ring when seal-ring is added by customer   
  LNP NOT INTERACT SEALRING_ORI
  LNP INSIDE EDGE SEALRING_ORI
}
#IFNDEF WIRE_BOND
LNP_FC.R.8:M6 { @ {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} must be mesh type [regular holes with metal width = 2 um and hole width = 4~7 um] DRC flag: 1. Width (W4) of {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} is not 2 um (except 45-degree corners), or 2. Hole width (C) of {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} is not 4~7 um   
  M6_CHK = (M6 AND LNP) NOT SEALRING_ALL
  M6_CHK NOT WITH WIDTH == LNP_FC_R_8
  NOT ENCLOSE RECTANGLE (HOLES M6_CHK INNER) LNP_FC_R_8_MIN LNP_FC_R_8_MIN ORTHOGONAL ONLY
  ENCLOSE RECTANGLE (HOLES M6_CHK INNER) LNP_FC_R_8_MAX+GRID LNP_FC_R_8_MAX+GRID ORTHOGONAL ONLY
}
LNP_FC.R.8:M5 { @ {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} must be mesh type [regular holes with metal width = 2 um and hole width = 4~7 um] DRC flag: 1. Width (W4) of {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} is not 2 um (except 45-degree corners), or 2. Hole width (C) of {{Mtop/Mtop-1 AND LNP} NOT SEALRING_ALL} is not 4~7 um   
  M5_CHK = (M5 AND LNP) NOT SEALRING_ALL
  M5_CHK NOT WITH WIDTH == LNP_FC_R_8
  NOT ENCLOSE RECTANGLE (HOLES M5_CHK INNER) LNP_FC_R_8_MIN LNP_FC_R_8_MIN ORTHOGONAL ONLY
  ENCLOSE RECTANGLE (HOLES M5_CHK INNER) LNP_FC_R_8_MAX+GRID LNP_FC_R_8_MAX+GRID ORTHOGONAL ONLY
}
#ENDIF


// SRAM CHECKS
//=====================
SRAM.R.43 { @ SRM_ULL (50;28) must be drawn identically to SRAMDMY;0 (186;0)   
	SRM_ULL XOR (SRAMDMY INTERACT SRM_ULL)
}
SRAM.WARN.3 { @ Warning: It is important to add more write/read assist and redundancy to meet product Vmin spec, if 0.299 um2 SRAM area in one chip is > 645,000 um2 (e.g. 2Mb of 0.299 um2 cell). DRC only flags the 0.299 um2 {SRM_HD (80;14) AND SRM_ULL (50;28)} area in one chip > 645,000 um2. For write/read assist and redundancy implementation, please refer to T-N40-CL-CL-012   
  SRM_CHECK_AREA = SRM_ULL AND SRMLOP14
  DENSITY SRM_CHECK_AREA > SRAM_WARN_3 INSIDE OF LAYER CHIPx
  [AREA(SRM_CHECK_AREA)] RDB SRAM.WARN.3.rep
}
SRAM.WARN.4 { @ Warning: It is important to add more write/read assist and redundancy to meet product Vmin spec, if 0.374 um2 SRAM area in one chip is > 807,000 um2 (e.g. 2Mb of 0.374 um2 cell). DRC only flags the 0.374 um2 {SRM_HC (80;13) AND SRM_ULL (50;28)} area in one chip > 807,000 um2. For write/read assist and redundancy implementation, please refer to T-N40-CL-CL-012   
  SRM_CHECK_AREA = SRM_ULL AND SRMLOP13
  DENSITY SRM_CHECK_AREA > SRAM_WARN_4 INSIDE OF LAYER CHIPx
  [AREA(SRM_CHECK_AREA)] RDB SRAM.WARN.4.rep
}
SRAM.WARN.5 { @ Warning: It is important to add more write/read assist and redundancy to meet product Vmin spec, if 0.741 um2 SRAM area in one chip is > 800,000 um2 (e.g. 1Mb of 0.741 um2 cell). DRC only flags the 0.741 um2 {SRM_10TTP (80;18) AND SRM_ULL (50;28)} area in one chip > 800,000 um2. For write/read assist and redundancy implementation, please refer to T-N40-CL-CL-020   
  SRM_CHECK_AREA = SRM_ULL AND TPLOP_10T
  DENSITY SRM_CHECK_AREA > SRAM_WARN_5 INSIDE OF LAYER CHIPx
  [AREA(SRM_CHECK_AREA)] RDB SRAM.WARN.5.rep
}

#IFDEF FULL_CHIP
#IFNDEF WITH_SEALRING
CSR.R.1:EHVTNi { @ EHVTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND EHVTNi
}
CSR.R.1:EHVTPi { @ EHVTPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND EHVTPi
}
CSR.R.1:ELVTNi { @ ELVTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ELVTNi
}
CSR.R.1:ELVTPi { @ ELVTPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ELVTPi
}
CSR.R.1:AVTi { @ AVTi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND AVTi
}
CSR.R.1:ULP_WR { @ ULP_WR is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ULP_WR
}
CSR.R.1:SRM_ULL { @ SRM_ULL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRM_ULL
}
CSR.R.1:LNP { @ LNP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LNP
}
CSR.R.1:SERPDMY { @ SERPDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SERPDMY
}
CSR.R.1:ANALOG { @ ANALOG is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ANALOG
}
CSR.R.1:JDMY { @ JDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JDMY
}
CSR.R.1:JNW { @ JNW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JNW
}
CSR.R.1:HVJDMY { @ HVJDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HVJDMY
}
CSR.R.1:JFETDMY_1 { @ JFETDMY_1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JFETDMY_1
}
CSR.R.1:JFETDMY_2 { @ JFETDMY_2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JFETDMY_2
}
CSR.R.1:JFETDMY_4 { @ JFETDMY_4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JFETDMY_4
}
CSR.R.1:JFETDMY_5 { @ JFETDMY_5 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND JFETDMY_5
}
CSR.R.1:FGDDMY { @ FGDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND FGDDMY
}
CSR.R.1:SBDDMYi { @ SBDDMYi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SBDDMYi
}
#ENDIF // WITH_SEALRING
#ENDIF // FULL_CHIP

